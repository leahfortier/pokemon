// The name of each pokemon effect and its contents.
// Blocks are separated by '*'
// Any function must be terminated by +++ on a line by itself
// Fields can be specified in any order

LeechSeed:
	EffectType: EndTurn
	FailTypes: Grass
	FailMessage: if (victim.isType(Type.GRASS)) return "It doesn't affect "+victim.getName()+"!";
	if (victim.hasEffect("LeechSeed")) return victim.getName()+" is already seeded!";
	+++
	CastMessage: victim.getName()+" was seeded!"
	Apply: if (victim.hasAbility("Magic Guard")) return;
	b.addMessage(victim.getName()+"'s health was sapped!");
	b.getOtherPokemon(victim.user()).sapHealth(victim, victim.reduceHealthFraction(b, 1/8.0), b, false);
	+++
	RapidSpin: user.getName()+" was released from leech seed!"
	EffectType: Passable
*
BadPoison:
	Field: private int turns;
	+++
	GetTurns: return turns;
	+++
	FailCondition: !Status.applies(StatusCondition.POISONED, b, caster, victim)
	CanHave
	Cast: super.cast(b, caster, victim, source, printCast);
	Status.giveStatus(b, caster, victim, StatusCondition.POISONED);
	+++
	EffectType: EndTurn
	Apply: turns++;
	+++
*
Flinch:
	EffectType: BeforeTurn
	FailAbility: Inner Focus
	OtherFail: !b.isFirstAttack()
	CastMessage: victim.getName()+" flinched!"
	CanAttack: return false;
	+++
	NumTurns: 1
	Cast: super.cast(b, caster, victim, source, printCast);
	if (victim.hasAbility("Steadfast"))
	{
		victim.getAttributes().modifyStage(victim, victim, 1, Stat.SPEED, b, CastSource.ABILITY);
	}
	+++
*
FireSpin:
	EffectType: EndTurn
	EffectType: Trapping
	MinTurns: 4
	MaxTurns: 5
	CastMessage: victim.getName()+" was trapped in the fiery vortex!"
	SubsideMessage: victim.getName()+" is no longer trapped by fire spin."
	PartialTrap: victim.getName()+" is hurt by fire spin!"
	RapidSpin: user.getName()+" was released from fire spin!"
	NextTurnSubside
*
MagmaStorm:
	EffectType: EndTurn
	EffectType: Trapping
	MinTurns: 4
	MaxTurns: 5
	CastMessage: victim.getName()+" was trapped by swirling magma!"
	SubsideMessage: victim.getName()+" is no longer trapped by magma storm."
	PartialTrap: victim.getName()+" is hurt by magma storm!"
	RapidSpin: user.getName()+" was released from magma storm!"
	NextTurnSubside
*
Clamped:
	EffectType: EndTurn
	EffectType: Trapping
	MinTurns: 4
	MaxTurns: 5
	CastMessage: user.getName()+" clamped "+victim.getName()+"!"
	SubsideMessage: victim.getName()+" is no longer trapped by clamp."
	PartialTrap: victim.getName()+" is hurt by clamp!"
	RapidSpin: user.getName()+" was released from clamp!"
	NextTurnSubside
*
Whirlpool:
	EffectType: EndTurn
	EffectType: Trapping
	MinTurns: 4
	MaxTurns: 5
	CastMessage: victim.getName()+" was trapped in the vortex!"
	SubsideMessage: victim.getName()+" is no longer trapped by whirlpool."
	PartialTrap: victim.getName()+" is hurt by whirlpool!"
	RapidSpin: user.getName()+" was released from whirlpool!"
	NextTurnSubside
*
Wrapped:
	EffectType: EndTurn
	EffectType: Trapping
	MinTurns: 4
	MaxTurns: 5
	CastMessage: victim.getName()+" was wrapped by "+user.getName()+"!"
	SubsideMessage: victim.getName()+" was freed from wrap."
	PartialTrap: victim.getName()+" is hurt by wrap!"
	RapidSpin: user.getName()+" was released from wrap!"
	NextTurnSubside
*
Binded:
	EffectType: EndTurn
	EffectType: Trapping
	MinTurns: 4
	MaxTurns: 5
	CastMessage: victim.getName()+" was binded by "+user.getName()+"!"
	SubsideMessage: victim.getName()+" was freed from bind."
	PartialTrap: victim.getName()+" is hurt by bind!"
	RapidSpin: user.getName()+" was released from bind!"
	NextTurnSubside
*
SandTomb:
	EffectType: EndTurn
	EffectType: Trapping
	MinTurns: 4
	MaxTurns: 5
	CastMessage: victim.getName()+" was trapped by sand tomb!"
	SubsideMessage: victim.getName()+" is no longer trapped from sand tomb."
	PartialTrap: victim.getName()+" is hurt by sand tomb!"
	RapidSpin: user.getName()+" was released from sand tomb!"
	NextTurnSubside
*
Protecting:
	EffectType: OpposingBeforeTurn
	NumTurns: 1
	OpposingCanAttack: if (p.getAttack().isSelfTarget() || p.getAttack().isMoveType("ProtectPiercing")) return true;
	b.printAttacking(p);
	b.addMessage(opp.getName()+" is protecting itself!");
	if (p.getAttack() instanceof CrashDamageMove) ((CrashDamageMove)p.getAttack()).crash(b, p);
	return false;
	+++
	Cast: if (Math.random() > caster.getAttributes().getSuccessionDecayRate())
	{
		b.addMessage("...but it failed!");
		return;
	}
	super.cast(b, caster, victim, source, printCast);
	+++
	CastMessage: victim.getName()+" protected itself!"
*
QuickGuard:
	EffectType: OpposingBeforeTurn
	NumTurns: 1
	OpposingCanAttack: if (p.getAttack().isSelfTarget() || p.getAttack().getName().equals("Feint") || p.getAttack().getPriority(b, p) <= 0) return true;
	b.printAttacking(p);
	b.addMessage(opp.getName()+" is protecting itself!");
	if (p.getAttack() instanceof CrashDamageMove) ((CrashDamageMove)p.getAttack()).crash(b, p);
	return false;
	+++
	Cast: if (Math.random() > caster.getAttributes().getSuccessionDecayRate())
	{
		b.addMessage("...but it failed!");
		return;
	}
	super.cast(b, caster, victim, source, printCast);
	+++
	CastMessage: victim.getName()+" protected itself!"
*
Bracing:
	NumTurns: 1
	Cast: if (Math.random() > caster.getAttributes().getSuccessionDecayRate())
	{
		b.addMessage("...but it failed!");
		return;
	}
	super.cast(b, caster, victim, source, printCast);
	+++
	CastMessage: user.getName()+" braced itself!"
	EffectType: Bracing
	Bracing: return true;
	+++
	BraceMessage: bracer.getName()+" endured the hit!"
*
Confusion:
	EffectType: Passable
	EffectType: BeforeTurn
	FailAbility: Own Tempo
	FailMessage: if (victim.hasEffect("Confusion")) return victim.getName()+" is already confused!";
	if (victim.hasAbility("Own Tempo")) return victim.getName()+"'s Own Tempo prevents confusion!";
	+++
	Field: private int turns;
	+++
	CanAttack: if (turns == 0)
	{
		b.addMessage(p.getName()+" snapped out of its confusion!");
		super.active = false;
		return true;
	}
	turns--;
	b.addMessage(p.getName()+" is confused!");
	if (Math.random()*100 < 50)
	{
		b.addMessage("It hurt itself in confusion!");
		Move temp = p.getMove();
		p.setMove(new Move(Attack.getAttack("ConfusionDamage")));
		b.applyDamage(p, b.damageCalc(p, p));
		p.setMove(temp);
		return false;
	}
	return true;
	+++
	Activate: x.turns = (int)(Math.random()*4)+1; // Between 1 and 4 turns
	+++
	CastMessage: victim.getName()+" became confused!"
	Cast: super.cast(b, caster, victim, source, printCast);
	if (victim.isHoldingItem(b, "Persim Berry"))
	{
		b.addMessage(victim.getName()+"'s Persim Berry snapped it out of confusion!");
		victim.getAttributes().removeEffect("Confusion");
		victim.consumeItem(b);
	}
	+++
*
SelfConfusion:
	EffectType: ForceMove
	Field: private Move move;
	+++
	MinTurns: 2
	MaxTurns: 3
	Subside: Confusion c = new Confusion();
	if (c.applies(b, p, p, CastSource.EFFECT))
	{
		b.addMessage(p.getName()+" became confused due to fatigue!");
		p.addEffect(c);
	}
	+++
	GetMove: return move;
	+++
	Cast: move = caster.getMove();
	super.cast(b, caster, victim, source, printCast);
	+++
	Activate: x.move = move;
	+++
*
Safeguard:
	CastMessage: user.getName()+" is covered by a veil!"
	SubsideMsg: "The effects of "+victim.getName()+"'s Safeguard faded."
	NumTurns: 5
	Defog: "The effects of "+victim.getName()+"'s Safeguard faded."
	EffectType: StatusPrevention
	StatusPrevent: return !caster.hasAbility("Infiltrator");
	+++
	StatusPreventMessage: "Safeguard protects "+victim.getName()+" from status conditions!"
*
GuardSpecial:
	SubsideMsg: "The effects of "+victim.getName()+"'s Guard Special faded."
	NumTurns: 5
	EffectType: StatusPrevention
	StatusPrevent: return !caster.hasAbility("Infiltrator");
	+++
	StatusPreventMessage: "Guard Special protects "+victim.getName()+" from status conditions!"
*
Encore:
	EffectType: AttackSelection
	EffectType: ForceMove
	Field: private Move move;
	+++
	NumTurns: 3
	SubsideMsg: "The effects of "+victim.getName()+"'s encore faded."
	GetMove: return move;
	+++
	Usable: return move.getAttack().getName().equals(m.getAttack().getName());
	+++
	UnusableMsg: "Only "+move.getAttack().getName()+" can be used right now!"
	FailCondition: victim.getAttributes().getLastMoveUsed() == null || victim.getAttributes().getLastMoveUsed().getPP() == 0 || victim.getAttributes().getLastMoveUsed().getAttack().isMoveType("Encoreless")
	CastMsg: victim.getName()+" got an encore!"
	Cast: move = victim.getAttributes().getLastMoveUsed();
	super.cast(b, caster, victim, source, printCast);
	+++
	Activate: x.move = move;
	+++
	EffectType: BeforeTurn
	CanAttack: if (!p.getAttack().getName().equals(move.getAttack().getName()))
	{
		b.printAttacking(p);
		b.addMessage("...but it failed!");
		return false;
	}
	return true;
	+++
	EffectType: EndTurn
	Apply: if (move.getPP() == 0) active = false; // If the move runs out of PP, Encore immediately ends
	+++
*
Disable:
	EffectType: AttackSelection
	EffectType: MoveCondition
	Field: private Move disabled;
	private int turns;
	+++
	Activate: x.disabled = disabled;
	x.turns = (int)(Math.random()*4)+4; // Between 4 and 7 turns
	+++
	Usable: return !disabled.getAttack().getName().equals(m.getAttack().getName());
	+++
	UnusableMsg: disabled.getAttack().getName()+" is disabled!"
	FailCondition: victim.getAttributes().getLastMoveUsed() == null || victim.getAttributes().getLastMoveUsed().getPP() == 0
	EffectType: BeforeTurn
	CanAttack: turns--;
	if (p.getAttack().getName().equals(disabled.getAttack().getName()))
	{
		b.printAttacking(p);
		b.addMessage(p.getAttack().getName()+" is disabled!");
		return false;
	}
	return true;
	+++
	ShouldSubside: return turns == 0;
	+++
	SubsideMsg: victim.getName()+"'s "+disabled.getAttack().getName()+" is no longer disabled!"
	CastMsg: victim.getName()+"'s "+disabled.getAttack().getName()+" was disabled!"
	Cast: disabled = victim.getAttributes().getLastMoveUsed();
	super.cast(b, caster, victim, source, printCast);
	+++
	GetMove: return disabled;
	+++
	FailMessage: if (victim.hasEffect("Disable")) return victim.getName()+" is already disabled!";
	+++
*
RaiseCrits:
	Field: private boolean focusEnergy;
	private boolean direHit;
	private boolean berrylicious;
	+++
	Activate: x.focusEnergy = false;
	x.direHit = false;
	x.berrylicious = false;
	+++
	EffectType: CritStage
	IncreaseCritStage: int stage = 0;
	if (focusEnergy) stage++;
	if (direHit) stage++;
	if (berrylicious) stage++;
	if (stage == 0) Global.error("RaiseCrits effect is not actually raising crits.");
	return stage;
	+++
	FailCondition: source == CastSource.USE_ITEM && victim.hasEffect("RaiseCrits") && ((RaiseCrits)victim.getEffect("RaiseCrits")).direHit
	CastMsg: victim.getName()+" is getting pumped!"
	CanHave
	Cast: if (!victim.hasEffect("RaiseCrits")) super.cast(b, caster, victim, source, printCast);
	else if (printCast) b.addMessage(getCastMessage(b, caster, victim));
	
	RaiseCrits e = (RaiseCrits)victim.getEffect("RaiseCrits");
	switch (source)
	{
		case ATTACK:
			e.focusEnergy = true;
			break;
		case USE_ITEM:
			e.direHit = true;
			break;
		case HELD_ITEM:
			e.berrylicious = true;
			break;
		default:
			Global.error("Unknown source for RaiseCrits effect.");
	}
	+++
	EffectType: Passable
*
ChangeItem:
	EffectType: ItemCondition
	Field: private Item item;
	+++
	Activate: x.item = item;
	+++
	Cast: item = ((ItemCondition)source.getSource(b, caster)).getItem();
	while (victim.getAttributes().removeEffect("ChangeItem"));
	super.cast(b, caster, victim, source, printCast);
	+++
	GetItem: return item;
	+++
	CanHave
*
ChangeType:
	EffectType: TypeCondition
	Field: private Type[] type;
	+++
	Activate: x.type = type;
	+++
	Cast: type = ((ChangeTypeMove)source.getSource(b, caster)).getType(b, caster, victim);
	while (victim.getAttributes().removeEffect("ChangeType"));
	super.cast(b, caster, victim, source, printCast);
	b.addMessage("", type, victim.user());
	+++
	GetType: return type;
	+++
	CastMessage: victim.getName()+" was changed to "+type[0].getName()+(type[1] == Type.NONE ? "" : "/"+type[1].getName())+" type!!"
	CanHave
	Subside: b.addMessage("", p.getType(), p.user());
	+++
*
ChangeAbility:
	EffectType: AbilityCondition
	Field: private Ability ability;
	private String message;
	+++
	Activate: x.ability = ability;
	x.message = message;
	+++
	Cast: ability = ((ChangeAbilityMove)source.getSource(b, caster)).getAbility(b, caster, victim);
	message = ((ChangeAbilityMove)source.getSource(b, caster)).getMessage(b, caster, victim);
	while (victim.getAttributes().removeEffect("ChangeAbility"));
	super.cast(b, caster, victim, source, printCast);
	+++
	GetAbility: return ability;
	+++
	CanHave
	CastMessage: message
*
Stockpile:
	Field: private int turns;
	+++
	Activate: x.turns = 0;
	+++
	GetTurns: return turns;
	+++
	EffectType: EndTurn
	Apply: if (!victim.getAttributes().getLastMoveUsed().getAttack().getName().equals("Stockpile")) active = false;
	+++
	CanHave
	Cast: if (!victim.hasEffect("Stockpile")) super.cast(b, caster, victim, source, printCast);
	Stockpile stockpile = (Stockpile)victim.getEffect("Stockpile");
	if (stockpile.turns < 3)
	{
		b.addMessage(victim.getName()+" Defense and Special Defense were raised!");
		stockpile.turns++;
		return;
	}
	b.addMessage("...but it failed!");
	+++
	EffectType: StageChanging
	StageChange: return s == Stat.DEFENSE || s == Stat.SP_DEFENSE ? stage+turns : stage;
	+++
	Subside: b.addMessage("The effects of "+p.getName()+"'s Stockpile ended!");
	b.addMessage(p.getName()+"'s Defense and Special Defense decreased!");
	+++
*
UsedDefenseCurl:
	CanHave
	Cast: if (!victim.hasEffect("UsedDefenseCurl")) super.cast(b, caster, victim, source, printCast);
	+++
*
UsedMinimize:
	CanHave
	Cast: if (!victim.hasEffect("UsedMinimize")) super.cast(b, caster, victim, source, printCast);
	+++
*
Mimic:
	Field: private Move mimicMove;
	+++
	EffectType: MoveListCondition
	GetMoveList: List<Move> list = new ArrayList<>();
	for (Move m : moves)
	{
		if (m.getAttack().getName().equals("Mimic")) list.add(mimicMove);
		else list.add(m);
	}
	return list;
	+++
	Cast: ActivePokemon other = b.getOtherPokemon(victim.user());
	Attack m = other.getAttributes().getLastMoveUsed() == null ? null : other.getAttributes().getLastMoveUsed().getAttack();
	if (m == null || victim.hasMove(m.getName()) || m.isMoveType("Mimicless"))
	{
		b.addMessage("...but it failed!");
		return;
	}
	mimicMove = new Move(m);
	super.cast(b, caster, victim, source, printCast);
	+++
	CastMsg: victim.getName()+" learned "+mimicMove.getAttack().getName()+"!"
	Activate: x.mimicMove = mimicMove;
	+++
*
Imprison:
	EffectType: AttackSelection
	Field: private List<String> unableMoves;
	+++
	Activate: x.unableMoves = unableMoves;
	+++
	Cast: unableMoves = new ArrayList<>();
	for (Move m : caster.getMoves()) unableMoves.add(m.getAttack().getName());
	super.cast(b, caster, victim, source, printCast);
	+++
	CastMsg: user.getName()+" sealed "+victim.getName()+"'s moves!"
	Usable: return !unableMoves.contains(m.getAttack().getName());
	+++
	UnusableMsg: "No!! You are imprisoned!!!"
	EffectType: BeforeTurn
	CanAttack: if (unableMoves.contains(p.getAttack().getName()))
	{
		b.printAttacking(p);
		b.addMessage("...but it failed!");
		return false;
	}
	return true;
	+++
*
Trapped:
	EffectType: Trapping
	CastMessage: user.getName()+" can't escape!"
*	
Foresight:
	CastMessage: user.getName()+" identified "+victim.getName()+"!"
	CanHave
	Cast: if (!victim.hasEffect("Foresight")) super.cast(b, caster, victim, source, printCast);
	else b.addMessage(getCastMessage(b, caster, victim));
	+++
*
MiracleEye:
	CastMessage: user.getName()+" identified "+victim.getName()+"!"
	CanHave
	Cast: if (!victim.hasEffect("MiracleEye")) super.cast(b, caster, victim, source, printCast);
	else b.addMessage(getCastMessage(b, caster, victim));
	+++
*
Torment:
	EffectType: AttackSelection
	Usable: return (p.getAttributes().getLastMoveUsed() == null || !p.getAttributes().getLastMoveUsed().getAttack().getName().equals(m.getAttack().getName()));
	+++
	UnusableMsg: p.getName()+" cannot use the same move twice in a row!"
	EffectType: BeforeTurn
	CanAttack: if (!usable(p, p.getMove()))
	{
		b.printAttacking(p);
		b.addMessage("...but it failed!");
		return false;
	}
	return true;
	+++
	CastMessage: user.getName()+" tormented "+victim.getName()+"!"
*	
Taunt:
	NumTurns: 3
	EffectType: AttackSelection
	Usable: return m.getAttack().getCategory() != Attack.Category.STATUS;
	+++
	UnusableMsg: "No!! Not while you're under the effects of taunt!!"
	EffectType: BeforeTurn
	CanAttack: if (!usable(p, p.getMove()))
	{
		b.printAttacking(p);
		b.addMessage("...but it failed!");
		return false;
	}
	return true;
	+++
	CastMessage: victim.getName()+" fell for the taunt!"
	SubsideMessage: "The effects of the taunt wore off."
*	
LockOn:
	NumTurns: 2
	CastMessage: user.getName()+" took aim!"
	EffectType: Passable
*
Telekinesis:
	NumTurns: 3
	CastMessage: victim.getName()+" was levitated due to "+user.getName()+"'s telekinesis!"
	FailCondition: victim.hasEffect("Ingrain")
	SubsideMessage: victim.getName()+" is no longer under the effects of telekinesis."
	EffectType: Levitation
*
Ingrain:
	EffectType: Trapping
	EffectType: EndTurn
	EffectType: Grounded
	EffectType: Passable
	Apply: if (victim.fullHealth() || victim.hasEffect("HealBlock")) return;
	int healAmount = victim.healHealthFraction(1/16.0);
	if (victim.isHoldingItem(b, "Big Root")) victim.heal((int)(healAmount*.3));
	b.addMessage(victim.getName()+" restored some HP due to ingrain!", victim.getHP(), victim.user());
	+++
	CastMessage: victim.getName()+" planted its roots!"
	Cast: super.cast(b, caster, victim, source, printCast);
	if (victim.hasEffect("MagnetRise"))
	{
		Effect.removeEffect(victim.getEffects(), "MagnetRise");
		b.addMessage("The effects of "+victim.getName()+"'s magnet rise were cancelled due to ingrain!");
	}
	if (victim.hasEffect("Telekinesis"))
	{
		Effect.removeEffect(victim.getEffects(), "Telekinesis");
		b.addMessage("The effects of telekinesis were cancelled due to ingrain!");
	}
	+++
*
Grounded:
	EffectType: Grounded
	Cast: super.cast(b, caster, victim, source, printCast);
	if (victim.isSemiInvulnerable() && (victim.getAttack().getName().equals("Fly") || victim.getAttack().getName().equals("Bounce")))
	{
		victim.getMove().switchReady(b);
		b.addMessage(victim.getName()+" fell to the ground!");
	}
	if (victim.hasEffect("MagnetRise"))
	{
		Effect.removeEffect(victim.getEffects(), "MagnetRise");
		b.addMessage("The effects of "+victim.getName()+"'s magnet rise was cancelled!");
	}
	if (victim.hasEffect("Telekinesis"))
	{
		Effect.removeEffect(victim.getEffects(), "Telekinesis");
		b.addMessage("The effects of telekinesis were cancelled!");
	}
	+++
*
Curse:
	EffectType: EndTurn
	EffectType: Passable
	Apply: if (victim.hasAbility("Magic Guard")) return;
	b.addMessage(victim.getName()+" was hurt by the curse!");
	victim.reduceHealthFraction(b, 1/4.0);
	+++
	CastMessage: user.getName()+" cut its own HP and put a curse on "+victim.getName()+"!"
	Cast: super.cast(b, caster, victim, source, printCast);
	caster.reduceHealthFraction(b, 1/2.0);
	+++
*
Yawn:
	NumTurns: 2
	FailCondition: !Status.applies(StatusCondition.ASLEEP, b, caster, victim)
	Subside: Status.giveStatus(b, b.getOtherPokemon(p.user()), p, StatusCondition.ASLEEP);
	+++
	CastMsg: victim.getName()+" grew drowsy!"
*
MagnetRise:
	EffectType: Levitation
	EffectType: Passable
	NumTurns: 5
	CastMessage: user.getName()+" levitated with electromagnetism!"
	FailCondition: victim.hasEffect("Ingrain")
	SubsideMessage: victim.getName()+" is no longer under the effects of magnet rise."
*
Uproar:
	NumTurns: 3
	SubsideMsg: "The uproar ended."
	Cast: uproar = victim.getMove();
	super.cast(b, caster, victim, source, printCast);
	ActivePokemon theOtherPokemon = b.getOtherPokemon(victim.user());
	if (victim.hasStatus(StatusCondition.ASLEEP))
	{
		b.addMessage("The uproar woke up "+victim.getName()+"!", StatusCondition.NONE, victim.user());
		victim.removeStatus();
	}
	if (theOtherPokemon.hasStatus(StatusCondition.ASLEEP))
	{
		b.addMessage("The uproar woke up "+theOtherPokemon.getName()+"!", StatusCondition.NONE, theOtherPokemon.user());
		theOtherPokemon.removeStatus();
	}
	+++
	Activate: x.uproar = uproar;
	+++
	Field: private Move uproar;
	+++
	EffectType: ForceMove
	GetMove: return uproar;
	+++
	CastMsg: user.getName()+" started an uproar!"
	Usable: return m.getAttack().getName().equals("Uproar");
	+++
	UnusableMsg: "Only Uproar can be used right now!"
	EffectType: AttackSelection
	EffectType: EndTurn
	Apply: if (uproar.getPP() == 0) active = false; // If uproar runs out of PP, the effect immediately ends
	+++
*
AquaRing:
	EffectType: Passable
	EffectType: EndTurn
	Apply: if (victim.fullHealth() || victim.hasEffect("HealBlock")) return;
	int healAmount = victim.healHealthFraction(1/16.0);
	if (victim.isHoldingItem(b, "Big Root")) victim.heal((int)(healAmount*.3));
	b.addMessage(victim.getName()+" restored some HP due to aqua ring!", victim.getHP(), victim.user());
	+++
	CastMessage: user.getName()+" surrounded itself with a veil of water!"
*
Nightmare:
	FailCondition: !victim.hasStatus(StatusCondition.ASLEEP)
	EffectType: EndTurn
	Apply: if (victim.hasAbility("Magic Guard")) return;
	b.addMessage(victim.getName()+" was hurt by its nightmare!");
	victim.reduceHealthFraction(b, 1/4.0);
	+++
	ShouldSubside: return !victim.hasStatus(StatusCondition.ASLEEP);
	+++
	CastMsg: victim.getName()+" began having a nightmare!"
*
Charge:
	NumTurns: 2
	EffectType: PowerChange
	GetMultiplier: return user.getAttack().getType(b, user) == Type.ELECTRIC ? 2 : 1;
	+++
*
Focusing:
	CastMessage: user.getName()+" began tightening its focus!"
	NumTurns: 1
*
FiddyPercentStronger:
	EffectType: PowerChange
	GetMultiplier: return 1.5;
	+++
	NumTurns: 1
*
Transformed:
	Field: private List<Move> moveList;
	private int[] stats;
	private Type[] type;
	+++
	Activate: x.moveList = moveList;
	x.stats = stats;
	x.type = type;
	+++
	CastMsg: victim.getName()+" transformed into "+b.getOtherPokemon(victim.user()).getPokemonInfo().getName()+"!"
	Cast: ActivePokemon transformee = b.getOtherPokemon(victim.user());
	stats = new int[Stat.NUM_STATS];
	for (int i = 0; i < stats.length; i++)
	{
		stats[i] = Stat.getStat(i, victim.getLevel(), transformee.getPokemonInfo().getStat(i), victim.getIV(i), victim.getEV(i), victim.getNature().getNatureVal(i));
	}
	stats[Stat.HP.index()] = victim.getStat(Stat.HP);
	moveList = new ArrayList<>();
	for (Move m : transformee.getMoves()) moveList.add(new Move(m.getAttack(), 5));
	for (int i = 0; i < Stat.NUM_BATTLE_STATS; i++) victim.getAttributes().setStage(i, transformee.getStage(i));
	type = transformee.getPokemonInfo().getType();
	super.cast(b, caster, victim, source, printCast);
	b.addMessage("", transformee.getPokemonInfo(), transformee.isShiny(), true, victim.user());
	b.addMessage("", victim.getType(), victim.user());
	+++
	FailCondition: b.getOtherPokemon(victim.user()).hasEffect("Transformed")
	EffectType: MoveListCondition
	EffectType: StatsCondition
	EffectType: TypeCondition
	GetMoveList: PokemonEffect mimic = p.getEffect("Mimic");
	if (mimic != null) return ((MoveListCondition)mimic).getMoveList(p, moveList);
	return moveList;
	+++
	GetStat: return stats[stat.index()];
	+++
	GetType: return type;
	+++
*
Substitute:
	EffectType: Integer
	Field: private int hp;
	+++
	Activate: x.hp = hp;
	+++
	Integer: hp
	EffectType: Passable
	CastMsg: victim.getName()+" put in a substitute!"
	Cast: hp = victim.reduceHealthFraction(b, .25)+1;
	super.cast(b, caster, victim, source, printCast);
	b.addMessage("", victim.getHP(), victim.user());
	+++
	FailCondition: victim.getHPRatio() <= .25 || victim.getStat(Stat.HP) <= 3
	EffectType: EffectBlocker
	ValidMove: if (user.getAttack().isSelfTarget() || user.getAttack().isMoveType("Field") || user.getAttack().isMoveType("SubstitutePiercing")) return true;
	if (user.getAttack().getCategory() == Category.STATUS) b.addMessage("...but it failed!");
	return false;
	+++
*	
Mist:
	NumTurns: 5
	CastMessage: user.getName()+" shrouded itself in mist!"
	SubsideMessage: "The mist faded."
	Defog: "The mist faded."
	EffectType: StatProtector
	Prevent: return !caster.hasAbility("Infiltrator");
	+++
	PreventMessage: "The mist prevents stat reductions!"
*
MagicCoat:
	CastMsg: user.getName()+" shrouded itself with a magic coat!"
	NumTurns: 1
*
Bide:
	Field: private Move move;
	private int turns;
	private int damage;
	+++
	EffectType: ForceMove
	GetMove: return move;
	+++
	EffectType: Integer
	Integer: damage
	GetTurns: return turns;
	+++
	CastMessage: user.getName()+" is storing energy!"
	Activate: x.move = move;
	x.turns = 1;
	x.damage = 0;
	+++
	Cast: Bide e = (Bide)victim.getEffect("Bide");
	if (e == null)
	{
		move = caster.getMove();
		super.cast(b, caster, victim, source, printCast);
		return;
	}
	
	if (e.turns > 0)
	{
		e.turns--;
		b.addMessage(getCastMessage(b, caster, victim));				
		return;
	}
	
	b.addMessage(victim.getName()+" released energy!");
	if (e.damage == 0) b.addMessage("...but it failed!");
	else b.applyDamage(b.getOtherPokemon(victim.user()), 2*e.damage);
	
	victim.getAttributes().removeEffect("Bide");
	+++
	CanHave
	EffectType: EndTurn
	Apply: increase(victim.getAttributes().getDamageTaken());
	+++
*
HalfWeight:
	Field: private int layers;
	+++
	CanHave
	Cast: HalfWeight e = (HalfWeight)victim.getEffect("HalfWeight");
	if (e == null) super.cast(b, caster, victim, source, printCast);
	else e.layers++;
	+++
	Activate: x.layers = 1;
	+++
	EffectType: Integer
	Integer: layers
*
PowerTrick:
	CanHave
	SwitchStat: if (s == Stat.ATTACK) return Stat.DEFENSE;
	if (s == Stat.DEFENSE) return Stat.ATTACK;
	return s;
	+++
	EffectType: Passable
	EffectType: StatSwitch
	CastMessage: user.getName()+"'s attack and defense were swapped!"
	Cast: PokemonEffect p = victim.getEffect("PowerTrick");
	if (p == null)
	{
		super.cast(b, caster, victim, source, printCast);
		return;
	}
	b.addMessage(getCastMessage(b, caster, victim));
	victim.getAttributes().removeEffect("PowerTrick");
	+++
*
PowerSplit:
	EffectType: StatChanging
	Modify: if (s == Stat.ATTACK) return (p.getStat(Stat.ATTACK)+opp.getStat(Stat.ATTACK))/2;
	if (s == Stat.SP_ATTACK) return (p.getStat(Stat.SP_ATTACK)+opp.getStat(Stat.SP_ATTACK))/2;
	return stat;
	+++
	CastMessage: user.getName()+" split the power!"
*
GuardSplit:
	EffectType: StatChanging
	Modify: if (s == Stat.DEFENSE) return (p.getStat(Stat.DEFENSE)+opp.getStat(Stat.DEFENSE))/2;
	if (s == Stat.SP_DEFENSE) return (p.getStat(Stat.SP_DEFENSE)+opp.getStat(Stat.SP_DEFENSE))/2;
	return stat;
	+++
	CastMessage: user.getName()+" split the defense!"
*
HealBlock:
	NumTurns: 5
	CastMessage: user.getName()+" blocked "+victim.getName()+" from healing!"
	SubsideMessage: "The effects of heal block wore off."
*
Infatuated:
	FailAbility: Oblivious
	FailCondition: !Gender.oppositeGenders(caster, victim)
	EffectType: BeforeTurn
	FailMessage: if (Gender.oppositeGenders(user, victim) && victim.hasAbility("Oblivious")) return victim.getName()+"'s Oblivious prevents infatuation!";
	+++
	CanAttack: b.addMessage(p.getName()+" is in love with "+opp.getName()+"!");
	if (Math.random() < .5) return true;
	b.addMessage(p.getName()+"'s infatuation kept it from attacking!");
	return false;
	+++
	CastMessage: victim.getName()+" fell in love!"
	Cast: super.cast(b, caster, victim, source, printCast);
	if (victim.isHoldingItem(b, "Destiny Knot") && this.applies(b, victim, caster, CastSource.HELD_ITEM))
	{
		super.cast(b, victim, caster, CastSource.HELD_ITEM, false);
		b.addMessage(victim.getName()+"'s Destiny Knot caused "+caster.getName()+" to fall in love!");
	}	
	+++
*
Snatch:
	NumTurns: 1
*
Grudge:
	CastMessage: victim.getName()+" wants "+b.getOtherPokemon(victim.user()).getName()+" to bear a grudge!"
	EffectType: Faint
	Deathwish: if (murderer.getAttributes().isAttacking())
	{
		b.addMessage(murderer.getName()+"'s "+murderer.getAttack().getName()+" lost all its PP due to its grudge!");
		murderer.getMove().reducePP(murderer.getMove().getPP());
	}
	+++
*
DestinyBond:
	CastMessage: victim.getName()+" is trying to take "+b.getOtherPokemon(victim.user()).getName()+" down with it!"
	EffectType: Faint
	Deathwish: if (murderer.getAttributes().isAttacking())
	{
		b.addMessage(dead.getName()+" took "+murderer.getName()+" down with it!");
		murderer.reduceHealthFraction(b, 1);
	}
	+++
*
PerishSong:
	NumTurns: 3
	FailAbility: Soundproof
	EffectType: Passable
	FailMessage: if (victim.hasAbility("Soundproof")) return victim.getName()+"'s Soundproof makes it immune to sound based moves!";
	+++
	CastMessage: "All Pokemon hearing this song will faint in three turns!"
	EffectType: EndTurn
	Apply: b.addMessage(victim.getName()+"'s Perish Song count fell to "+(super.numTurns-1)+"!");
	if (super.numTurns == 1) victim.reduceHealthFraction(b, 1);
	+++
*
Embargo:
	EffectType: Passable
	CastMessage: victim.getName()+" can't use items now!"
	NumTurns: 5
	SubsideMessage: victim.getName()+" can use items again!"
*
ConsumedItem:
	Field: private Item consumed;
	+++
	Activate: x.consumed = consumed;
	+++
	Cast: consumed = victim.getHeldItem(b);
	victim.removeItem();
	while (victim.getAttributes().removeEffect("ConsumedItem"));
	super.cast(b, caster, victim, source, printCast);
	+++
	EffectType: ItemCondition
	GetItem: return consumed;
	+++
	CanHave
*