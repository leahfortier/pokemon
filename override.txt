Override:
	FixedDamage:
		Header: int getFixedDamage(ActivePokemon me, ActivePokemon o, Battle b)
		Body: 
		return {0};
		###
		AddMapField: ApplyDamage:
		return super.tryDamage(me, o, b, getFixedDamage(me, o, b));
		###
	*
***
Override:
	GetPriority:
		Header: int getPriority(Battle b, ActivePokemon me)
	*
***
Override:
	GetType:
		Header: Type setType(Battle b, ActivePokemon user)
	*
***
RecoilMove:
	Recoil:
		Header: void applyRecoil(Battle b, ActivePokemon user, Integer damage)
		Try: 
		if (user.hasAbility(Namesies.ROCK_HEAD_ABILITY) || user.hasAbility(Namesies.MAGIC_GUARD_ABILITY)) 
		{
			return;
		}
		
		b.addMessage(user.getName() + " was hurt by recoil!");
		user.reduceHealth(b, (int)Math.ceil(damage/{0}.0));
		###
	*
***
SelfHealingMove:
	SelfHealing:
		Header: void heal(ActivePokemon user, ActivePokemon victim, Battle b)
		Begin:
		if (victim.fullHealth() || victim.hasEffect(Namesies.HEAL_BLOCK_EFFECT))
		{
			b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			return;
		}
		
		###
		End:
		
		b.addMessage(victim.getName() + "'s health was restored!", victim.getHP(), victim.user());
		###
		Try:
		victim.healHealthFraction(1/{0}.0);
		###
		AddMapField: SelfTarget: True
	*
***
MultiTurnMove:
	ChargeFirst:
		Header: boolean chargesFirst()
		Body: 
		return {0};
		###
	*
	SemiInv:
		Header: boolean semiInvulnerability()
		Body:
		return {0};
		###
	*
	Charge:
		Header: void charge(ActivePokemon user, Battle b)
		Optional: True
		Begin:
		b.addMessage(getChargeMessage(user));
		###
	*
	ChargeMessage:
		Header: String getChargeMessage(ActivePokemon user)
		Body:
		return {0};
		###
	*
***
Override:
	IsMultiTurn:
		Header: boolean isMultiTurn(Battle b)
	*
***
Override:
	MultiStrike:
		Header: int getHits(ActivePokemon me)
		Body:
		int minHits = {1};
		int maxHits = {2};
		
		int hits = (int)(Math.random()*(maxHits - minHits + 1)) + 2;
		
		if (maxHits == 5 && me.hasAbility(Namesies.SKILL_LINK_ABILITY)) 
		{
			hits = 5;
		}
		
		return hits;
		###
		AddMapField: ApplyDamage:
		// Don't apply damage if the move is ineffective
		if (!effective(b, me, o))
		{
			return -1;
		}
		
		int damage = 0, hit = 1;
		int hits = getHits(me);
		
		for (; hit <= hits; hit++)
		{
			b.addMessage("Hit " + hit + "!");
			damage += super.applyDamage(me, o, b);
			
			// Stop attacking the dead
			if (o.isFainted(b))
			{
				break;
			}
		}
		
		// Print hits and gtfo
		b.addMessage("Hit " + hit + " time" + (hit == 1 ? "" : "s") + "!");
		return damage;
		###
	*
***
ChangeTypeMove:
	ChangeType:
		Header: Type[] getType(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
***
Override:
	StartTurn:
		Header: void startTurn(Battle b, ActivePokemon me)
	*
***
Override:
	SwitchItems:
		Header: boolean switchCondition(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		return {0};
		###
		AddMapField: ApplyEffects:
		if (switchCondition(b, user, victim))
		{
			if (super.category == Category.STATUS) 
			{
				b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			}
			
			return;
		}

		Item userItem = user.getHeldItem(b), victimItem = victim.getHeldItem(b);
		b.addMessage(getSwitchMessage(user, userItem, victim, victimItem));

		if (b.isWildBattle())
		{
			user.giveItem((HoldItem)victimItem);
			victim.giveItem((HoldItem)userItem);
			return;
		}

		item = userItem;
		super.applyEffects(b, user, victim);
		item = victimItem;
		super.applyEffects(b, user, user);
		###
		AddMapField: Effect: Pokemon ChangeItem
		AddInterface: ItemCondition
		AddMapField: Field:
		private Item item;
		###
		AddMapField: GetItem:
		return item;
		###
	*
***
Override:
	SwitchMessage:
		Header: String getSwitchMessage(ActivePokemon user, Item userItem, ActivePokemon victim, Item victimItem)
		Body:
		return {0};
		###
	*
***
Override:
	OHKO:
		AddMapField: ApplyDamage:
		// Fails when the opponent is at a higher level than the user
		if (me.getLevel() < o.getLevel())
		{
			b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			return -1;
		}
		
		// Sturdy prevents OHKO moves if the user is not a mold breaker
		if (o.hasAbility(Namesies.STURDY_ABILITY) && !me.breaksTheMold())
		{
			b.addMessage(o.getName() + "'s " + Namesies.STURDY_ABILITY.getName() + " prevents OHKO moves!");
			return -1;
		}
		
		int damage = super.tryDamage(me, o, b, o.getHP());
		
		// Did not actually strike as was ineffective for some reason
		if (damage == -1)
		{
			return -1;
		}
		
		// Certain death
		b.addMessage("It's a One-Hit KO!");
		return damage;
		###
		AddMapField: MoveType: One_Hit_KO
		AddMapField: GetAccuracy:
		return super.accuracy + (me.getLevel() - o.getLevel());
		###
	*
***
StatSwitchingEffect:
	SwitchStat:
		Header: Stat switchStat(Stat s)
	*
***
CrashDamageMove:
	CrashDamage:
		Header: void crash(Battle b, ActivePokemon user)
		Body:
		b.addMessage(user.getName() + " kept going and crashed!");
		user.reduceHealth(b, user.getStat(Stat.HP)/{0});
		###
	*
***
StageChangingEffect:
	StageChange:
		Header: int adjustStage(Integer stage, Stat s, ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
IgnoreStageEffect:
	IgnoreStage: 
		Header: boolean ignoreStage(Stat s)
	*
***
Override:
	FieldMove:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		return true;
		###
		AddMapField: MoveType: Field
	*
***
Override:
	HitFly:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		// Always hit when the opponent is flying
		return defending.isSemiInvulnerableFlying();
		###
		AddMapField: GetPow:
		// Twice as strong when the opponent is flying
		return super.power*(o.isSemiInvulnerableFlying() ? 2 : 1);
		###
	*
***
Override:
	HitDig:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		// Always hit when the opponent is underground
		return defending.isSemiInvulnerableDigging();
		###
		AddMapField: GetPow:
		// Twice as strong when the opponent is underground
		return super.power*(o.isSemiInvulnerableDigging() ? 2 : 1);
		###
	*
***
Override:
	HitMinimize:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		return !defending.isSemiInvulnerable() && defending.hasEffect(Namesies.USED_MINIMIZE_EFFECT);
		###
		AddMapField: GetPow:
		return super.power*(o.hasEffect(Namesies.USED_MINIMIZE_EFFECT) ? 2 : 1);
		###
	*
***
AccuracyBypassEffect:
	BypassAccuracy:
		Header: boolean bypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
	*
***
OpponentAccuracyBypassEffect:
	OpponentBypassAccuracy:
		Header: boolean opponentBypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
	*
***
ChangeAbilityMove:
	AbilityChange:
		Header: Ability getAbility(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
	AbilityMessage:
		Header: String getMessage(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
***
Override:
	ExitBattle:
		Header: void applyEffects(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		// TODO: These moves need infinite accuracy and bypass Protect
		Trainer trainer = b.isWildBattle() ? null : (Trainer)b.getTrainer(victim.user());
		if (trainer == null || !trainer.hasRemainingPokemon() || b.isFirstAttack() || victim.hasEffect(Namesies.INGRAIN_EFFECT))
		{
			if (super.category == Category.STATUS) 
			{
				b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			}
			return;
		}

		if (victim.hasAbility(Namesies.SUCTION_CUPS_ABILITY) && !user.breaksTheMold())
		{
			b.addMessage(victim.getName() + "'s Suction Cups prevents it from switching!");
			return;
		}

		b.addMessage({0});
		trainer.switchToRandom();
		victim = trainer.front();
		b.enterBattle(victim, "...and " + victim.getName() + " was dragged out!");
		###
	*
***
Override:
	SelfSwitching:
		AddMapField: Apply:
		// First execute the move as normal
		super.apply(me, o, b);
		
		Team t = b.getTrainer(me.user());
		if (t instanceof WildPokemon)
		{
			// End the battle against a wild Pokemon
			b.addMessage(me.getName() + " left the battle!");
			b.addMessage(" ", MessageUpdate.Update.EXIT_BATTLE);
			return;
		}
		
		Trainer trainer = (Trainer)t;
		if (!trainer.hasRemainingPokemon())
		{
			// Don't switch if no one to switch to
			return;
		}
		
		// Send this Pokemon back to the trainer and send out the next one
		b.addMessage(me.getName() + " went back to " + trainer.getName() + "!");
		trainer.switchToRandom(); // TODO: Prompt a legit switch fo user
		me = trainer.front();
		b.enterBattle(me, trainer.getName() + " sent out " + me.getName() + "!");
		###
	*
***
EndTurnEffect:
	ApplyEndTurn:
		Header: void applyEndTurn(ActivePokemon victim, Battle b)
	*
***
BeforeTurnEffect:
	CanAttack:
		Header: boolean canAttack(ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
OpponentBeforeTurnEffect:
	OpponentCanAttack:
		Header: boolean opposingCanAttack(ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
Override:
	ProtectingEffect:
		AddInterface: OpponentBeforeTurnEffect
		AddMapField: MinTurns: 1
		AddMapField: MaxTurns: 1
		AddMapField: CastMessage: victim.getName() + " protected itself!"
		AddMapField: SuccessiveDecay: True
		AddMapField: OnProtectingSuccess:
		// No additional effects
		###
		AddMapField: ProtectingCondition: true
		AddMapField: OpponentCanAttack:
		// TODO: Test with a field move I think this should be included here as well
		// Self-target moves, moves that penetrate Protect, and other conditions
		if (p.getAttack().isSelfTarget() || p.getAttack().isMoveType(MoveType.PROTECT_PIERCING) || !protectingCondition(b, p)) 
		{
			return true;
		}
		
		// Protect is a success!
		b.printAttacking(p);
		b.addMessage(opp.getName() + " is protecting itself!");
		Global.invoke(new Object[] {p.getAttack()}, CrashDamageMove.class, "crash", b, p);
	
		// Additional Effects
		protectingEffects(p, opp, b);

		return false;
		###
	*
***
Override:
	ProtectingCondition:
		Header: boolean protectingCondition(Battle b, ActivePokemon attacking)
		Body:
		return {0};
		###
	*
***
Override:
	OnProtectingSuccess:
		Header: void protectingEffects(ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
Override: 
	SuccessiveDecay:
		AddMapField: Cast:
		if (Math.random() > caster.getAttributes().getSuccessionDecayRate())
		{
			b.addMessage(this.getFailMessage(b, caster, victim));
			return;
		}

		super.cast(b, caster, victim, source, printCast);
		###
	*
***
TrappingEffect:
	Trapped:
		Header: boolean isTrapped(Battle b, ActivePokemon p)
		Optional: True
		Default:
		// Ghost-type Pokemon can always escape
		return !p.isType(b, Type.GHOST);
		###
	*
***
OpponentTrappingEffect:
	OppTrapped: 
		Header: boolean trapOpponent(Battle b, ActivePokemon p)
	*
	OppTrappingMessage:
		Header: String trappingMessage(ActivePokemon escaper, ActivePokemon trapper)
		Optional: True
		Default:
		return trapper.getName() + "'s " + this.getName() + " prevents " + escaper.getName() + " from escaping!";
		###
	*
***
Override:
	PartialTrap:
		Header: String getPartialTrapMessage(ActivePokemon victim)
		Body: 
		return {0};
		###
		AddMapField: Cast:
		super.cast(b, caster, victim, source, printCast);
		if (caster.isHoldingItem(b, Namesies.GRIP_CLAW_ITEM)) setTurns(5);
		###
		AddInterface: EndTurnEffect
		AddInterface: TrappingEffect
		AddInterface: RapidSpinRelease
		AddMapField: MinTurns: 4
		AddMapField: MaxTurns: 5
		AddMapField: NextTurnSubside: True
		AddMapField: ApplyEndTurn:
		if (victim.hasAbility(Namesies.MAGIC_GUARD_ABILITY)) 
		{
			return;
		}
		
		b.addMessage(getPartialTrapMessage(victim));
		
		// Reduce 1/8 of the victim's total health, or 1/6 if holding a binding band
		victim.reduceHealthFraction(b, b.getOtherPokemon(victim.user()).isHoldingItem(b, Namesies.BINDING_BAND_ITEM) ? 1/6.0 : 1/8.0);
		###
	*
***
Override:
	Cast:
		Header: void cast(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source, boolean printCast)
	*
***
Override:
	CastMessage:
		Header: String getCastMessage(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
Override:
	SubsideMessage:
		Header: String getSubsideMessage(ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
RapidSpinRelease:
	RapidSpin:
		Header: String getReleaseMessage(ActivePokemon user)
		Body:
		return {0};
		###
	*
***
StatChangingEffect:
	ModifyStat:
		Header: int modify(Integer statValue, ActivePokemon p, ActivePokemon opp, Stat s, Battle b)
		Optional: True
		Default:
		if (isModifyStat(s) && modifyCondition(b, p, opp))
		{
			stat *= modifyMultiplier();
		}
		
		return stat;
		###
		Begin: 
		int stat = statValue;
		###
	*
***
Override:
	TwoModify:
		Header: boolean isModifyStat(Stat s)
		Body:
		return s == Stat.{11} || s == Stat.{22};
		###
	*
***
Override:
	ToModify:
		Header: boolean isModifyStat(Stat s)
		Body:
		return s == Stat.{00};
		###
	*
***
Override:
	WeatherModify:
		Header: Namesies getWeatherCondition()
		Body:
		return Namesies.{00}_EFFECT;
		###
		AddMapField: ModifyCondition: b.getWeather().namesies() == getWeatherCondition()
	*
***
Override:
	ModifyCondition:
		Header: boolean modifyCondition(Battle b, ActivePokemon p, ActivePokemon opp)
		Body:
		return {0};
		###
		AddInterface: StatChangingEffect
	*
***
Override:
	ModifyMultiplier:
		Header: double modifyMultiplier()
		Body:
		return {0};
		###
	*
***
MoveCondition:
	GetMove:
		Header: Move getMove()
	*
***
ForceMoveEffect:
	GetMove:
		Header: Move getMove()
	*
***
Override:
	Subside:
		Header: void subside(Battle b, ActivePokemon p)
	*
***
AttackSelectionEffect:
	Usable:
		Header: boolean usable(ActivePokemon p, Move m)
	*
	UnusableMessage:
		Header: String getUnusableMessage(ActivePokemon p)
		Body: 
		return {0};
		###
	*
***
Override:
	ShouldSubside:
		Header: boolean shouldSubside(Battle b, ActivePokemon victim)
	*
***
EntryEffect:
	Enter:
		Header: void enter(Battle b, ActivePokemon victim)
	*
***
TypeCondition:
	GetTypeCondition:	
		Header: Type[] getType()
	*
***
Override:
	GetTurns:
		Header: int getTurns()
	*
***
StatusPreventionEffect:
	StatusPrevent:
		Header: boolean preventStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusCondition status)
	*
	StatusPreventMessage:
		Header: String statusPreventionMessage(ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
PowerChangeEffect:
	GetMultiplier:
		Header: double getMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
OpponentPowerChangeEffect:
	GetOppMultiplier:
		Header: double getOpponentMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
IntegerCondition:
	GetAmount:
		Header: int getAmount()
		Body:
		return {0};
		###
	*
	DecreaseAmount:
		Header: void decrease(int amount)
		Body:
		{0} -= amount;
		###
	*
	IncreaseAmount:
		Header: void increase(int amount)
		Body:
		{0} += amount;
		###
	*
***
EffectBlockerEffect:
	ValidMove:
		Header: boolean validMove(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
StatProtectingEffect:
	StatProtect:
		Header: boolean prevent(Battle b, ActivePokemon caster, ActivePokemon victim, Stat stat)
	*
	StatProtectMessage:
		Header: String preventionMessage(ActivePokemon p)
		Body:
		return {0};
		###
	*
***
FaintEffect:
	Deathwish:
		Header: void deathwish(Battle b, ActivePokemon dead, ActivePokemon murderer)
	*
***
PassableEffect:
***
Override:
	FailMessage:
		Header: String getFailMessage(Battle b, ActivePokemon user, ActivePokemon victim)
		End:
		
		return super.getFailMessage(b, user, victim);
		###
	*
***
DefogRelease:
	Defog:
		Header: String getDefogReleaseMessage(ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
AbilityCondition:
	GetAbility:
		Header: Ability getAbility()
	*
***
ItemCondition:
	GetItem:
		Header: Item getItem()
	*
***
BracingEffect:
	Bracing:
		Header: boolean isBracing(Battle b, ActivePokemon bracer, Boolean fullHealth)
	*
	BraceMessage:
		Header: String braceMessage(ActivePokemon bracer)
		Body:
		return {0};
		###
	*
***
MoveListCondition:
	GetMoveList:
		Header: Move[] getMoveList(ActivePokemon p, Move[] moves)
	*
***
StatsCondition:
	GetStat:
		Header: int getStat(ActivePokemon user, Stat stat)
	*
***
CritStageEffect:
	IncreaseCritStage:
		Header: int increaseCritStage(Integer stage, ActivePokemon p)
		Optional: True
		Default:
		return stage + 1;
		###
	*
***
LevitationEffect:
***
GroundedEffect:
***
EndBattleEffect:
	EndBattle:
		Header: void afterBattle(Trainer player, Battle b, ActivePokemon p)
	*
***
PhysicalContactEffect:
	Contact:
		Header: void contact(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
DamageBlocker:
	Block:
		Header: boolean block(Type attacking, ActivePokemon victim)
	*
	AlternateEffect:
		Header: void alternateEffect(Battle b, ActivePokemon victim)
	*
***
Override:
	BlockType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: DamageBlocker
		AddMapField: Block:
		return attacking == getType();
		###
		AddMapField: AlternateEffect:
		b.addMessage(victim.getName() + "'s " + this.getName() + " makes it immune to " + getType().getName() + " type moves!");
		victim.getAttributes().modifyStage(victim, victim, 1, toIncrease(), b, CastSource.ABILITY);
		###
	*
***
Override:
	AbsorbType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: DamageBlocker
		AddMapField: Block:
		return attacking == getType() && !victim.hasEffect(Namesies.HEAL_BLOCK_EFFECT);
		###
		AddMapField: AlternateEffect:
		// TODO: Srsly considering changing the heal block to be here instead -- like I don't think they should take damage when they have heal block it makes no sense
		victim.healHealthFraction(1/4.0);
		b.addMessage(victim.getName() + "'s HP was restored due to its " + this.getName() + "!", victim.getHP(), victim.user());
		###
	*
***
WeatherBlockerEffect:
	WeatherBlock:
		Header: boolean block(Namesies weather)
	*
***
ApplyDamageEffect:
	OnApplyDamage:
		Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, Integer damage)
	*
***
ModifyStageValueEffect:
	ModifyStageValue:
		Header: int modifyStageValue(int modVal)
	*
***
SwitchOutEffect:
	SwitchOut:
		Header: void switchOut(ActivePokemon switchee)
	*
***
TakeDamageEffect:
	OnTakeDamage:
		Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
StallingEffect:
***
DefiniteEscape:
***
HoldItem:
	Fling:
		Header: int flingDamage()
		Body:
		return {0};
		###
	*
	FlingEffect:
		Header: void flingEffect(Battle b, ActivePokemon pelted)
		Optional: True
		Default:
		###
	*
***
TrainerUseItem:
	TrainerUse:
		Header: boolean use(Trainer t)
	*
***
PokemonUseItem:
	PokemonUse:
		Header: boolean use(CharacterData player, ActivePokemon p)
	*
***
BattleUseItem:
	BattleUse:
		Header: boolean use(ActivePokemon p, Battle b)
		Optional: True
		Default:
		return use(b.getPlayer(), p);
		###
	*
***
MoveUseItem:
	MoveUse:
		Header: boolean use(ActivePokemon p, Move m)
	*
***
Override:
	IncreaseStat:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
	*
***
Override:
	TypeTakeDamageStatIncrease:
		Header: boolean checkModify(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		return user.getAttackType() == Type.{11} && victim.getAttributes().modifyStage(victim, victim, 1, Stat.{22}, b, CastSource.HELD_ITEM);
		###
		AddMapField: OnTakeDamage:
		if (checkModify(b, user, victim))
		{
			victim.consumeItem(b);
		}
		###
		AddInterface: HoldItem
		AddInterface: ConsumableItem
		AddInterface: TakeDamageEffect
	*
***
ConsumableItem:
***
Override:
	ChoiceItem:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddInterface: StatChangingEffect
		AddMapField: ModifyStat:
		if (s == toIncrease())
		{
			stat *= 1.5;
		}
		
		return stat;
		###
		AddInterface: AttackSelectionEffect
		AddMapField: Usable:
		Move last = p.getAttributes().getLastMoveUsed();
		if (last == null || m == last)
		{
			return true;
		}
		
		return false;
		###
		AddMapField: UnusableMessage: p.getName() + "'s " + super.name + " only allows " + p.getAttributes().getLastMoveUsed().getAttack().getName() + " to be used!"
		AddInterface: HoldItem
		AddMapField: Fling: 10
	*
***
Override:
	Wing:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddMapField: EVIncreaseAmt: 1
		AddMapField: Price: 3000
		AddMapField: Fling: 20
		AddInterface: HoldItem
		AddMapField: Cat: Stat
	*
***
Override:	
	Vitamin:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddMapField: EVIncreaseAmt: 10
		AddMapField: Price: 9800
		AddMapField: Fling: 30
		AddInterface: HoldItem
		AddMapField: Cat: Stat
	*
***
RepellingEffect:
	RepelChance:
		Header: double chance()
		Body:
		return {0};
		###
	*
***
WeatherExtendingEffect:
	WeatherType:
		Header: Namesies getWeatherType()
		Body:
		return Namesies.{00}_EFFECT;
		###
	*
***
PowerItem:
	GetEVs:
		Header: int[] getEVs(int[] vals)
		Optional: True
		Default:
		vals[toIncrease().index()] += 4;
		return vals;
		###
	*
	ModifyStat:
		Header: int modify(Integer stat, ActivePokemon p, ActivePokemon opp, Stat s, Battle b)
		Optional: True
		Default:
		if (s == Stat.SPEED)
		{
			return stat / 2;
		}
		
		return stat;
		###
	*
	PowerStat:
		Header: Stat toIncrease()
		Optional: True
		Default:
		Global.error("toIncrease() method in " + super.name +" is unimplemented.");
		return null;
		###
		AddInterface: Hidden-HoldItem
	*
***
GemItem:
	GemType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: Hidden-PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.isAttackType(getType()))
		{
			// Consume the item
			b.addMessage(user.getName() + "'s " + this.getName() + " enhanced " + user.getAttack().getName() + "'s power!");
			user.consumeItem(b);

			// Gems increase the power of the move by 50% -- technically 30% in Gen 6 but they suck enough as is being a consumed item and all
			return 1.5;
		}

		return 1;
		###
		AddInterface: Hidden-HoldItem
		AddMapField: Fling: 30
	*
***
Override:
	EnhanceType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
	*
***
Override:
	TypeEnhanceMultiplier:
		Header: double getMultiplier()
		Body:
		return {0};
		###
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.isAttackType(getType()))
		{
			return getMultiplier();
		}

		return 1;
		###
	*
***
Override:
	Elixir:
		Header: int increaseAmount(Move m)
		Body:
		return {0};
		###
		AddMapField: Field:
		private boolean use(List<Move> moves)
		{
			boolean changed = false;
			for (Move m : moves)
			{
				changed |= m.increasePP(increaseAmount(m));
			}
			
			return changed;
		}
		###
		AddMapField: BattleUse:
		return use(p.getMoves(b));
		###
		AddMapField: PokemonUse:
		return use(p.getActualMoves());
		###
		AddMapField: SuccessMessage: p.getName() + "'s PP was restored!"
		AddMapField: Fling: 30
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
		AddInterface: HoldItem
		AddMapField: Cat: Medicine
		AddMapField: BattleCat: HP_PP
	*
***
Override:
	TimeSpaceOrb:
		Header: boolean canUseOrb(ActivePokemon user)
		Body:
		if (!user.isPokemon(Namesies.{11}_POKEMON))
		{
			return false;
		}
		
		return user.isAttackType(Type.DRAGON) || user.isAttackType(Type.{22});
		###
		AddMapField: Fling: 60
		AddMapField: Price: 10000
		AddInterface: HoldItem
		AddInterface: PowerChangeEffect
		AddMapField: Cat: Misc
		AddMapField: GetMultiplier:
		if (canUseOrb(user))
		{
			return 1.2;
		}
		
		return 1;
		###
	*
***
PlateItem:
	PlateType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: Hidden-HoldItem
		AddMapField: Price: 1000
		AddMapField: Fling: 90
		AddMapField: Cat: MISC
		AddInterface: Hidden-PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.isAttackType(getType()))
		{
			return 1.2;
		}

		return 1;
		###
	*
***
DriveItem:
	DriveType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: Hidden-HoldItem
		AddMapField: Fling: 70
		AddMapField: Price: 1000
		AddMapField: Cat: Misc
	*
***
Override:
	EvolutionItem:
		AddInterface: PokemonUseItem
		AddMapField: SuccessMessage: ""
		AddMapField: PokemonUse:
		Evolution ev = p.getPokemonInfo().getEvolution();
		BaseEvolution base = (BaseEvolution) ev.getEvolution(EvolutionCheck.ITEM, p, this.namesies);
		if (base == null)
		{
			return false;
		}

		player.setEvolution(p, base);
		return true;
		###
	*
***
Override:
	StatusRemove:
		Header: StatusCondition toRemove()
		Body:
		return StatusCondition.{00};
		###
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
		AddMapField: PokemonUse:
		if (!p.hasStatus(toRemove()))
		{
			return false;
		}

		p.removeStatus();
		return true;
		###
		AddMapField: SuccessMessage: p.getName() + " was cured of its status condition!"
	*
***
Override:
	HealAmt:
		Header: int healAmount()
		Body:
		return {0};
		###
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
		AddMapField: PokemonUse:
		return p.heal(healAmount()) != 0;
		###
		AddMapField: SuccessMessage: p.getName() + "'s health was restored!"
		AddMapField: Cat: Medicine
		AddMapField: BattleCat: HP_PP
		AddMapField: Fling: 30
		AddInterface: HoldItem
	*
***
Override:
	XStageIncrease:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddMapField: Fling: 30
		AddMapField: Cat: Stat
		AddMapField: BattleCat: Battle
		AddInterface: HoldItem
		AddInterface: BattleUseItem
		AddMapField: BattleUse:
		return p.getAttributes().modifyStage(p, p, 1, toIncrease(), b, CastSource.USE_ITEM);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toIncrease().getName() + " was raised!"
	*
***
Override:
	EVIncrease:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
	*
***
Override:
	EVIncreaseAmt:
		Header: int increaseAmount()
		Body:
		return {0};
		###
		AddInterface: PokemonUseItem
		AddMapField: PokemonUse:
		int[] toAdd = new int[Stat.NUM_STATS];
		toAdd[toIncrease().index()] += increaseAmount();

		return p.addEVs(toAdd);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toIncrease().getName() + " was raised!"
	*
***
BallItem:
	CatchRate:
		Header: double[] catchRate(ActivePokemon me, ActivePokemon o, Battle b)
		Try:
		return new double[] {{0}, 0};
		###
		AddMapField: Cat: Ball
		AddMapField: BattleCat: Ball
	*
	AfterCaught:
		Header: void afterCaught(ActivePokemon p)
		Optional: True
		Default:
		###
	*
***
Override:
	EVDecreaseBerry:
		Header: Stat toDecrease()
		Body:
		return Stat.{00};
		###
		AddInterface: Berry
		AddInterface: PokemonUseItem
		AddMapField: PokemonUse:
		int[] vals = new int[Stat.NUM_STATS];
		if (p.getEV(toDecrease().index()) > 110)
			vals[toDecrease().index()] = 100 - p.getEV(toDecrease().index());
		else
			vals[toDecrease().index()] -= 10;

		return p.addEVs(vals);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toDecrease().getName() + " was lowered!"
		AddMapField: NGPow: 90
	*
***
Override:
	SuperEffectivePowerReduceBerryType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: Berry
		AddMapField: NGPow: 80
		AddInterface: OpponentPowerChangeEffect
		AddMapField: GetOppMultiplier:
		if (user.getAttackType() == getType() && Type.getAdvantage(user, victim, b) > 1)
		{
			b.addMessage(victim.getName() + "'s " + this.name + " decreased " + user.getName() + "'s attack!");
			victim.consumeItem(b);
			return .5;
		}

		return 1;
		###
	*
***
Override:
	HealthTriggeredStageIncreaseBerryStat:
		Header: Stat toRaise()
		Body:
		return Stat.{00};
		###
		AddInterface: HealthTriggeredBerry
		AddMapField: HealthTrigger:
		if (user.getAttributes().modifyStage(user, user, 1, toRaise(), b, source))
		{
			return true;
		}

		return false;
		###
		AddMapField: HealthTriggerRatio: 4
		AddMapField: SuccessMessage: p.getName() + "'s " + toRaise().getName() + " increased!"
		AddMapField: HoldSuccessMessage: ""
		AddMapField: NGPow: 100
	*
***
Override:
	CategoryIncreaseBerry:
		Header: boolean checkModify(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		return user.getAttack().getCategory() == Category.{11} && victim.getAttributes().modifyStage(victim, victim, 1, Stat.{22}, b, CastSource.HELD_ITEM);
		###
		AddMapField: NGPow: 100
		AddInterface: Berry
		AddInterface: TakeDamageEffect
		AddMapField: OnTakeDamage:
		if (checkModify(b, user, victim))
		{
			victim.consumeItem(b);
		}
		###
	*
***
Override:
	CategoryDamagerBerry:
		Header: Category getCategory()
		Body:
		return Category.{00};
		###
		AddMapField: NGPow: 100
		AddInterface: Berry
		AddInterface: TakeDamageEffect
		AddMapField: OnTakeDamage:
		if (user.getAttack().getCategory() == getCategory())
		{
			b.addMessage(user.getName() + " was hurt by " + victim.getName() + "'s " + this.name + "!");
			user.reduceHealthFraction(b, 1/8.0);
			victim.consumeItem(b);
		}
		###
	*
***
StatusBerry:
	StatusBerryGainEffect:
		Optional: True
		AddMapField: GainEffect:
		if (!use(user, b))
		{
			return false;
		}
		###
		AddInterface: Hidden-GainableEffectBerry
		AddMapField: HoldSuccessMessage: p.getName() + "'s " + this.getName() + " cured it of its status condition!"
		AddMapField: NGPow: 80
	*
***
GainableEffectBerry:
	GainEffect:
		Header: boolean gainBerryEffect(Battle b, ActivePokemon user, CastSource source)
		End:
		
		String message = "";
		switch (source)
		{
			case USE_ITEM:
				message = getSuccessMessage(user);
				break;
			case HELD_ITEM:
				message = getHoldSuccessMessage(user);
				break;
			default:
				Global.error("Use item and held item are the only valid cast sources for berries.");
		}
		
		b.addMessage(message, user.getStatus().getType(), user.user());
		b.addMessage("", user.getHP(), user.user());
		
		if (user.hasAbility(Namesies.CHEEK_POUCH_ABILITY) && !user.fullHealth())
		{
			b.addMessage(user.getName() + "'s " + Namesies.CHEEK_POUCH_ABILITY.getName() + " restored its health!");
			user.healHealthFraction(1/3.0);
			b.addMessage("", user.getHP(), user.user());
		}
		
		// Eat dat berry!!
		PokemonEffect.getEffect(Namesies.EATEN_BERRY_EFFECT).cast(b, user, user, source, false);
		
		return true;
		###
		AddInterface: Hidden-Berry
		AddMapField: FlingEffect:
		gainBerryEffect(b, pelted, CastSource.USE_ITEM);
		###
	*
***
HealthTriggeredBerry:
	HealthTrigger:
		Header: boolean useHealthTriggerBerry(Battle b, ActivePokemon user, CastSource source)
		Optional: True
		Default:
		return use(user, b);
		###
		AddInterface: Hidden-GainableEffectBerry
		AddMapField: GainEffect:
		if (!useHealthTriggerBerry(b, user, source))
		{
			return false;
		}
		###
	*
	HealthTriggerRatio:
		Header: double healthTriggerRatio()
		Try:
		return 1/{0}.0;
		###
	*
***
Berry:
	NGPow:
		Header: int naturalGiftPower()
		Body:
		return {0};
		###
		AddMapField: Cat: Berry
		AddInterface: Hidden-HoldItem
		AddMapField: Fling: 10
		AddMapField: Price: 20
	*
	NGType:
		Header: Type naturalGiftType()
		Body:
		return Type.{00};
		###
	*
***
Override:
	RepelSteps:
		Header: int repelSteps()
		Body:
		return {0};
		###
		AddInterface: HoldItem
		AddMapField: Fling: 30
		AddInterface: TrainerUseItem
		AddMapField: TrainerUse:
		if (!(t instanceof CharacterData))
		{
			Global.error("Only the character should be using a Repel item");
		}

		CharacterData player = (CharacterData) t;
		if (player.isUsingRepel())
		{
			return false;
		}

		player.addRepelSteps(repelSteps());
		return true;
		###
		AddMapField: SuccessMessage: "Weak wild Pok\u00e9mon will not appear for " + repelSteps() + " steps!"
		AddMapField: Cat: MISC
	*
***
CritBlockerEffect:
	BlockCrits:
		Header: boolean blockCrits()
		Optional: True
		Default:
		return true;
		###
	*
***
Override:
	PowderResist:
		Header: String getPreventMessage(ActivePokemon victim)
		Body:
		return victim.getName() + "'s " + this.getName() + " protects it from powder moves!";
		###
		AddInterface: EffectBlockerEffect
		AddMapField: ValidMove:
		if (!user.getAttack().isMoveType(MoveType.POWDER)) 
		{
			return true;
		}
		
		if (user.getAttack().getCategory() == Category.STATUS) 
		{
			b.addMessage(getPreventMessage(victim));
		}
		
		return false;
		###
	*
***
AdvantageChanger:
	AdvantageChange:
		Header: Type[] getAdvantageChange(Type attacking, Type[] defending)
		Body:
		for (int i = 0; i < 2; i++)
		{
			if ({0})
			{
				defending[i] = Type.NONE;	
			}
		}
		
		return defending;
		###
	*
***
AdvantageMultiplier:
	MultiplyAdvantage:
		Header: double multiplyAdvantage(Type moveType, Type[] defendingType)
	*
***
Override:
	GetPow:
		Header: int setPower(Battle b, ActivePokemon me, ActivePokemon o)
	*
***
Override:
	ApplyDamage:
		Header: int applyDamage(ActivePokemon me, ActivePokemon o, Battle b)
	*
***
Override:
	GetAccuracy:
		Header: int getAccuracy(Battle b, ActivePokemon me, ActivePokemon o)
	*
***
Override:
	Apply:
		Header: void apply(ActivePokemon me, ActivePokemon o, Battle b)
	*
***
Override:
	Aura:
		Header: Type getAuraType()
		Body:
		return Type.{00};
		###
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.getAttackType() == getAuraType())
		{
			return 1 + .33*(victim.hasAbility(Namesies.AURA_BREAK_ABILITY) ? -1 : 1);
		}
		
		return 1;
		###
	*
***
Override:
	StealItem:
		Header: void steal(Battle b, ActivePokemon thief, ActivePokemon victim)
		Body:
		// Dead Pokemon and wild Pokemon cannot steal; 
		// Cannot steal if victim is not holding an item or thief is already holding an item;
		// Cannot steal from a Pokemon with the Sticky Hold ability 
		if (thief.isFainted(b) || !victim.isHoldingItem(b) || thief.isHoldingItem(b) || b.getTrainer(thief.user()) instanceof WildPokemon || victim.hasAbility(Namesies.STICKY_HOLD_ABILITY))
		{
			return;
		}
		
		// Stealers gon' steal
		Item stolen = victim.getHeldItem(b);
		b.addMessage(thief.getName() + " stole " + victim.getName() + "'s " + stolen.getName() + "!");
		
		if (b.isWildBattle())
		{
			victim.removeItem();
			thief.giveItem((HoldItem)stolen);
			return;
		}
		
		item = stolen;
		PokemonEffect.getEffect(Namesies.CHANGE_ITEM_EFFECT).cast(b, thief, thief, CastSource.ABILITY, false);
		
		item = Item.noneItem();
		PokemonEffect.getEffect(Namesies.CHANGE_ITEM_EFFECT).cast(b, thief, victim, CastSource.ABILITY, false);
		###
		AddInterface: ItemCondition
		AddMapField: Field:
		private Item item;
		###
		AddMapField: GetItem:
		return item;
		###
	*
***
Override:
	ConsumeBerry:
		AddMapField: ApplyEffects: 
		Item i = victim.getHeldItem(b);
		if (i instanceof Berry)
		{
			b.addMessage(user.getName() + " ate " + victim.getName() + "'s " + i.getName() + "!");
			victim.consumeItem(b);
			
			if (i instanceof GainableEffectBerry)
			{
				((GainableEffectBerry)i).gainBerryEffect(b, user, CastSource.USE_ITEM);
			}
		}
		###
	*
***
Override:
	ApplyEffects:
		Header: void applyEffects(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
Override:
	SuccessMessage:
		Header: String getSuccessMessage(ActivePokemon p)
		Body:
		return {0};
		###
	*
***
Override:
	HoldSuccessMessage:
		Header: String getHoldSuccessMessage(ActivePokemon p)
		Body:
		return {0};
		###
	*
***
ChangeAttackTypeEffect:
	ChangeAttackType:
		Header: Type changeAttackType(Type original)
	*
***
Override:
	NormalTypeChanger:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: ChangeAttackTypeEffect
		AddMapField: ChangeAttackType:
		if (original == Type.NORMAL)
		{
			this.activated = true;
			return getType();
		}
		
		return original;
		###
		AddMapField: Field:
		private boolean activated;
		###
		AddMapField: Activate:
		x.activated = false;
		###
		AddInterface: EndTurnEffect
		AddMapField: ApplyEndTurn:
		this.activated = false;
		###
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		return activated ? 1.3 : 1;
		###
	*
***
StatLoweredEffect:
	NextLevel:
		Header: void takeItToTheNextLevel(Battle b, ActivePokemon caster, ActivePokemon victim)
		Body:
		victim.getAttributes().modifyStage(victim, victim, 2, Stat.{00}, b, CastSource.@SuperClass);
		###
	*
***
Override:
	FlinchItem:
		AddMapField: FlingEffect:
		PokemonEffect flinch = PokemonEffect.getEffect(Namesies.FLINCH_EFFECT);
		if (flinch.applies(b, pelted, pelted, CastSource.USE_ITEM))
		{
			flinch.cast(b, pelted, pelted, CastSource.USE_ITEM, false);
			b.addMessage("The " + this.name + " caused " + pelted.getName() + " to flinch!");
		}
		###
		AddMapField: OnApplyDamage:
		if (Math.random()*100 < 10)
		{
			PokemonEffect flinch = PokemonEffect.getEffect(Namesies.FLINCH_EFFECT);
			if (flinch.applies(b, user, victim, CastSource.HELD_ITEM))
			{
				flinch.cast(b, user, victim, CastSource.HELD_ITEM, false);
				b.addMessage(user.getName() + "'s " + this.name + " caused " + victim.getName() + " to flinch!");
			}
		}
		###
		AddInterface: ApplyDamageEffect
		AddInterface: HoldItem
	*
***
Override:
	TM:
		Header: Attack getAttack()
		Body:
		return Attack.getAttack(Namesies.getValueOf("{0}", NamesiesType.ATTACK));
		###
		AddMapField: Cat: TM
		AddInterface: MoveUseItem
		AddMapField: SuccessMessage: p.getName() + " learned " + getAttack().getName() + "!"
		AddMapField: MoveUse:
		Attack attack = getAttack();
		
		// Cannot learn if you already know the move
		if (p.hasActualMove(attack.namesies()))
		{
			return false;
		}

		// Cannot learn if the TM is not compatible with the Pokemon
		if (!p.getPokemonInfo().isTmMove(attack.namesies()))
		{
			return false;
		}

		Move tmMove = new Move(attack);
		List<Move> moveList = p.getActualMoves();

		// If they don't have a full move list, append to the end
		if (moveList.size() < Move.MAX_MOVES)
		{
			p.addMove(null, tmMove, moveList.size());
			return true;
		}

		// Otherwise, go through their moves and find the one that matches and replace with the TM move
		for (int i = 0; i < moveList.size(); i++)
		{
			if (moveList.get(i).getAttack().namesies() == m.getAttack().namesies())
			{
				p.addMove(null, tmMove, i);
				return true;
			}
		}

		// Did not find move to replace -- throw error
		Global.error("ActivePokemon " + p.getName() + " does not have move to replace " + m.getAttack().getName());
		return false;
		###
	*
***
PriorityChangeEffect:
	ChangePriority:
		Header: int changePriority(Battle b, ActivePokemon user, Integer priority)
		Body:
		if ({0})
		{
			if (this instanceof ConsumableItem)
			{
				user.consumeItem(b);
			}
			
			priority++;
		}
		
		return priority;
		###
	*
***