Override:
	FixedDamage:
		AddMapField: ApplyDamage:
		o.reduceHealth(b, {0});
		###
	*
***
Override:
	GetPriority:
		Header: int getPriority(Battle b, ActivePokemon me)
	*
***
Override:
	GetType:
		Header: Type setType(Battle b, ActivePokemon user)
	*
***
RecoilMove:
	Recoil:
		Header: void applyRecoil(Battle b, ActivePokemon user, Integer damage)
		Try: 
		if (user.hasAbility(Namesies.ROCK_HEAD_ABILITY) || user.hasAbility(Namesies.MAGIC_GUARD_ABILITY)) 
		{
			return;
		}
		
		b.addMessage(user.getName() + " was hurt by recoil!");
		user.reduceHealth(b, (int)Math.ceil(damage/{0}.0));
		###
	*
***
Override:
	StatusFang:
		AddMapField: EffChance: 20
		AddMapField: Effect: Pokemon Flinch
		AddMapField: MoveType: Biting
		AddMapField: ApplyEffects:
		// If the effect is being applied, 50/50 chance to give a status condition vs. flinching
		if (Math.random() < .5)
		{
			Status.giveStatus(b, user, victim, StatusCondition.{00});
			return;
		}
		
		super.applyEffects(b, user, victim);
		###
	*
***
Override:
	WeatherHeal:
		AddInterface: SelfHealingMove
		AddMapField: SelfHealing: 
		switch (b.getWeather().namesies())
		{
			case CLEAR_SKIES_EFFECT:
				victim.healHealthFraction(1/2.0);
				break;
			case SUNNY_EFFECT:
				victim.healHealthFraction(2/3.0);
				break;
			case HAILING_EFFECT:
			case RAINING_EFFECT:
			case SANDSTORM_EFFECT:
				victim.healHealthFraction(1/4.0);
				break;
			default:
				Global.error("Funky weather problems!!!!");
				break;
		}
		###
	*
***
SelfHealingMove:
	SelfHealing:
		Header: void heal(ActivePokemon user, ActivePokemon victim, Battle b)
		Begin:
		if (victim.fullHealth() || victim.hasEffect(Namesies.HEAL_BLOCK_EFFECT))
		{
			b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			return;
		}
		
		###
		End:
		
		b.addMessage(victim.getName() + "'s health was restored!", victim);
		###
		Try:
		victim.healHealthFraction(1/{0}.0);
		###
		AddMapField: SelfTarget: True
	*
***
MultiTurnMove:
	ChargeFirst:
		Header: boolean chargesFirst()
		Body: 
		return {0};
		###
	*
	SemiInv:
		Header: boolean semiInvulnerability()
		Body:
		return {0};
		###
	*
	Charge:
		Header: void charge(ActivePokemon user, Battle b)
		Optional: True
		Begin:
		b.addMessage(getChargeMessage(user));
		###
	*
	ChargeMessage:
		Header: String getChargeMessage(ActivePokemon user)
		Body:
		return {0};
		###
		AddMapField: MoveType: Sleep_Talk_Fail
	*
***
Override:
	IsMultiTurn:
		Header: boolean isMultiTurn(Battle b, ActivePokemon user)
	*
***
Override:
	MultiStrike:
		AddMapField: ApplyDamage:
		int minHits = {1};
		int maxHits = {2};
		
		int hits = (int)(Math.random()*(maxHits - minHits + 1)) + minHits;
		
		if (maxHits == 5 && me.hasAbility(Namesies.SKILL_LINK_ABILITY)) 
		{
			hits = 5;
		}
		
		int hit = 1;
		for (; hit <= hits; hit++)
		{
			b.addMessage("Hit " + hit + "!");
			super.applyDamage(me, o, b);
			
			// Stop attacking the dead
			if (o.isFainted(b))
			{
				break;
			}
		}
		
		// Print hits and gtfo
		b.addMessage("Hit " + hit + " time" + (hit == 1 ? "" : "s") + "!");
		###
	*
***
ChangeTypeMove:
	ChangeType:
		Header: Type[] getType(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
***
Override:
	StartTurn:
		Header: void startTurn(Battle b, ActivePokemon me)
	*
***
Override:
	SwitchItems:
		AddMapField: ApplyEffects:
		if ({0})
		{
			if (super.category == Category.STATUS) 
			{
				b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			}
			
			return;
		}

		Item userItem = user.getHeldItem(b), victimItem = victim.getHeldItem(b);
		b.addMessage(getSwitchMessage(user, userItem, victim, victimItem));

		if (b.isWildBattle())
		{
			user.giveItem((HoldItem)victimItem);
			victim.giveItem((HoldItem)userItem);
			return;
		}

		item = userItem;
		super.applyEffects(b, user, victim);
		
		item = victimItem;
		super.applyEffects(b, user, user);
		###
		AddMapField: Effect: Pokemon ChangeItem
		AddInterface: ItemCondition
		AddMapField: Field:
		private Item item;
		###
		AddMapField: GetItem:
		return item;
		###
		AddMapField: MoveType: Metronomeless, No_Magic_Coat
	*
***
Override:
	SwitchItemMessage:
		Header: String getSwitchMessage(ActivePokemon user, Item userItem, ActivePokemon victim, Item victimItem)
		Body:
		return {0};
		###
	*
***
Override:
	BattleEffect:
		AddMapField: Effect: Battle {0}
		AddMapField: FieldMove: True
		AddMapField: MoveType: No_Magic_Coat
	*
***
Override:
	ProtectingAttack:
		AddMapField: Effect: Pokemon {0}
		AddMapField: Priority: 4
		AddMapField: SelfTarget: True
		AddMapField: MoveType: Successive_Decay, Assistless, Metronomeless, Non_Snatchable
	*
***
Override:
	OHKO:
		AddMapField: ApplyDamage:
		// Fails when the opponent is at a higher level than the user
		if (me.getLevel() < o.getLevel())
		{
			b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			return;
		}
		
		// Sturdy prevents OHKO moves if the user is not a mold breaker
		if (o.hasAbility(Namesies.STURDY_ABILITY) && !me.breaksTheMold())
		{
			b.addMessage(o.getName() + "'s " + Namesies.STURDY_ABILITY.getName() + " prevents OHKO moves!");
			return;
		}
		
		// Certain death
		o.reduceHealth(b, o.getHP());
		b.addMessage("It's a One-Hit KO!");
		###
		AddMapField: MoveType: One_Hit_KO
		AddMapField: GetAccuracy:
		return super.accuracy + (me.getLevel() - o.getLevel());
		###
	*
***
StatSwitchingEffect:
	SwitchStat:
		Header: Stat switchStat(Stat s)
	*
***
CrashDamageMove:
	CrashDamage:
		Header: void crash(Battle b, ActivePokemon user)
		Body:
		b.addMessage(user.getName() + " kept going and crashed!");
		user.reduceHealth(b, user.getMaxHP()/{0});
		###
	*
***
Override:
	StatSplit:
		AddInterface: StatChangingEffect
		AddMapField: ModifyStat:
		
		// If the stat is a splitting stat, return the average between the user and the opponent
		if (s == Stat.{11} || s == Stat.{22})
		{
			return (p.getStat(b, s) + opp.getStat(b, s))/2;
		}
		
		return stat;
		###
	*
***
StageChangingEffect:
	StageChange:
		Header: int adjustStage(Integer stage, Stat s, ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
IgnoreStageEffect:
	IgnoreStage: 
		Header: boolean ignoreStage(Stat s)
	*
***
Override:
	FieldMove:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		return true;
		###
		AddMapField: MoveType: Field
	*
***
Override:
	StatusCureMove:
		AddMapField: GetPow: 
		return super.power*(o.hasStatus(StatusCondition.{00}) ? 2 : 1);
		###
		AddMapField: ApplyEffects:
		if (victim.hasStatus(StatusCondition.{00}))
		{
			Status.removeStatus(b, victim, CastSource.ATTACK);
		}
		###
	*
***
Override:
	StormyMove:
		AddMapField: GetAccuracy:
		// Accuracy is only 50% when sunny
		if (b.getWeather().namesies() == Namesies.SUNNY_EFFECT)
		{
			return 50;
		}
		
		return super.accuracy;
		###
		AddMapField: BypassAccuracy:
		// Always hits when the opponent is flying or it is raining (unless they're non-flying semi-invulnerable)
		return defending.isSemiInvulnerableFlying() || (b.getWeather().namesies() == Namesies.RAINING_EFFECT && defending.isSemiInvulnerable());
		###
		AddMapField: HitFly: True
	*
***
Override:
	HitFly:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		// Always hit when the opponent is flying
		return defending.isSemiInvulnerableFlying();
		###
		AddMapField: GetPow:
		// Twice as strong when the opponent is flying
		return super.power*(o.isSemiInvulnerableFlying() ? 2 : 1);
		###
	*
***
Override:
	HitDig:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		// Always hit when the opponent is underground
		return defending.isSemiInvulnerableDigging();
		###
		AddMapField: GetPow:
		int power = {0};
		
		// Power is halved during Grassy Terrain
		if (b.hasEffect(Namesies.GRASSY_TERRAIN_EFFECT))
		{
			power *= .5;
		}
		
		// Power is double when the opponent is underground
		if (o.isSemiInvulnerableDigging())
		{
			power *= 2;
		}
		
		return power;
		###
	*
***
Override:
	HPRatioMove:
		AddMapField: GetPow:
		return (int)Math.min(1, ({1}*{2}.getHPRatio()));
		###
	*
***
Override:
	Flailing:
		AddMapField: GetPow: 
		double ratio = me.getHPRatio();
		if (ratio > .7) return 20;
		if (ratio > .35) return 40;
		if (ratio > .2) return 80;
		if (ratio > .1) return 100;
		if (ratio > .04) return 150;
		return 200;
		###
	*
***
BarrierEffect:
	Barrier:
		AddInterface: Hidden-DefogRelease
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
		AddMapField: ToModify: {1}
		AddMapField: ModifyMultiplier: 2 !opp.hasAbility(Namesies.INFILTRATOR_ABILITY)
		AddMapField: CastMessage: user.getName() + " raised the " + Stat.{11}.getName().toLowerCase() + " of its team!"
		AddMapField: SubsideMessage: "The effects of {2-} faded."
		AddMapField: Defog: "The effects of {2-} faded."
		AddMapField: Cast: 
		super.cast(b, caster, victim, source, printCast);
		if (caster.isHoldingItem(b, Namesies.LIGHT_CLAY_ITEM)) 
		{
			Effect.getEffect(b.getEffects(victim.user()), this.namesies).setTurns(8);
		}
		###
		AddMapField: BreakBarrier: {2-}
	*
	BreakBarrier:
		Header: void breakBarrier(Battle b, ActivePokemon breaker)
		Body:
		b.addMessage(breaker.getName() + " broke the {0} barrier!");
		b.getEffects(!breaker.user()).remove(this);
		###
	*
***
Override:
	SpecificAbilityChange:
		AddInterface: ChangeAbilityMove
		AddMapField: Effect: Pokemon ChangeAbility
		AddMapField: AbilityChange:
		return Ability.getAbility(Namesies.{00}_ABILITY).newInstance();
		###
		AddMapField: AbilityMessage: 
		return victim.getName() + "'s ability was changed to " + Namesies.{00}_ABILITY.getName() + "!";
		###
		AddMapField: Apply: 
		switch (o.getAbility().namesies())
		{
			case TRUANT_ABILITY:
			case MULTITYPE_ABILITY:
			case STANCE_CHANGE_ABILITY:
				b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
				return;
			default:
				super.apply(me, o, b);
		}	
		###
	*
***
Override:
	HitMinimize:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		return !defending.isSemiInvulnerable() && defending.hasEffect(Namesies.USED_MINIMIZE_EFFECT);
		###
		AddMapField: GetPow:
		return super.power*(o.hasEffect(Namesies.USED_MINIMIZE_EFFECT) ? 2 : 1);
		###
	*
***
AccuracyBypassEffect:
	BypassAccuracy:
		Header: boolean bypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
	*
***
OpponentAccuracyBypassEffect:
	OpponentBypassAccuracy:
		Header: boolean opponentBypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
	*
***
ChangeAbilityMove:
	AbilityChange:
		Header: Ability getAbility(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
	AbilityMessage:
		Header: String getMessage(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
***
Override:
	MirrorMove:
		AddMapField: MoveType: Sleep_Talk_Fail, Encoreless, Metronomeless, Assistless, No_Magic_Coat, Mirrorless
		AddMapField: Apply: 
		Move mirror = o.getAttributes().getLastMoveUsed();
		if (mirror == null || mirror.getAttack().isMoveType(MoveType.MIRRORLESS))
		{
			b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			return;
		}
		
		me.callNewMove(b, o, new Move(mirror.getAttack()));
		###
	*
***
Override:
	Countering:
		AddMapField: Priority: -5
		AddMapField: MoveType: Assistless, Metronomeless
		AddMapField: PP: 20
		AddMapField: Acc: 100
		AddMapField: ApplyDamage:
		int damageTaken = me.getAttributes().getDamageTaken();
		
		// Fails if no damage to reflect or if the opponent isn't using an attack of the proper category
		if (damageTaken == 0 || o.getMove() == null || o.getAttack().getCategory() != Category.{00} || b.isFirstAttack())
		{
			b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			return;
		}
		
		o.reduceHealth(b, damageTaken*2);
		###
	*
***
Override:
	ExitBattle:
		AddMapField: MoveType: Assistless
		AddMapField: Priority: -6
		AddMapField: ApplyEffects:
		// Fails against the Suction Cups ability
		if (victim.hasAbility(Namesies.SUCTION_CUPS_ABILITY) && !user.breaksTheMold())
		{
			b.addMessage(victim.getName() + "'s " + Namesies.SUCTION_CUPS_ABILITY.getName() + " prevents it from switching!");
			return;
		}
		
		// Fails if this is the first attack of the turn, or if the victim is rooted by Ingrain
		if (b.isFirstAttack() || victim.hasEffect(Namesies.INGRAIN_EFFECT))
		{
			if (super.category == Category.STATUS)
			{
				b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			}
			
			return;
		}
		
		Team opponent = b.getTrainer(victim.user());
		if (opponent instanceof WildPokemon)
		{
			// Fails against wild Pokemon of higher levels
			if (victim.getLevel() > user.getLevel())
			{
				b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
				return;
			}
			
			// End the battle against a wild Pokemon
			b.addMessage({0});
			b.addMessage(" ", Update.EXIT_BATTLE);
			return;
		}
		
		Trainer trainer = (Trainer)opponent;
		if (!trainer.hasRemainingPokemon())
		{
			// Fails against trainers on their last Pokemon
			if (super.category == Category.STATUS)
			{
				b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			}
			
			return;
		}
		
		// Swap to a random Pokemon!
		b.addMessage({0});
		trainer.switchToRandom();
		victim = trainer.front();
		b.enterBattle(victim, "...and " + victim.getName() + " was dragged out!");
		###
	*
***
Override:
	SelfSwitching:
		AddMapField: Apply:
		// First execute the move as normal
		super.apply(me, o, b);
		
		Team t = b.getTrainer(me.user());
		if (t instanceof WildPokemon)
		{
			// End the battle against a wild Pokemon
			b.addMessage(me.getName() + " left the battle!");
			b.addMessage(" ", MessageUpdate.Update.EXIT_BATTLE);
			return;
		}
		
		Trainer trainer = (Trainer)t;
		if (!trainer.hasRemainingPokemon())
		{
			// Don't switch if no one to switch to
			return;
		}
		
		// Send this Pokemon back to the trainer and send out the next one
		b.addMessage(me.getName() + " went back to " + trainer.getName() + "!");
		trainer.switchToRandom(); // TODO: Prompt a legit switch fo user
		me = trainer.front();
		b.enterBattle(me, trainer.getName() + " sent out " + me.getName() + "!");
		###
	*
***
EndTurnEffect:
	ApplyEndTurn:
		Header: void applyEndTurn(ActivePokemon victim, Battle b)
	*
***
BeforeTurnEffect:
	CanAttack:
		Header: boolean canAttack(ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
OpponentBeforeTurnEffect:
	OpponentCanAttack:
		Header: boolean opposingCanAttack(ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
Override:
	ProtectingEffect:
		AddInterface: OpponentBeforeTurnEffect
		AddMapField: MinTurns: 1
		AddMapField: MaxTurns: 1
		AddMapField: CastMessage: victim.getName() + " protected itself!"
		AddMapField: SuccessiveDecay: True
		AddMapField: OnProtectingSuccess:
		// No additional effects
		###
		AddMapField: ProtectingCondition: true
		AddMapField: OpponentCanAttack:
		// Self-target moves, moves that penetrate Protect, and other conditions
		if (p.getAttack().isSelfTarget() || p.getAttack().isMoveType(MoveType.FIELD) || p.getAttack().isMoveType(MoveType.PROTECT_PIERCING) || !protectingCondition(b, p)) 
		{
			return true;
		}
		
		// Protect is a success!
		b.printAttacking(p);
		b.addMessage(opp.getName() + " is protecting itself!");
		Battle.invoke(new Object[] {p.getAttack()}, CrashDamageMove.class, "crash", b, p);
	
		// Additional Effects
		protectingEffects(p, opp, b);

		return false;
		###
	*
***
Override:
	ProtectingCondition:
		Header: boolean protectingCondition(Battle b, ActivePokemon attacking)
		Body:
		return {0};
		###
	*
***
Override:
	OnProtectingSuccess:
		Header: void protectingEffects(ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
Override: 
	SuccessiveDecay:
		AddMapField: Cast:
		if (Math.random() > caster.getAttributes().getSuccessionDecayRate())
		{
			b.addMessage(this.getFailMessage(b, caster, victim));
			return;
		}

		super.cast(b, caster, victim, source, printCast);
		###
	*
***
TrappingEffect:
	Trapped:
		Header: boolean isTrapped(Battle b, ActivePokemon p)
		Optional: True
		Default:
		// Ghost-type Pokemon can always escape
		return !p.isType(b, Type.GHOST);
		###
	*
	TrappingMessage:
		Header: String trappingMessage(ActivePokemon trapped)
		Body:
		return {0};
		###
	*
***
OpponentTrappingEffect:
	OppTrapped: 
		Header: boolean trapOpponent(Battle b, ActivePokemon p)
	*
	OppTrappingMessage:
		Header: String opponentTrappingMessage(ActivePokemon escaper, ActivePokemon trapper)
		Optional: True
		Default:
		return trapper.getName() + "'s " + this.getName() + " prevents " + escaper.getName() + " from escaping!";
		###
	*
***
Override:
	PartialTrap:
		AddMapField: Cast:
		super.cast(b, caster, victim, source, printCast);
		if (caster.isHoldingItem(b, Namesies.GRIP_CLAW_ITEM)) setTurns(5);
		###
		AddInterface: EndTurnEffect
		AddInterface: TrappingEffect
		AddInterface: RapidSpinRelease
		AddMapField: MinTurns: 4
		AddMapField: MaxTurns: 5
		AddMapField: NextTurnSubside: True
		AddMapField: CastMessage: {2-}
		AddMapField: SubsideMessage: victim.getName() + " is no longer trapped by {1_}."
		AddMapField: RapidSpin: user.getName() + " was released from {1_}!"
		AddMapField: TrappingMessage: trapped.getName() + " cannot be recalled due to {1_}!"
		AddMapField: ApplyEndTurn:
		if (victim.hasAbility(Namesies.MAGIC_GUARD_ABILITY)) 
		{
			return;
		}
		
		b.addMessage(victim.getName() + " is hurt by {1_}!");
		
		// Reduce 1/8 of the victim's total health, or 1/6 if holding a binding band
		victim.reduceHealthFraction(b, b.getOtherPokemon(victim.user()).isHoldingItem(b, Namesies.BINDING_BAND_ITEM) ? 1/6.0 : 1/8.0);
		###
	*
***
Override:
	SafeguardEffect:
		AddMapField: CastMessage: user.getName() + " is covered by a veil!"
		AddMapField: SubsideMessage: "The effects of " + victim.getName() + "'s {0} faded."
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
		AddInterface: StatusPreventionEffect
		AddMapField: StatusPrevent: 
		return !caster.hasAbility(Namesies.INFILTRATOR_ABILITY);
		###
		AddMapField: StatusPreventMessage: "{0} protects " + victim.getName() + " from status conditions!"
	*
***
Override:
	UsedProof:
		AddMapField: CanHave: True
		AddMapField: Cast: 
		if (!victim.hasEffect(this.namesies))
		{
			super.cast(b, caster, victim, source, printCast);
		}
		else 
		{
			b.addMessage(getCastMessage(b, caster, victim));
		}
		###
	*
***
Override:
	Cast:
		Header: void cast(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source, boolean printCast)
	*
***
Override:
	CastMessage:
		Header: String getCastMessage(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
Override:
	SubsideMessage:
		Header: String getSubsideMessage(ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
Override:
	ApplyError:
		AddMapField: Apply:
		if ({0})
		{
			b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			return;
		}
		
		super.apply(me, o, b);
		###
	*
***
Override:
	WeightBased:
		AddMapField: GetPow: 
		double weight = {0}.getWeight(b);
		if (weight < 22) return 20;
		if (weight < 55) return 40;
		if (weight < 110) return 60;
		if (weight < 220) return 80;
		if (weight < 440) return 100;
		return 120;
		###
	*
***
Override:
	WeightRatio:
		AddMapField: GetPow: 
		double ratio = {1}.getWeight(b)/{2}.getWeight(b);
		if (ratio > .5) return 40;
		if (ratio > .33) return 60;
		if (ratio > .25) return 80;
		if (ratio > .2) return 100;
		return 120;
		###
	*
***
Override:
	StatRatio:
		AddMapField: GetPow: 
		double ratio = (double)Stat.getStat(Stat.{11}, {2}, {3}, b)/Stat.getStat(Stat.{11}, {3}, {2}, b);
		if (ratio > .5) return 60;
		if (ratio > .33) return 80;
		if (ratio > .25) return 120;
		return 150;
		###
	*
***
RapidSpinRelease:
	RapidSpin:
		Header: void releaseRapidSpin(Battle b, ActivePokemon user)
		Body:
		b.addMessage({0});
		
		// This is a little hacky and I'm not a super fan but I don't feel like distinguishing in the generator if this a PokemonEffect or a TeamEffect, so just try to remove from both list
		user.getEffects().remove(this);
		b.getEffects(user.user()).remove(this);
		###
	*
***
StatChangingEffect:
	ModifyStat:
		Header: int modify(Integer statValue, ActivePokemon p, ActivePokemon opp, Stat s, Battle b)
		Begin: 
		int stat = statValue;
		###
	*
***
Override:
	ModifyMultiplier:
		AddInterface: StatChangingEffect
		AddMapField: ModifyStat:
		if (isModifyStat(s) && {2-})
		{
			stat *= {1};
		}
		
		return stat;
		###
	*
***
Override:
	TwoModify:
		Header: boolean isModifyStat(Stat s)
		Body:
		return s == Stat.{11} || s == Stat.{22};
		###
	*
***
Override:
	ToModify:
		Header: boolean isModifyStat(Stat s)
		Body:
		return s == Stat.{00};
		###
	*
***
MoveCondition:
	GetMove:
		Header: Move getMove()
	*
***
ForceMoveEffect:
	GetForceMove:
		Header: Move getMove()
	*
***
Override:
	Subside:
		Header: void subside(Battle b, ActivePokemon p)
	*
***
AttackSelectionEffect:
	Usable:
		Header: boolean usable(ActivePokemon p, Move m)
	*
	UnusableMessage:
		Header: String getUnusableMessage(ActivePokemon p)
		Body: 
		return {0};
		###
	*
***
Override:
	ShouldSubside:
		Header: boolean shouldSubside(Battle b, ActivePokemon victim)
	*
***
EntryEffect:
	Enter:
		Header: void enter(Battle b, ActivePokemon victim)
	*
***
TypeCondition:
	GetTypeCondition:	
		Header: Type[] getType(Battle b, ActivePokemon p, Boolean display)
	*
***
NameChanger:
	GetNameChange:
		Header: String getNameChange()
	*
	SetNameChange:
		Header: void setNameChange(Battle b, ActivePokemon victim)
	*
***
Override:
	IsActive:
		Header: boolean isActive()
	*
***
Override:
	Deactivate:
		Header: void deactivate(Battle b, ActivePokemon victim)
	*
***
Override:
	GetTurns:
		Header: int getTurns()
	*
***
StatusPreventionEffect:
	StatusPrevent:
		Header: boolean preventStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusCondition status)
	*
	StatusPreventMessage:
		Header: String statusPreventionMessage(ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
PowerChangeEffect:
	GetMultiplier:
		Header: double getMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
OpponentPowerChangeEffect:
	GetOppMultiplier:
		Header: double getOpponentMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
IntegerCondition:
	IntegerName:
		AddMapField: GetAmount: {0}
		AddMapField: DecreaseAmount: {0}
		AddMapField: IncreaseAmount: {0}
	*
	GetAmount:
		Header: int getAmount()
		Body:
		return {0};
		###
	*
	DecreaseAmount:
		Header: void decrease(int amount)
		Body:
		{0} -= amount;
		###
	*
	IncreaseAmount:
		Header: void increase(int amount)
		Body:
		{0} += amount;
		###
	*
***
EffectBlockerEffect:
	ValidMove:
		Header: boolean validMove(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
StatProtectingEffect:
	StatProtect:
		Header: boolean prevent(Battle b, ActivePokemon caster, ActivePokemon victim, Stat stat)
	*
	StatProtectMessage:
		Header: String preventionMessage(ActivePokemon p, Stat s)
		Optional: True
		Default:
		return p.getName() + "'s " + this.getName() + " prevents its " + s.getName().toLowerCase() + " from being lowered!";
		###
	*
***
Override:
	Sporty:
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier: 
		return user.getAttackType() == Type.{11} ? .33 : 1;
		###
		AddMapField: CastMessage: "{2}'s power was weakened!"
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
		AddMapField: SubsideMessage: "The effects of {3} Sport wore off."
	*
***
Override:
	SpecialRoom:
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
		AddMapField: SubsideMessage: "The dimensions of the {1} room returned to normal."
		AddMapField: CastMessage: user.getName() + " twisted the dimensions to {2-}!"
		AddMapField: CanHave: True
		AddMapField: Cast: 
		Effect roomsies = Effect.getEffect(b.getEffects(), this.namesies);
		if (roomsies == null)
		{
			super.cast(b, caster, victim, source, printCast);
			return;
		}
	
		// Remove the effect if it's already in play
		b.addMessage(roomsies.getSubsideMessage(caster));
		Effect.removeEffect(b.getEffects(), this.namesies);
		###
	*
***
Override:
	MoveTypePrevent:
		AddInterface: OpponentBeforeTurnEffect
		AddMapField: OpponentCanAttack:
		if (p.getAttack().isMoveType(MoveType.{00}))
		{
			b.printAttacking(p);
			b.addMessage(opp.getName() + "'s " + this.getName() + " prevents " + p.getAttack().getName() + " from being used!");
			return false;
		}
		
		return true;
		###
	*
***
FaintEffect:
	Deathwish:
		Header: void deathwish(Battle b, ActivePokemon dead, ActivePokemon murderer)
	*
***
PassableEffect:
***
Override:
	FailMessage:
		Header: String getFailMessage(Battle b, ActivePokemon user, ActivePokemon victim)
		End:
		
		return super.getFailMessage(b, user, victim);
		###
	*
***
DefogRelease:
	Defog:
		Header: void releaseDefog(Battle b, ActivePokemon victim)
		Body:
		b.addMessage({0});
		
		// This is a little hacky and I'm not a super fan but I don't feel like distinguishing in the generator if this a PokemonEffect or a TeamEffect, so just try to remove from both lists
		victim.getEffects().remove(this);
		b.getEffects(victim.user()).remove(this);
		###
	*
***
AbilityCondition:
	GetAbility:
		Header: Ability getAbility()
	*
***
ItemCondition:
	GetItem:
		Header: Item getItem()
	*
***
BracingEffect:
	Bracing:
		Header: boolean isBracing(Battle b, ActivePokemon bracer, Boolean fullHealth)
	*
	BraceMessage:
		Header: String braceMessage(ActivePokemon bracer)
		Body:
		return {0};
		###
	*
***
MoveListCondition:
	GetMoveList:
		Header: Move[] getMoveList(ActivePokemon p, Move[] moves)
	*
***
StatsCondition:
	GetStat:
		Header: int getStat(ActivePokemon user, Stat stat)
	*
***
CritStageEffect:
	IncreaseCritStage:
		Header: int increaseCritStage(Integer stage, ActivePokemon p)
		Optional: True
		Default:
		return stage + 1;
		###
	*
***
LevitationEffect:
	FallMessage:
		Header: void fall(Battle b, ActivePokemon fallen)
		Body:
		b.addMessage({0});
		Effect.removeEffect(fallen.getEffects(), this.namesies());
		###
	*
***
GroundedEffect:
	RemoveLevitation:
		Header: void removeLevitation(Battle b, ActivePokemon p)
		Optional: True
		Default:
		if (p.isSemiInvulnerableFlying())
		{
			p.getMove().switchReady(b, p);
			b.addMessage(p.getName() + " fell to the ground!");
		}
		
		Battle.invoke(b.getEffectsList(p), LevitationEffect.class, "fall", b, p);
		###
		AddInterface: BeforeTurnEffect
		AddMapField: CanAttack:
		if (p.getAttack().isMoveType(MoveType.AIRBORNE))
		{
			b.printAttacking(p);
			b.addMessage(Effect.DEFAULT_FAIL_MESSAGE);
			return false;
		}
		
		return true;
		###
	*
***
TerrainEffect:
	Terrain:
		AddMapField: Cast:
		// Remove all other Terrain Effects
		for (int i = 0; i < b.getEffects().size(); i++)
		{
			Effect effect = b.getEffects().get(i);
			if (effect instanceof TerrainEffect)
			{
				b.getEffects().remove(i);
				i--;
			}
		}
		
		super.cast(b, caster, victim, source, printCast);
		b.setTerrainType(TerrainType.{00}, false); // TODO: Need to send a terrain change message
		###
		AddMapField: Subside:
		super.subside(b, p);
		b.resetTerrain();
		###
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
	*
***
EndBattleEffect:
	EndBattle:
		Header: void afterBattle(Trainer player, Battle b, ActivePokemon p)
	*
***
PhysicalContactEffect:
	Contact:
		Header: void contact(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
DamageBlocker:
	Block:
		Header: boolean block(Type attacking, ActivePokemon victim)
	*
	AlternateEffect:
		Header: void alternateEffect(Battle b, ActivePokemon victim)
	*
***
Override:
	BlockType:
		AddInterface: DamageBlocker
		AddMapField: Block:
		return attacking == Type.{00};
		###
		AddMapField: AlternateEffect:
		b.addMessage(victim.getName() + "'s " + this.getName() + " makes it immune to " + Type.{00}.getName() + " type moves!");
		victim.getAttributes().modifyStage(victim, victim, 1, toIncrease(), b, CastSource.ABILITY);
		###
	*
***
Override:
	AbsorbType:
		AddInterface: DamageBlocker
		AddMapField: Block:
		return attacking == Type.{00};
		###
		AddMapField: AlternateEffect:
		b.addMessage(victim.getName() + "'s " + this.getName() + " makes it immune to " + Type.{00}.getName() + " moves!");
		
		// Technically, according to the description, Heal Block prevents the prevention entirely (meaning this should be in Block), but that makes no sense, they shouldn't take damage, this way makes more sense
		if (victim.fullHealth() || victim.hasEffect(Namesies.HEAL_BLOCK_EFFECT))
		{
			return;
		}
		
		victim.healHealthFraction(1/4.0);
		b.addMessage(victim.getName() + "'s HP was restored instead!", victim);
		###
	*
***
Override:
	EndTurnStatusCure:
		AddInterface: EndTurnEffect
		AddMapField: ApplyEndTurn: 
		if (victim.hasStatus() && {0})
		{
			Status.removeStatus(b, victim, CastSource.ABILITY);
		}
		###
	*
***
Override:
	PinchAbility:
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier: 
		return user.getHPRatio() < 1/3.0 && user.getAttackType() == Type.{00} ? 1.5 : 1;
		###
	*
***
Override:
	StatusPreventAbility:
		AddInterface: StatusPreventionEffect
		AddMapField: StatusPrevent: 
		return status == StatusCondition.{11};
		###
		AddMapField: StatusPreventMessage: victim.getName() + "'s " + this.getName() + " prevents {2}!"
	*
***
Override:
	StatusContact:
		AddMapField: Contact: 
		if (Math.random()*100 < 30)
		{
			Status.giveStatus(b, victim, user, StatusCondition.{00}, true);
		}
		###
		AddInterface: PhysicalContactEffect
	*
***
Override:
	SpeedWeather:
		AddMapField: ToModify: Speed
		AddMapField: ModifyMultiplier: 2 b.getWeather().namesies() == Namesies.{00}_EFFECT
	*
***
Override:
	WeatherStarter:
		AddInterface: EntryEffect
		AddMapField: Enter: 
		b.addEffect(Weather.getEffect(Namesies.{11}_EFFECT).newInstance());
		b.addMessage(victim.getName() + "'s " + this.getName() + " {2-}!");
		###
	*
***
Override:
	WeatherEvasion:
		AddInterface: StageChangingEffect
		AddMapField: StageChange: 
		return s == Stat.EVASION && b.getWeather().namesies() == Namesies.{00}_EFFECT ? stage + 1 : stage;
		###
	*
***
Override:
	WeatherEliminate:
		AddInterface: EntryEffect
		AddMapField: Enter: 
		// TODO: I think this isn't the intended effect of this ability
		b.addEffect(Weather.getEffect(Namesies.CLEAR_SKIES_EFFECT));
		b.addMessage(victim.getName() + "'s " + this.getName() + " eliminated the weather!");
		###
	*
***
HalfWeightEffect:
	HalfAmount:
		Header: int getHalfAmount(Integer halfAmount)
		Body:
		return halfAmount + {0};
		###
	*
***
WeatherBlockerEffect:
	WeatherBlock:
		Header: boolean block(Namesies weather)
	*
***
ApplyDamageEffect:
	OnApplyDamage:
		Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, Integer damage)
	*
***
ModifyStageValueEffect:
	ModifyStageValue:
		Header: int modifyStageValue(int modVal)
	*
***
SwitchOutEffect:
	SwitchOut:
		Header: void switchOut(ActivePokemon switchee)
	*
***
TakeDamageEffect:
	OnTakeDamage:
		Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
StallingEffect:
***
DefiniteEscape:
***
HoldItem:
	Fling:
		Header: int flingDamage()
		Body:
		return {0};
		###
	*
	FlingEffect:
		Header: void flingEffect(Battle b, ActivePokemon pelted)
		Optional: True
		Default:
		###
	*
***
TrainerUseItem:
	TrainerUse:
		Header: boolean use(Trainer t)
	*
***
PokemonUseItem:
	PokemonUse:
		Header: boolean use(CharacterData player, ActivePokemon p)
	*
***
BattleUseItem:
	BattleUse:
		Header: boolean use(ActivePokemon p, Battle b)
		Optional: True
		Default:
		return use(b.getPlayer(), p);
		###
	*
***
MoveUseItem:
	MoveUse:
		Header: boolean use(ActivePokemon p, Move m)
	*
***
Override:
	IncreaseStat:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
	*
***
Override:
	TypeTakeDamageStatIncrease:
		AddMapField: OnTakeDamage:
		if (user.getAttackType() == Type.{11} && victim.getAttributes().modifyStage(victim, victim, 1, Stat.{22}, b, CastSource.HELD_ITEM))
		{
			victim.consumeItem(b);
		}
		###
		AddInterface: HoldItem
		AddInterface: ConsumableItem
		AddInterface: TakeDamageEffect
	*
***
ConsumableItem:
***
Override:
	ChoiceItem:
		AddMapField: ToModify: {0}
		AddMapField: ModifyMultiplier: 1.5 true
		AddInterface: AttackSelectionEffect
		AddMapField: Usable:
		Move last = p.getAttributes().getLastMoveUsed();
		if (last == null || m == last)
		{
			return true;
		}
		
		return false;
		###
		AddMapField: UnusableMessage: p.getName() + "'s " + super.name + " only allows " + p.getAttributes().getLastMoveUsed().getAttack().getName() + " to be used!"
		AddInterface: HoldItem
		AddMapField: Fling: 10
	*
***
Override:
	Wing:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddMapField: EVIncreaseAmt: 1
		AddMapField: Price: 3000
		AddMapField: Fling: 20
		AddInterface: HoldItem
		AddMapField: Cat: Stat
	*
***
Override:	
	Vitamin:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddMapField: EVIncreaseAmt: 10
		AddMapField: Price: 9800
		AddMapField: Fling: 30
		AddInterface: HoldItem
		AddMapField: Cat: Stat
	*
***
RepellingEffect:
	RepelChance:
		Header: double chance()
		Body:
		return {0};
		###
	*
***
Override:
	BuffetImmune:
		AddMapField: Field:
		private static Type[] immunees = new Type[] {{0}};
		###
	*
***
Override:
	BuffetMessage:
		AddMapField: Field:
		private void buffet(Battle b, ActivePokemon p)
		{
			// Don't buffet the immune!
			for (Type type : immunees)
				if (p.isType(b, type))
					return;
			
			// Srsly don't buffet the immune!!
			Object[] list = b.getEffectsList(p);
			Object checkeroo = Battle.checkInvoke(true, list, WeatherBlockerEffect.class, "block", weatherElement);
			if (checkeroo != null)
			{
				return;
			}

			// Buffety buffety buffet
			b.addMessage({0});
			p.reduceHealthFraction(b, 1/16.0);
		}
		###
	*
***
Override:
	PreBuffetMessage:
		AddInterface: Hidden-EndTurnEffect
		AddMapField: ApplyEndTurn:
		b.addMessage({0});
				
		ActivePokemon other = b.getOtherPokemon(victim.user());
		buffet(b, victim);
		buffet(b, other);
		###
	*
***
Override:
	WeatherStatChange:
		AddInterface: StatChangingEffect
		AddMapField: ModifyStat:
		if (s == Stat.ATTACK || s == Stat.SP_ATTACK)
		{
			if (p.isAttackType(Type.{11}))
			{
				// {1} is fiddy percent stronger in tha weathz
				stat *= 1.5;
			}
			else if (p.isAttackType(Type.{22}))
			{
				// {2} is fiddy percent weaker in tha weathz
				stat *= .5;
			}
		}
		
		return stat;
		###
	*
***
WeatherExtendingEffect:
	WeatherType:
		Header: Namesies getWeatherType()
		Body:
		return Namesies.{00}_EFFECT;
		###
	*
***
EVItem:
	GetEVs:
		Header: int[] getEVs(int[] vals)
		AddInterface: Hidden-HoldItem
	*
***
TargetSwapperEffect:
	TargetSwap:
		Header: boolean swapTarget(Battle b, ActivePokemon user, ActivePokemon opponent)
	*
***
Override:
	MagicReflection:
		AddInterface: TargetSwapperEffect
		AddMapField: TargetSwap:
		Attack attack = user.getAttack();
		if (!attack.isSelfTarget() && attack.getCategory() == Category.STATUS && !attack.isMoveType(MoveType.NO_MAGIC_COAT))
		{
			b.addMessage(opponent.getName() + "'s " + {0} + " reflected " + user.getName() + "'s move!");
			return true;
		}
		
		return false;
		###
	*
***
PowerItem:
	PowerStat:
		Header: Stat powerStat()
		Body:
		return Stat.{00};
		###
		AddMapField: ToModify: Speed
		AddMapField: ModifyMultiplier: .5 true
		AddInterface: Hidden-EVItem
		AddMapField: GetEVs:
		vals[powerStat().index()] += 4;
		return vals;
		###
		AddMapField: Fling: 70
		AddMapField: Price: 3000
		AddMapField: Cat: Misc
	*
***
GemItem:
	GemType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: Hidden-PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.isAttackType(getType()))
		{
			// Consume the item
			b.addMessage(user.getName() + "'s " + this.getName() + " enhanced " + user.getAttack().getName() + "'s power!");
			user.consumeItem(b);

			// Gems increase the power of the move by 50% -- technically 30% in Gen 6 but they suck enough as is being a consumed item and all
			return 1.5;
		}

		return 1;
		###
		AddInterface: Hidden-HoldItem
		AddMapField: Fling: 30
		AddMapField: Cat: Misc
		AddMapField: Price: 100
	*
***
Override:
	TypeEnhance:
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.isAttackType(Type.{00}))
		{
			return 1.2;
		}

		return 1;
		###
		AddInterface: HoldItem
		AddMapField: Cat: Misc
	*
***
Override:
	PPIncrease:
		AddMapField: Fling: 30
		AddMapField: Field:
		private String increase;
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + increase + "'s Max PP was increased!"
		AddMapField: MoveUse:
		increase = m.getAttack().getName();
		return m.increaseMaxPP({0});
		###
		AddInterface: MoveUseItem
		AddInterface: HoldItem
		AddMapField: Cat: Stat
	*
***
Override:
	Ether:
		AddInterface: MoveUseItem
		AddMapField: BattleCat: HP_PP
		AddMapField: MoveUse:
		// TODO: Need to be able to call these from the battle! (BattleMoveUse? yuck) -- Test messages once completed
		restore = m.getAttack().getName();
		return m.increasePP({0});
		###
		AddMapField: Field: 
		private String restore;
		###
		AddMapField: SuccessMessage: p.getName() + "'s PP for " + restore + " PP was restored!"
	*
***
Override:
	Elixir:
		Header: int increaseAmount(Move m)
		Body:
		return {0};
		###
		AddMapField: Field:
		private boolean use(List<Move> moves)
		{
			boolean changed = false;
			for (Move m : moves)
			{
				changed |= m.increasePP(increaseAmount(m));
			}
			
			return changed;
		}
		###
		AddMapField: BattleUse:
		return use(p.getMoves(b));
		###
		AddMapField: PokemonUse:
		return use(p.getActualMoves());
		###
		AddMapField: SuccessMessage: p.getName() + "'s PP was restored!"
		AddMapField: Fling: 30
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
		AddInterface: HoldItem
		AddMapField: Cat: Medicine
		AddMapField: BattleCat: HP_PP
	*
***
Override:
	TimeSpaceOrb:
		Header: boolean canUseOrb(ActivePokemon user)
		Body:
		if (!user.isPokemon(Namesies.{11}_POKEMON))
		{
			return false;
		}
		
		return user.isAttackType(Type.DRAGON) || user.isAttackType(Type.{22});
		###
		AddMapField: Fling: 60
		AddMapField: Price: 10000
		AddInterface: HoldItem
		AddInterface: PowerChangeEffect
		AddMapField: Cat: Misc
		AddMapField: GetMultiplier:
		if (canUseOrb(user))
		{
			return 1.2;
		}
		
		return 1;
		###
	*
***
PlateItem:
	PlateType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: Hidden-HoldItem
		AddMapField: Price: 1000
		AddMapField: Fling: 90
		AddMapField: Cat: Misc
		AddInterface: Hidden-PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.isAttackType(getType()))
		{
			return 1.2;
		}

		return 1;
		###
	*
***
DriveItem:
	DriveType:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: Hidden-HoldItem
		AddMapField: Fling: 70
		AddMapField: Price: 1000
		AddMapField: Cat: Misc
	*
***
Override:
	EvolutionItem:
		AddInterface: PokemonUseItem
		AddMapField: SuccessMessage: ""
		AddMapField: PokemonUse:
		Evolution ev = p.getPokemonInfo().getEvolution();
		BaseEvolution base = (BaseEvolution) ev.getEvolution(EvolutionCheck.ITEM, p, this.namesies);
		if (base == null)
		{
			return false;
		}

		player.setEvolution(p, base);
		return true;
		###
	*
***
Override:
	FullHeal:
		AddMapField: PokemonUse:
		// Does not apply to the dead
		if (p.hasStatus(StatusCondition.FAINTED)) 
		{	
			return false;
		}
		
		// YOU'RE FINE
		if (!p.hasStatus())
		{
			return false;
		}
		
		p.removeStatus();
		return true;
		###
		AddMapField: SuccessMessage: p.getName() + " was cured of its status condition!"
		AddMapField: BattleCat: Status
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
	*
***
Override:
	Revive:
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
		AddInterface: HoldItem
		AddMapField: Cat: Medicine
		AddMapField: BattleCat: Status
		AddMapField: Fling: 30
		AddMapField: PokemonUse:
		// Only applies to the dead
		if (!p.hasStatus(StatusCondition.FAINTED)) 
		{
			return false;
		}
		
		p.removeStatus();
		p.healHealthFraction({1});
		
		return true;
		###
		AddMapField: SuccessMessage: p.getName() + " was {2} revived!"
	*
***
Override:
	StatusRemove:
		Header: StatusCondition toRemove()
		Body:
		return StatusCondition.{00};
		###
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
		AddMapField: PokemonUse:
		if (!p.hasStatus(toRemove()))
		{
			return false;
		}

		message = Status.getRemoveStatus(null, p, CastSource.USE_ITEM);
		return true;
		###
		AddMapField: SuccessMessage: message
		AddMapField: Field:
		private String message;
		###
	*
***
Override:
	HealAmt:
		Header: int healAmount()
		Body:
		return {0};
		###
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
		AddMapField: PokemonUse:
		return p.heal(healAmount()) != 0;
		###
		AddMapField: SuccessMessage: p.getName() + "'s health was restored!"
		AddMapField: Cat: Medicine
		AddMapField: BattleCat: HP_PP
		AddMapField: Fling: 30
		AddInterface: HoldItem
	*
***
Override:
	XStageIncrease:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddMapField: Fling: 30
		AddMapField: Cat: Stat
		AddMapField: BattleCat: Battle
		AddInterface: HoldItem
		AddInterface: BattleUseItem
		AddMapField: BattleUse:
		return p.getAttributes().modifyStage(p, p, 1, toIncrease(), b, CastSource.USE_ITEM);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toIncrease().getName() + " was raised!"
	*
***
Override:
	EVIncrease:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
	*
***
Override:
	EVIncreaseAmt:
		Header: int increaseAmount()
		Body:
		return {0};
		###
		AddInterface: PokemonUseItem
		AddMapField: PokemonUse:
		int[] toAdd = new int[Stat.NUM_STATS];
		toAdd[toIncrease().index()] += increaseAmount();

		return p.addEVs(toAdd);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toIncrease().getName() + " was raised!"
	*
***
BallItem:
	CatchRate:
		Header: double[] catchRate(ActivePokemon me, ActivePokemon o, Battle b)
		Try:
		return new double[] {{0}, 0};
		###
		AddMapField: Cat: Ball
		AddMapField: BattleCat: Ball
	*
	AfterCaught:
		Header: void afterCaught(ActivePokemon p)
		Optional: True
		Default:
		###
	*
***
Override:
	EVDecreaseBerry:
		Header: Stat toDecrease()
		Body:
		return Stat.{00};
		###
		AddInterface: Berry
		AddInterface: PokemonUseItem
		AddMapField: PokemonUse:
		int[] vals = new int[Stat.NUM_STATS];
		if (p.getEV(toDecrease().index()) > 110)
			vals[toDecrease().index()] = 100 - p.getEV(toDecrease().index());
		else
			vals[toDecrease().index()] -= 10;

		return p.addEVs(vals);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toDecrease().getName() + " was lowered!"
		AddMapField: NGPow: 90
	*
***
Override:
	SuperEffectivePowerReduceBerry:
		AddInterface: Berry
		AddMapField: NGPow: 80
		AddMapField: NGType: {0}
		AddInterface: OpponentPowerChangeEffect
		AddMapField: GetOppMultiplier:
		if (user.getAttackType() == Type.{00} && Type.getAdvantage(user, victim, b) > 1)
		{
			b.addMessage(victim.getName() + "'s " + this.name + " decreased " + user.getName() + "'s attack!");
			victim.consumeItem(b);
			return .5;
		}

		return 1;
		###
	*
***
Override:
	HealthTriggeredStageIncreaseBerry:
		AddInterface: HealthTriggeredBerry
		AddMapField: HealthTrigger:
		if (user.getAttributes().modifyStage(user, user, 1, Stat.{00}, b, source))
		{
			return true;
		}

		return false;
		###
		AddMapField: HealthTriggerRatio: 4
		AddMapField: SuccessMessage: p.getName() + "'s " + Stat.{00}.getName() + " increased!"
		AddMapField: HoldSuccessMessage: ""
		AddMapField: NGPow: 100
	*
***
Override:
	CategoryIncreaseBerry:
		Header: boolean checkModify(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		return user.getAttack().getCategory() == Category.{11} && victim.getAttributes().modifyStage(victim, victim, 1, Stat.{22}, b, CastSource.HELD_ITEM);
		###
		AddMapField: NGPow: 100
		AddInterface: Berry
		AddInterface: TakeDamageEffect
		AddMapField: OnTakeDamage:
		if (checkModify(b, user, victim))
		{
			victim.consumeItem(b);
		}
		###
	*
***
Override:
	CategoryDamagerBerry:
		Header: Category getCategory()
		Body:
		return Category.{00};
		###
		AddMapField: NGPow: 100
		AddInterface: Berry
		AddInterface: TakeDamageEffect
		AddMapField: OnTakeDamage:
		if (user.getAttack().getCategory() == getCategory())
		{
			b.addMessage(user.getName() + " was hurt by " + victim.getName() + "'s " + this.name + "!");
			user.reduceHealthFraction(b, 1/8.0);
			victim.consumeItem(b);
		}
		###
	*
***
Override:
	HealPartyStatus:
		AddMapField: ApplyEffects:
		for (ActivePokemon p : b.getTrainer(user.user()).getTeam())
		{
			if (!p.hasStatus(StatusCondition.FAINTED)) 
			{
				p.removeStatus();
			}
		}
		
		b.addMessage("All status problems were cured!");
		###
		AddMapField: SelfTarget: True
	*
***
Override:
	ForesightEffect:
		AddMapField: CastMessage: user.getName() + " identified " + victim.getName() + "!"
		AddMapField: CanHave: True
		AddMapField: UsedProof: True
		AddInterface: AdvantageChanger
		AddMapField: AdvantageChange: (attacking == Type.{11} || attacking == Type.{22}) && defending[i] == Type.{33}
	*
***
Override:
	ForesightMove:
		AddMapField: Effect: Pokemon {0}
		AddMapField: ApplyEffects: 
		super.applyEffects(b, user, victim);
		victim.getAttributes().resetStage(Stat.EVASION);
		###
		AddMapField: MoveType: Substitute_Piercing
	*
***
Override:
	AddTypeMove:
		AddInterface: ChangeTypeMove
		AddMapField: Effect: Pokemon ChangeType
		AddMapField: ChangeType:
		Type primary = victim.getType(b)[0];
				
		return new Type[] {primary, primary == Type.{00} ? Type.NONE : Type.{00}};
		###
	*
***
Override:
	PrintFail:
		Header: boolean canPrintFail()
		Body:
		return {0};
		###
	*
***
Override:
	FutureAttackMove:
		AddMapField: Effect: Team {0}
		AddMapField: Apply:
		super.applyEffects(b, me, o); // Don't apply damage just yet!!
		###
		AddMapField: PrintFail: true
	*
***
Override:
	FutureAttackEffect:
		AddMapField: MinTurns: 2
		AddMapField: MaxTurns: 2
		AddMapField: NextTurnSubside: True
		AddMapField: Field: 
		private ActivePokemon theSeeer;
		###
		AddMapField: Activate: 
		x.theSeeer = theSeeer;
		###
		AddMapField: Subside: 
		b.addMessage(p.getName() + " took " + theSeeer.getName() + "'s attack!");
			
		Attack attack = Attack.getAttack(Namesies.{00}_ATTACK);
		
		// Don't do anything for moves that are uneffective
		if (!attack.effective(b, theSeeer, p))
		{
			return;
		}
		
		theSeeer.setMove(new Move(attack));
		theSeeer.getAttack().applyDamage(theSeeer, p, b);
		###
		AddMapField: Cast: 
		theSeeer = caster;
		super.cast(b, caster, victim, source, printCast);
		###
		AddMapField: CastMessage: theSeeer.getName() + " foresaw an attack!"
	*
***
Override:
	EliminateStatChanges:
		AddMapField: ApplyEffects: 
		user.getAttributes().resetStages();
		victim.getAttributes().resetStages();
		b.addMessage("All stat changes were eliminated!");
		###
	*
***
Override:
	StatSwapMove:
		AddMapField: Field:
		private static Stat[] swapStats = { Stat.{11}, Stat.{22} };
		###
		AddMapField: ApplyEffects: 
		for (Stat s : swapStats)
		{
			int statIndex = s.index();
			
			int userStat = user.getAttributes().getStage(statIndex);
			int victimStat = victim.getAttributes().getStage(statIndex);
			
			user.getAttributes().setStage(statIndex, victimStat);
			victim.getAttributes().setStage(statIndex, userStat);
		}
		
		b.addMessage(user.getName() + " swapped its stats with " + victim.getName() + "!");
		###
		AddMapField: MoveType: No_Magic_Coat
	*
***
StatusBerry:
	StatusBerryGainEffect:
		Optional: True
		AddMapField: GainEffect:
		if (!user.hasStatus(toRemove()))
		{
			return false;
		}

		holdMessage = Status.getRemoveStatus(b, user, source);
		###
		AddInterface: Hidden-GainableEffectBerry
		AddMapField: HoldSuccessMessage: holdMessage
		AddMapField: NGPow: 80
		AddMapField: Field:
		private String holdMessage;
		###
	*
***
GainableEffectBerry:
	GainEffect:
		Header: boolean gainBerryEffect(Battle b, ActivePokemon user, CastSource source)
		End:
		
		String message = "";
		switch (source)
		{
			case USE_ITEM:
				message = getSuccessMessage(user);
				break;
			case HELD_ITEM:
				message = getHoldSuccessMessage(b, user);
				break;
			default:
				Global.error("Use item and held item are the only valid cast sources for berries.");
		}
		
		b.addMessage(message, user);
		
		if (user.hasAbility(Namesies.CHEEK_POUCH_ABILITY) && !user.fullHealth())
		{
			b.addMessage(user.getName() + "'s " + Namesies.CHEEK_POUCH_ABILITY.getName() + " restored its health!");
			user.healHealthFraction(1/3.0);
			b.addMessage("", user);
		}
		
		// Eat dat berry!!
		PokemonEffect.getEffect(Namesies.EATEN_BERRY_EFFECT).cast(b, user, user, source, false);
		
		return true;
		###
		AddInterface: Hidden-Berry
		AddMapField: FlingEffect:
		gainBerryEffect(b, pelted, CastSource.USE_ITEM);
		###
	*
***
HealthTriggeredBerry:
	HealthTrigger:
		Header: boolean useHealthTriggerBerry(Battle b, ActivePokemon user, CastSource source)
		Optional: True
		Default:
		return use(user, b);
		###
		AddInterface: Hidden-GainableEffectBerry
		AddMapField: GainEffect:
		if (!useHealthTriggerBerry(b, user, source))
		{
			return false;
		}
		###
	*
	HealthTriggerRatio:
		Header: double healthTriggerRatio()
		Try:
		return 1/{0}.0;
		###
	*
***
Berry:
	NGPow:
		Header: int naturalGiftPower()
		Body:
		return {0};
		###
		AddMapField: Cat: Berry
		AddInterface: Hidden-HoldItem
		AddMapField: Fling: 10
		AddMapField: Price: 20
	*
	NGType:
		Header: Type naturalGiftType()
		Body:
		return Type.{00};
		###
	*
***
Override:
	RepelSteps:
		Header: int repelSteps()
		Body:
		return {0};
		###
		AddInterface: HoldItem
		AddMapField: Fling: 30
		AddInterface: TrainerUseItem
		AddMapField: TrainerUse:
		if (!(t instanceof CharacterData))
		{
			Global.error("Only the character should be using a Repel item");
		}

		CharacterData player = (CharacterData) t;
		if (player.isUsingRepel())
		{
			return false;
		}

		player.addRepelSteps(repelSteps());
		return true;
		###
		AddMapField: SuccessMessage: "Weak wild Pok\u00e9mon will not appear for " + repelSteps() + " steps!"
		AddMapField: Cat: Misc
	*
***
CritBlockerEffect:
	BlockCrits:
		Header: boolean blockCrits()
		Optional: True
		Default:
		return true;
		###
	*
***
Override:
	PowderResist:
		Header: String getPreventMessage(ActivePokemon victim)
		Body:
		return victim.getName() + "'s " + this.getName() + " protects it from powder moves!";
		###
		AddInterface: EffectBlockerEffect
		AddMapField: ValidMove:
		if (!user.getAttack().isMoveType(MoveType.POWDER)) 
		{
			return true;
		}
		
		if (user.getAttack().getCategory() == Category.STATUS) 
		{
			b.addMessage(getPreventMessage(victim));
		}
		
		return false;
		###
	*
***
AdvantageChanger:
	AdvantageChange:
		Header: Type[] getAdvantageChange(Type attacking, Type[] defending)
		Body:
		for (int i = 0; i < 2; i++)
		{
			if ({0})
			{
				defending[i] = Type.NONE;	
			}
		}
		
		return defending;
		###
	*
***
AdvantageMultiplier:
	MultiplyAdvantage:
		Header: double multiplyAdvantage(Type moveType, Type[] defendingType)
	*
***
Override:
	GetPow:
		Header: int setPower(Battle b, ActivePokemon me, ActivePokemon o)
	*
***
Override:
	ApplyDamage:
		Header: void applyDamage(ActivePokemon me, ActivePokemon o, Battle b)
	*
***
Override:
	GetAccuracy:
		Header: int getAccuracy(Battle b, ActivePokemon me, ActivePokemon o)
	*
***
Override:
	Apply:
		Header: void apply(ActivePokemon me, ActivePokemon o, Battle b)
	*
***
Override:
	Aura:
		Header: Type getAuraType()
		Body:
		return Type.{00};
		###
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.getAttackType() == getAuraType())
		{
			return 1 + .33*(victim.hasAbility(Namesies.AURA_BREAK_ABILITY) ? -1 : 1);
		}
		
		return 1;
		###
	*
***
Override:
	StealItem:
		Header: void steal(Battle b, ActivePokemon thief, ActivePokemon victim)
		Body:
		// Dead Pokemon and wild Pokemon cannot steal; 
		// Cannot steal if victim is not holding an item or thief is already holding an item;
		// Cannot steal from a Pokemon with the Sticky Hold ability 
		if (thief.isFainted(b) || !victim.isHoldingItem(b) || thief.isHoldingItem(b) || b.getTrainer(thief.user()) instanceof WildPokemon || victim.hasAbility(Namesies.STICKY_HOLD_ABILITY))
		{
			return;
		}
		
		// Stealers gon' steal
		Item stolen = victim.getHeldItem(b);
		b.addMessage(thief.getName() + " stole " + victim.getName() + "'s " + stolen.getName() + "!");
		
		if (b.isWildBattle())
		{
			victim.removeItem();
			thief.giveItem((HoldItem)stolen);
			return;
		}
		
		item = stolen;
		PokemonEffect.getEffect(Namesies.CHANGE_ITEM_EFFECT).cast(b, thief, thief, CastSource.ABILITY, false);
		
		item = Item.noneItem();
		PokemonEffect.getEffect(Namesies.CHANGE_ITEM_EFFECT).cast(b, thief, victim, CastSource.ABILITY, false);
		###
		AddInterface: ItemCondition
		AddMapField: Field:
		private Item item;
		###
		AddMapField: GetItem:
		return item;
		###
	*
***
Override:
	ConsumeBerry:
		AddMapField: ApplyEffects: 
		Item i = victim.getHeldItem(b);
		if (i instanceof Berry)
		{
			b.addMessage(user.getName() + " ate " + victim.getName() + "'s " + i.getName() + "!");
			victim.consumeItem(b);
			
			if (i instanceof GainableEffectBerry)
			{
				((GainableEffectBerry)i).gainBerryEffect(b, user, CastSource.USE_ITEM);
			}
		}
		###
	*
***
Override:
	ApplyEffects:
		Header: void applyEffects(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
Override:
	SuccessMessage:
		Header: String getSuccessMessage(ActivePokemon p)
		Body:
		return {0};
		###
	*
***
Override:
	HoldSuccessMessage:
		Header: String getHoldSuccessMessage(Battle b, ActivePokemon p)
		Body:
		return {0};
		###
	*
***
ChangeAttackTypeEffect:
	ChangeAttackType:
		Header: Type changeAttackType(Type original)
	*
***
Override:
	NormalTypeChanger:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: ChangeAttackTypeEffect
		AddMapField: ChangeAttackType:
		if (original == Type.NORMAL)
		{
			this.activated = true;
			return getType();
		}
		
		return original;
		###
		AddMapField: Field:
		private boolean activated;
		###
		AddMapField: Activate:
		x.activated = false;
		###
		AddInterface: EndTurnEffect
		AddMapField: ApplyEndTurn:
		this.activated = false;
		###
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		return activated ? 1.3 : 1;
		###
	*
***
StatLoweredEffect:
	NextLevel:
		Header: void takeItToTheNextLevel(Battle b, ActivePokemon caster, ActivePokemon victim)
		Body:
		victim.getAttributes().modifyStage(victim, victim, 2, Stat.{00}, b, CastSource.@SuperClass);
		###
	*
***
Override:
	FlinchItem:
		AddMapField: FlingEffect:
		PokemonEffect flinch = PokemonEffect.getEffect(Namesies.FLINCH_EFFECT);
		if (flinch.applies(b, pelted, pelted, CastSource.USE_ITEM))
		{
			flinch.cast(b, pelted, pelted, CastSource.USE_ITEM, false);
			b.addMessage("The " + this.name + " caused " + pelted.getName() + " to flinch!");
		}
		###
		AddMapField: OnApplyDamage:
		if (Math.random()*100 < 10)
		{
			PokemonEffect flinch = PokemonEffect.getEffect(Namesies.FLINCH_EFFECT);
			if (flinch.applies(b, user, victim, CastSource.HELD_ITEM))
			{
				flinch.cast(b, user, victim, CastSource.HELD_ITEM, false);
				b.addMessage(user.getName() + "'s " + this.name + " caused " + victim.getName() + " to flinch!");
			}
		}
		###
		AddInterface: ApplyDamageEffect
		AddInterface: HoldItem
	*
***
Override:
	StatusFling:
		AddMapField: FlingEffect:
		Status.giveStatus(b, pelted, pelted, StatusCondition.{00}, pelted.getName() + " was {0} by the " + this.name + "!");
		###
	*
***
Override:
	TM:
		Header: Attack getAttack()
		Body:
		return Attack.getAttack(Namesies.getValueOf("{0}", NamesiesType.ATTACK));
		###
		AddMapField: Cat: TM
		AddInterface: MoveUseItem
		AddMapField: SuccessMessage: p.getName() + " learned " + getAttack().getName() + "!"
		AddMapField: MoveUse:
		Attack attack = getAttack();
		
		// Cannot learn if you already know the move
		if (p.hasActualMove(attack.namesies()))
		{
			return false;
		}

		// Cannot learn if the TM is not compatible with the Pokemon
		if (!p.getPokemonInfo().isTmMove(attack.namesies()))
		{
			return false;
		}

		Move tmMove = new Move(attack);
		List<Move> moveList = p.getActualMoves();

		// If they don't have a full move list, append to the end
		if (moveList.size() < Move.MAX_MOVES)
		{
			p.addMove(null, tmMove, moveList.size());
			return true;
		}

		// Otherwise, go through their moves and find the one that matches and replace with the TM move
		for (int i = 0; i < moveList.size(); i++)
		{
			if (moveList.get(i).getAttack().namesies() == m.getAttack().namesies())
			{
				p.addMove(null, tmMove, i);
				return true;
			}
		}

		// Did not find move to replace -- throw error
		Global.error("ActivePokemon " + p.getName() + " does not have move to replace " + m.getAttack().getName());
		return false;
		###
	*
***
PriorityChangeEffect:
	ChangePriority:
		Header: int changePriority(Battle b, ActivePokemon user, Integer priority)
		Body:
		if ({0})
		{
			if (this instanceof ConsumableItem)
			{
				user.consumeItem(b);
			}
			
			priority++;
		}
		
		return priority;
		###
	*
***
IncenseItem:
	Baby:
		Header: Namesies getBaby()
		Body:
		return Namesies.{00}_POKEMON;
		###
	*
***