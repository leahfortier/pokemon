Override:
	FixedDamage:
		AddMapField: ApplyDamage:
		o.reduceHealth(b, {0});
		###
	*
***
Override:
	GetPriority:
		Header: int getPriority(Battle b, ActivePokemon me)
	*
***
Override:
	GetType:
		Header: Type setType(Battle b, ActivePokemon user)
	*
***
Override:
	Applies:
		Header: boolean applies(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
Override:
	ExtraApplies:
		AddMapField: Applies: {0}
	*
***
RecoilMove:
	Recoil:
		Header: void applyRecoil(Battle b, ActivePokemon user, int damage)
	*
***
RecoilPercentageMove:
	RecoilPercentage:
		Header: int getDamagePercentageDenominator()
		Body:
		return {0};
		###
	*
***
Override:
	StatusFang:
		AddMapField: EffChance: 20
		AddMapField: Effect: Flinch
		AddMapField: MoveType: Biting
		AddMapField: ApplyEffects:
		// If the effect is being applied, 50/50 chance to give a status condition vs. flinching
		if (RandomUtils.chanceTest(50)) {
			Status.giveStatus(b, user, victim, StatusCondition.{00});
			return;
		}
		
		super.applyEffects(b, user, victim);
		###
	*
***
Override:
	WeatherHeal:
		AddInterface: SelfHealingMove
		AddMapField: SelfHealing: 
		switch (b.getWeather().namesies()) {
			case CLEAR_SKIES:
				victim.healHealthFraction(1/2.0);
				break;
			case SUNNY:
				victim.healHealthFraction(2/3.0);
				break;
			case HAILING:
			case RAINING:
			case SANDSTORM:
				victim.healHealthFraction(1/4.0);
				break;
			default:
				Global.error("Funky weather problems!!!!");
				break;
		}
		###
	*
***
SelfHealingMove:
	SelfHealing:
		Header: void heal(ActivePokemon user, ActivePokemon victim, Battle b)
		AddMapField: Applies: !user.fullHealth() && !user.hasEffect(EffectNamesies.HEAL_BLOCK)
		End:
		
		Messages.add(new MessageUpdate(victim.getName() + "'s health was restored!").updatePokemon(b, victim));
		###
		Try:
		victim.healHealthFraction(1/{0}.0);
		###
		AddMapField: SelfTarget: True
		AddMapField: MoveType: Healing
	*
***
MultiTurnMove:
	ChargeFirst:
		Header: boolean chargesFirst()
		Body: 
		return {0};
		###
	*
	SemiInv:
		Header: boolean semiInvulnerability()
		Body:
		return {0};
		###
	*
	Charge:
		Header: void charge(ActivePokemon user, Battle b)
		Optional: True
		Begin:
		Messages.add(new MessageUpdate(getChargeMessage(user)));
		###
	*
	ChargeMessage:
		Header: String getChargeMessage(ActivePokemon user)
		AccessModifier: Private
		Body:
		return {0};
		###
		AddMapField: MoveType: Sleep_Talk_Fail
	*
***
Override:
	IsMultiTurn:
		Header: boolean isMultiTurn(Battle b, ActivePokemon user)
	*
***
Override:
	MultiStrike:
		AddInterface: MultiStrikeMove
		AddMapField: GetMinHits: {1}
		AddMapField: GetMaxHits: {2}
		AddMapField: ApplyDamage:
		int hits = this.getNumHits(me);
		
		int hit = 1;
		for (; hit <= hits; hit++) {
			Messages.add(new MessageUpdate("Hit " + hit + "!"));
			super.applyDamage(me, o, b);
			
			// Stop attacking the dead
			if (o.isFainted(b)) {
				break;
			}
		}
		
		hit--;
		
		// Print hits and gtfo
		Messages.add(new MessageUpdate("Hit " + hit + " time" + (hit == 1 ? "" : "s") + "!"));
		###
	*
***
MultiStrikeMove:
	GetMinHits:
		Header: int getMinHits()
		Body: return {0};
	*
	GetMaxHits:
		Header: int getMaxHits()
		Body: return {0};
	*
***
ChangeTypeSource:
	ChangeType:
		Header: Type[] getType(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
***
Override:
	RemoveType:
		AddInterface: ChangeTypeSource
		AddMapField: ChangeType: 
		Type[] type = victim.getType(b);
				
		// TODO: Rewrite this because it looks stupid
		if (type[0] == Type.{00}) {
			return new Type[] { type[1], Type.NO_TYPE };
		}

		if (type[1] == Type.{00}) {
			return new Type[] { type[0], Type.NO_TYPE };
		}

		return null;
		###
	*
***
Override:
	StartTurn:
		Header: void startTurn(Battle b, ActivePokemon me)
	*
***
Override:
	SwitchItems:
		AddMapField: ApplyEffects:
		if ({0}) {
			if (super.category == MoveCategory.STATUS) {
				Messages.add(new MessageUpdate(Effect.DEFAULT_FAIL_MESSAGE));
			}
			
			return;
		}

		Item userItem = user.getHeldItem(b), victimItem = victim.getHeldItem(b);
		Messages.add(new MessageUpdate(getSwitchMessage(user, userItem, victim, victimItem)));

		if (b.isWildBattle()) {
			user.giveItem((HoldItem)victimItem);
			victim.giveItem((HoldItem)userItem);
			return;
		}

		item = userItem;
		super.applyEffects(b, user, victim);
		
		item = victimItem;
		super.applyEffects(b, user, user);
		###
		AddMapField: Effect: ChangeItem
		AddInterface: ItemHolder
		AddMapField: Field:
		private Item item;
		###
		AddMapField: GetItem:
		return item;
		###
		AddMapField: MoveType: Metronomeless, No_Magic_Coat
	*
***
Override:
	SwitchItemMessage:
		Header: String getSwitchMessage(ActivePokemon user, Item userItem, ActivePokemon victim, Item victimItem)
		AccessModifier: Private
		Body:
		return {0};
		###
	*
***
Override:
	BattleEffect:
		AddMapField: Effect: {0}
		AddMapField: MoveType: No_Magic_Coat, Field
	*
***
Override:
	ProtectingAttack:
		AddMapField: Effect: {0}
		AddMapField: Priority: 4
		AddMapField: SelfTarget: True
		AddMapField: MoveType: Successive_Decay, Assistless, Metronomeless, Non_Snatchable
	*
***
Override:
	OHKO:
		AddMapField: Applies: user.getLevel() >= victim.getLevel()
		AddMapField: ApplyDamage:
		// Certain death
		o.reduceHealth(b, o.getHP());
		Messages.add(new MessageUpdate("It's a One-Hit KO!"));
		###
		AddMapField: MoveType: One_Hit_KO
		AddMapField: GetAccuracy:
		return super.accuracy + (me.getLevel() - o.getLevel());
		###
	*
***
StatSwitchingEffect:
	SwitchStat:
		Header: Stat switchStat(Stat s)
	*
***
OpponentStatSwitchingEffect:
	OppSwitchStat:
		Header: Stat switchStat(Stat s)
	*
***
CrashDamageMove:
	CrashDamage:
		Header: void crash(Battle b, ActivePokemon user)
		Body:
		Messages.add(new MessageUpdate(user.getName() + " kept going and crashed!"));
		user.reduceHealth(b, user.getMaxHP()/{0});
		###
	*
***
Override:
	StatSplit:
		AddInterface: StatChangingEffect
		AddMapField: ChangeStat:
		
		// If the stat is a splitting stat, return the average between the user and the opponent
		if (s == Stat.{11} || s == Stat.{22}) {
			return (p.getStat(b, s) + opp.getStat(b, s))/2;
		}
		
		return stat;
		###
	*
***
StageChangingEffect:
	StageChange:
		Header: int adjustStage(Battle b,  ActivePokemon p, ActivePokemon opp, Stat s)
	*
***
OpponentIgnoreStageEffect:
	IgnoreStage: 
		Header: boolean ignoreStage(Stat s)
	*
***
Override:
	StatusCureMove:
		AddMapField: GetPow: 
		return super.power*(o.hasStatus(StatusCondition.{00}) ? 2 : 1);
		###
		AddMapField: ApplyEffects:
		if (victim.hasStatus(StatusCondition.{00})) {
			Status.removeStatus(b, victim, CastSource.ATTACK);
		}
		###
	*
***
Override:
	StormyMove:
		AddMapField: GetAccuracy:
		// Accuracy is only 50% when sunny
		if (b.getWeather().namesies() == EffectNamesies.SUNNY) {
			return 50;
		}
		
		return super.accuracy;
		###
		AddMapField: BypassAccuracy:
		// Always hits when the opponent is flying or it is raining (unless they're non-flying semi-invulnerable)
		return defending.isSemiInvulnerableFlying() || (b.getWeather().namesies() == EffectNamesies.RAINING && defending.isSemiInvulnerable());
		###
		AddMapField: HitFly: True
	*
***
Override:
	HitFly:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		// Always hit when the opponent is flying
		return defending.isSemiInvulnerableFlying();
		###
		AddMapField: GetPow:
		// Twice as strong when the opponent is flying
		return super.power*(o.isSemiInvulnerableFlying() ? 2 : 1);
		###
	*
***
Override:
	HitDig:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		// Always hit when the opponent is underground
		return defending.isSemiInvulnerableDigging();
		###
		AddMapField: GetPow:
		int power = {0};
		
		// Power is halved during Grassy Terrain
		if (b.hasEffect(EffectNamesies.GRASSY_TERRAIN)) {
			power *= .5;
		}
		
		// Power is double when the opponent is underground
		if (o.isSemiInvulnerableDigging()) {
			power *= 2;
		}
		
		return power;
		###
	*
***
Override:
	HPRatioMove:
		AddMapField: GetPow:
		return (int)Math.min(1, ({1}*{2}.getHPRatio()));
		###
	*
***
Override:
	Flailing:
		AddMapField: GetPow: 
		double ratio = me.getHPRatio();
		if (ratio > .7) return 20;
		if (ratio > .35) return 40;
		if (ratio > .2) return 80;
		if (ratio > .1) return 100;
		if (ratio > .04) return 150;
		return 200;
		###
	*
***
Override:
	LightClay:
		AddMapField: Cast: 
		super.cast(b, caster, victim, source, printCast);
		if (caster.isHoldingItem(b, ItemNamesies.LIGHT_CLAY)) {
			Effect.getEffect(b.getEffects(victim.isPlayer()), this.namesies).setTurns(8);
		}
		###
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
	*
***
BarrierEffect:
	Barrier:
		AddInterface: Hidden-DefogRelease
		AddMapField: LightClay: True
		AddMapField: ToModify: {1}
		AddMapField: ModifyMultiplier: 2 !opp.hasAbility(AbilityNamesies.INFILTRATOR)
		AddMapField: CastMessage: user.getName() + " raised the " + Stat.{11}.getName().toLowerCase() + " of its team!"
		AddMapField: SubsideMessage: "The effects of {2-} faded."
		AddMapField: Defog: "The effects of {2-} faded."
		AddMapField: BreakBarrier: {2-}
	*
	BreakBarrier:
		Header: void breakBarrier(Battle b, ActivePokemon breaker)
		Body:
		Messages.add(new MessageUpdate(breaker.getName() + " broke the {0} barrier!"));
		b.getEffects(!breaker.isPlayer()).remove(this);
		###
	*
***
Override:
	SpecificAbilityChange:
		AddInterface: ChangeAbilityMove
		AddMapField: Applies: victim.getAbility().isReplaceable()
		AddMapField: Effect: ChangeAbility
		AddMapField: AbilityChange:
		return AbilityNamesies.{00}.getNewAbility();
		###
		AddMapField: AbilityMessage: 
		return victim.getName() + "'s ability was changed to " + AbilityNamesies.{00}.getName() + "!";
		###
	*
***
Override:
	HitMinimize:
		AddInterface: AccuracyBypassEffect
		AddMapField: BypassAccuracy:
		return !defending.isSemiInvulnerable() && defending.hasEffect(EffectNamesies.USED_MINIMIZE);
		###
		AddMapField: GetPow:
		return super.power*(o.hasEffect(EffectNamesies.USED_MINIMIZE) ? 2 : 1);
		###
	*
***
AccuracyBypassEffect:
	BypassAccuracy:
		Header: boolean bypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
	*
***
OpponentAccuracyBypassEffect:
	OpponentBypassAccuracy:
		Header: boolean opponentBypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
	*
***
ChangeAbilityMove:
	AbilityChange:
		Header: Ability getAbility(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
	AbilityMessage:
		Header: String getMessage(Battle b, ActivePokemon caster, ActivePokemon victim)
	*
***
Override:
	MirrorMove:
		AddMapField: MoveType: Sleep_Talk_Fail, Encoreless, Metronomeless, Assistless, No_Magic_Coat, Mirrorless
		AddMapField: Applies: victim.getAttributes().getLastMoveUsed() != null && !victim.getAttributes().getLastMoveUsed().getAttack().isMoveType(MoveType.MIRRORLESS)
		AddMapField: Apply: 
		// TODO: Test
		Move mirror = o.getAttributes().getLastMoveUsed();
		me.callNewMove(b, o, new Move(mirror.getAttack()));
		###
	*
***
Override:
	Countering:
		AddMapField: Priority: -5
		AddMapField: MoveType: Assistless, Metronomeless
		AddMapField: PP: 20
		AddMapField: Acc: 100
		AddMapField: ApplyDamage:
		int damageTaken = me.getAttributes().getDamageTaken();
		
		// Fails if no damage to reflect or if the opponent isn't using an attack of the proper category
		if (damageTaken == 0 || o.getMove() == null || o.getAttack().getCategory() != MoveCategory.{00} || b.isFirstAttack()) {
			Messages.add(new MessageUpdate(Effect.DEFAULT_FAIL_MESSAGE));
			return;
		}
		
		o.reduceHealth(b, damageTaken*2);
		###
	*
***
Override:
	ExitBattle:
		AddMapField: MoveType: Assistless
		AddMapField: Priority: -6
		AddMapField: ApplyEffects:
		// Fails against the Suction Cups ability
		if (victim.hasAbility(AbilityNamesies.SUCTION_CUPS) && !user.breaksTheMold()) {
			Messages.add(new MessageUpdate(victim.getName() + "'s " + AbilityNamesies.SUCTION_CUPS.getName() + " prevents it from switching!"));
			return;
		}
		
		// Fails if this is the first attack of the turn, or if the victim is rooted by Ingrain
		if (b.isFirstAttack() || victim.hasEffect(EffectNamesies.INGRAIN)) {
			if (super.category == MoveCategory.STATUS)  {
				Messages.add(new MessageUpdate(Effect.DEFAULT_FAIL_MESSAGE));
			}
			
			return;
		}
		
		Team opponent = b.getTrainer(victim.isPlayer());
		if (opponent instanceof WildPokemon) {
			// Fails against wild Pokemon of higher levels
			if (victim.getLevel() > user.getLevel()) {
				Messages.add(new MessageUpdate(Effect.DEFAULT_FAIL_MESSAGE));
				return;
			}
			
			// End the battle against a wild Pokemon
			Messages.add(new MessageUpdate({0}));
			Messages.add(new MessageUpdate().withUpdate(Update.EXIT_BATTLE));
			return;
		}
		
		Trainer trainer = (Trainer)opponent;
		if (!trainer.hasRemainingPokemon()) {
			// Fails against trainers on their last Pokemon
			if (super.category == MoveCategory.STATUS) {
				Messages.add(new MessageUpdate(Effect.DEFAULT_FAIL_MESSAGE));
			}
			
			return;
		}
		
		// Swap to a random Pokemon!
		Messages.add(new MessageUpdate({0}));
		trainer.switchToRandom();
		victim = trainer.front();
		b.enterBattle(victim, "...and " + victim.getName() + " was dragged out!");
		###
	*
***
Override:
	SelfSwitching:
		AddMapField: Apply:
		// First execute the move as normal
		super.apply(me, o, b);
		
		me.switcheroo(b, me, CastSource.ATTACK, true);
		###
	*
***
EndTurnEffect:
	ApplyEndTurn:
		Header: void applyEndTurn(ActivePokemon victim, Battle b)
	*
***
BeforeTurnEffect:
	CanAttack:
		Header: boolean canAttack(ActivePokemon p, ActivePokemon opp, Battle b)
		Optional: True
	*
***
OpponentBeforeTurnEffect:
	OpponentCanAttack:
		Header: boolean opposingCanAttack(ActivePokemon p, ActivePokemon opp, Battle b)
		Optional: True
	*
***
Override:
	ProtectingEffect:
		AddInterface: OpponentBeforeTurnEffect
		AddMapField: MinTurns: 1
		AddMapField: MaxTurns: 1
		AddMapField: CastMessage: victim.getName() + " protected itself!"
		AddMapField: SuccessiveDecay: True
		AddMapField: OnProtectingSuccess:
		// No additional effects
		###
		AddMapField: ProtectingCondition: true
		AddMapField: OpponentCanAttack:
		// Self-target moves, moves that penetrate Protect, and other conditions
		if (p.getAttack().isSelfTarget() || p.getAttack().isMoveType(MoveType.FIELD) || p.getAttack().isMoveType(MoveType.PROTECT_PIERCING) || !protectingCondition(b, p)) {
			return true;
		}
		
		// Protect is a success!
		b.printAttacking(p);
		Messages.add(new MessageUpdate(opp.getName() + " is protecting itself!"));
		CrashDamageMove.invokeCrashDamageMove(b, p);
	
		// Additional Effects
		protectingEffects(p, opp, b);

		return false;
		###
	*
***
Override:
	ProtectingCondition:
		Header: boolean protectingCondition(Battle b, ActivePokemon attacking)
		Body:
		return {0};
		###
	*
***
Override:
	OnProtectingSuccess:
		Header: void protectingEffects(ActivePokemon p, ActivePokemon opp, Battle b)
	*
***
Override: 
	SuccessiveDecay:
		AddMapField: Cast:
		if (!RandomUtils.chanceTest((int)(100*caster.getAttributes().getSuccessionDecayRate()))) {
			Messages.add(new MessageUpdate(this.getFailMessage(b, caster, victim)));
			return;
		}

		super.cast(b, caster, victim, source, printCast);
		###
	*
***
TrappingEffect:
	Trapped:
		Header: boolean isTrapped(Battle b, ActivePokemon escaper)
		Optional: True
		Default:
		// Ghost-type Pokemon can always escape
		return !escaper.isType(b, Type.GHOST);
		###
	*
	TrappingMessage:
		Header: String trappingMessage(ActivePokemon trapped)
		Body:
		return {0};
		###
	*
***
OpponentTrappingEffect:
	OppTrapped: 
		Header: boolean trapOpponent(Battle b, ActivePokemon escaper, ActivePokemon trapper)
	*
	OppTrappingMessage:
		Header: String opponentTrappingMessage(ActivePokemon escaper, ActivePokemon trapper)
		Optional: True
		Default:
		return trapper.getName() + "'s " + this.getName() + " prevents " + escaper.getName() + " from escaping!";
		###
	*
***
Override:
	PartialTrap:
		AddMapField: Cast:
		super.cast(b, caster, victim, source, printCast);
		if (caster.isHoldingItem(b, ItemNamesies.GRIP_CLAW)) setTurns(5);
		###
		AddInterface: EndTurnEffect
		AddInterface: TrappingEffect
		AddInterface: RapidSpinRelease
		AddMapField: MinTurns: 4
		AddMapField: MaxTurns: 5
		AddMapField: NextTurnSubside: True
		AddMapField: CastMessage: {2-}
		AddMapField: SubsideMessage: victim.getName() + " is no longer trapped by {1_}."
		AddMapField: RapidSpin: releaser.getName() + " was released from {1_}!"
		AddMapField: TrappingMessage: trapped.getName() + " cannot be recalled due to {1_}!"
		AddMapField: ApplyEndTurn:
		if (victim.hasAbility(AbilityNamesies.MAGIC_GUARD)) {
			return;
		}
		
		Messages.add(new MessageUpdate(victim.getName() + " is hurt by {1_}!"));
		
		// Reduce 1/8 of the victim's total health, or 1/6 if holding a binding band
		victim.reduceHealthFraction(b, b.getOtherPokemon(victim.isPlayer()).isHoldingItem(b, ItemNamesies.BINDING_BAND) ? 1/6.0 : 1/8.0);
		###
	*
***
Override:
	SafeguardEffect:
		AddMapField: CastMessage: user.getName() + " is covered by a veil!"
		AddMapField: SubsideMessage: "The effects of " + victim.getName() + "'s {0} faded."
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
		AddInterface: StatusPreventionEffect
		AddMapField: StatusPrevent: 
		return !caster.hasAbility(AbilityNamesies.INFILTRATOR);
		###
		AddMapField: StatusPreventMessage: "{0} protects " + victim.getName() + " from status conditions!"
	*
***
Override:
	UsedProof:
		AddMapField: CanHave: True
		AddMapField: Cast: 
		if (!victim.hasEffect(this.namesies)) {
			super.cast(b, caster, victim, source, printCast);
		}
		else {
			Messages.add(new MessageUpdate(getCastMessage(b, caster, victim)));
		}
		###
	*
***
Override:
	Cast:
		Header: void cast(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source, boolean printCast)
	*
***
Override:
	CastMessage:
		Header: String getCastMessage(Battle b, ActivePokemon user, ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
Override:
	SubsideMessage:
		Header: String getSubsideMessage(ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
Override:
	WeightBased:
		AddMapField: GetPow: 
		double weight = {0}.getWeight(b);
		if (weight < 22) return 20;
		if (weight < 55) return 40;
		if (weight < 110) return 60;
		if (weight < 220) return 80;
		if (weight < 440) return 100;
		return 120;
		###
	*
***
Override:
	WeightRatio:
		AddMapField: GetPow: 
		double ratio = {1}.getWeight(b)/{2}.getWeight(b);
		if (ratio > .5) return 40;
		if (ratio > .33) return 60;
		if (ratio > .25) return 80;
		if (ratio > .2) return 100;
		return 120;
		###
	*
***
Override:
	StatRatio:
		AddMapField: GetPow: 
		double ratio = (double)Stat.getStat(Stat.{11}, {2}, {3}, b)/Stat.getStat(Stat.{11}, {3}, {2}, b);
		if (ratio > .5) return 60;
		if (ratio > .33) return 80;
		if (ratio > .25) return 120;
		return 150;
		###
	*
***
RapidSpinRelease:
	RapidSpin:
		Header: void releaseRapidSpin(Battle b, ActivePokemon releaser)
		Body:
		Messages.add(new MessageUpdate({0}));
		
		// This is a little hacky and I'm not a super fan but I don't feel like distinguishing in the generator if this a PokemonEffect or a TeamEffect, so just try to remove from both list
		releaser.getEffects().remove(this);
		b.getEffects(releaser.isPlayer()).remove(this);
		###
	*
***
StatChangingEffect:
	ChangeStat:
		Header: int modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s, int stat)
	*
***
StatModifyingEffect:
	ModifyStat:
		Header: double modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s)
	*
***
SimpleStatModifyingEffect
***
Override:
	ModifyMultiplier:
		Header: double getModifier()
		Body:
		return {1};
		###
		AddInterface: SimpleStatModifyingEffect
		AddMapField: CanModify: {2-}
	*
***
Override:
	CanModify:
		Header: boolean canModifyStat(Battle b, ActivePokemon p, ActivePokemon opp)
		Body:
		return {0};
		###
	*
***
Override:
	TwoModify:
		Header: boolean isModifyStat(Stat s)
		Body:
		return s == Stat.{11} || s == Stat.{22};
		###
	*
***
Override:
	ToModify:
		Header: boolean isModifyStat(Stat s)
		Body:
		return s == Stat.{00};
		###
	*
***
ForceMoveEffect:
	GetForceMove:
		Header: Move getForcedMove()
	*
***
Override:
	Subside:
		Header: void subside(Battle b, ActivePokemon p)
	*
***
AttackSelectionEffect:
	Usable:
		Header: boolean usable(Battle b, ActivePokemon p, Move m)
	*
	UnusableMessage:
		Header: String getUnusableMessage(Battle b, ActivePokemon p)
		Body: 
		return {0};
		###
	*
***
OpponentAttackSelectionEffect:
	OpponentUsable:
		Optional: True
		AddInterface: Hidden-AttackSelectionEffect
	*
***
Override:
	ShouldSubside:
		Header: boolean shouldSubside(Battle b, ActivePokemon victim)
	*
***
Override:
	DoublePowerCondition:
		AddMapField: GetPow: 
		return super.power*({0} ? 2 : 1);
		###
	*
***
EntryEffect:
	Enter:
		Header: void enter(Battle b, ActivePokemon enterer)
	*
***
ChangeTypeEffect:
	GetChangeTypeEffect:	
		Header: Type[] getType(Battle b, ActivePokemon p, boolean display)
	*
***
NameChanger:
	GetNameChange:
		Header: String getNameChange()
	*
	SetNameChange:
		Header: void setNameChange(Battle b, ActivePokemon victim)
	*
***
Override:
	AbilityIsActive:
		Header: boolean isActive()
	*
***
Override:
	EffectIsActive:
		Header: boolean isActive(Battle b)
	*
***
Override:
	Deactivate:
		Header: void deactivate(Battle b, ActivePokemon victim)
	*
***
Override:
	GetTurns:
		Header: int getTurns()
	*
***
StatusPreventionEffect:
	StatusPrevent:
		Header: boolean preventStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusCondition status)
	*
	StatusPreventMessage:
		Header: String statusPreventionMessage(ActivePokemon victim)
		Body:
		return {0};
		###
	*
***
PowerChangeEffect:
	GetMultiplier:
		Header: double getMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
OpponentPowerChangeEffect:
	GetOppMultiplier:
		Header: double getOpponentMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
EffectBlockerEffect:
	ValidMove:
		Header: boolean validMove(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
StatProtectingEffect:
	StatProtect:
		Header: boolean prevent(Battle b, ActivePokemon caster, ActivePokemon victim, Stat stat)
	*
	StatProtectMessage:
		Header: String preventionMessage(ActivePokemon p, Stat s)
		Optional: True
		Default:
		return p.getName() + "'s " + this.getName() + " prevents its " + s.getName().toLowerCase() + " from being lowered!";
		###
	*
***
Override:
	Sporty:
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier: 
		return user.getAttackType() == Type.{11} ? .33 : 1;
		###
		AddMapField: CastMessage: "{2}'s power was weakened!"
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
		AddMapField: SubsideMessage: "The effects of {3} Sport wore off."
	*
***
Override:
	SpecialRoom:
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
		AddMapField: SubsideMessage: "The dimensions of the {1} room returned to normal."
		AddMapField: CastMessage: user.getName() + " twisted the dimensions to {2-}!"
		AddMapField: CanHave: True
		AddMapField: Cast: 
		Effect roomsies = Effect.getEffect(b.getEffects(), this.namesies);
		if (roomsies == null) {
			super.cast(b, caster, victim, source, printCast);
			return;
		}
	
		// Remove the effect if it's already in play
		Messages.add(new MessageUpdate(roomsies.getSubsideMessage(caster)));
		Effect.removeEffect(b.getEffects(), this.namesies);
		###
	*
***
Override:
	MoveTypePrevent:
		AddInterface: OpponentBeforeTurnEffect
		AddMapField: OpponentCanAttack:
		if (p.getAttack().isMoveType(MoveType.{00})) {
			b.printAttacking(p);
			Messages.add(new MessageUpdate(opp.getName() + "'s " + this.getName() + " prevents " + p.getAttack().getName() + " from being used!"));
			return false;
		}
		
		return true;
		###
	*
***
Override:
	DeathWish:
		Header: void deathWish(Battle b, ActivePokemon dead, ActivePokemon murderer)
		AccessModifier: Private
		AddInterface: StatusReceivedEffect
		AddMapField: StatusReceived:
		if (statusType == StatusCondition.FAINTED) {
			ActivePokemon murderer = b.getOtherPokemon(victim);
			
			// Only grant death wish if murdered through direct damage
			if (murderer.getAttributes().isAttacking()) {
				// DEATH WISH GRANTED
				deathWish(b, victim, murderer);
			}
		}
		###
	*
***
MurderEffect:
	KillWish:
		Header: void killWish(Battle b, ActivePokemon dead, ActivePokemon murderer)
	*
***
PassableEffect:
***
Override:
	FailMessage:
		Header: String getFailMessage(Battle b, ActivePokemon user, ActivePokemon victim)
		End:
		
		return super.getFailMessage(b, user, victim);
		###
	*
***
DefogRelease:
	Defog:
		Header: void releaseDefog(Battle b, ActivePokemon victim)
		Body:
		Messages.add(new MessageUpdate({0}));
		
		// This is a little hacky and I'm not a super fan but I don't feel like distinguishing in the generator if this a PokemonEffect or a TeamEffect, so just try to remove from both lists
		victim.getEffects().remove(this);
		b.getEffects(victim.isPlayer()).remove(this);
		###
	*
***
AbilityHolder:
	GetAbility:
		Header: Ability getAbility()
	*
***
ItemHolder:
	GetItem:
		Header: Item getItem()
	*
***
BracingEffect:
	Bracing:
		Header: boolean isBracing(Battle b, ActivePokemon bracer, boolean fullHealth)
	*
	BraceMessage:
		Header: String braceMessage(ActivePokemon bracer)
		Body:
		return {0};
		###
	*
***
ChangeMoveListEffect:
	GetMoveList:
		Header: List<Move> getMoveList(List<Move> actualMoves)
	*
***
DifferentStatEffect:
	GetStat:
		Header: Integer getStat(ActivePokemon user, Stat stat)
	*
***
CritStageEffect:
	IncreaseCritStage:
		Header: int increaseCritStage(int stage, ActivePokemon p)
		Optional: True
		Default:
		return stage + 1;
		###
	*
***
LevitationEffect:
	FallMessage:
		Header: void fall(Battle b, ActivePokemon fallen)
		Body:
		Messages.add(new MessageUpdate({0}));
		
		// TODO: Fix this it's broken
		// Effect.removeEffect(fallen.getEffects(), this.namesies());
		###
	*
***
GroundedEffect:
	RemoveLevitation:
		Header: void removeLevitation(Battle b, ActivePokemon p)
		AccessModifier: Private
		Optional: True
		Default:
		if (p.isSemiInvulnerableFlying()) {
			p.getMove().switchReady(b, p);
			Messages.add(new MessageUpdate(p.getName() + " fell to the ground!"));
		}
		
		LevitationEffect.falllllllll(b, p);
		###
		AddInterface: BeforeTurnEffect
		AddMapField: CanAttack:
		if (p.getAttack().isMoveType(MoveType.AIRBORNE)) {
			b.printAttacking(p);
			Messages.add(new MessageUpdate(Effect.DEFAULT_FAIL_MESSAGE));
			return false;
		}
		
		return true;
		###
	*
***
TerrainEffect:
	Terrain:
		AddMapField: Cast:
		// Remove all other Terrain Effects
		for (int i = 0; i < b.getEffects().size(); i++) {
			Effect effect = b.getEffects().get(i);
			if (effect instanceof TerrainEffect) {
				b.getEffects().remove(i);
				i--;
			}
		}
		
		super.cast(b, caster, victim, source, printCast);
		b.setTerrainType(TerrainType.{00}, false); // TODO: Need to send a terrain change message
		###
		AddMapField: Subside:
		super.subside(b, p);
		b.resetTerrain();
		###
		AddMapField: MinTurns: 5
		AddMapField: MaxTurns: 5
	*
***
EndBattleEffect:
	EndBattle:
		Header: void afterBattle(Trainer player, Battle b, ActivePokemon p)
	*
***
PhysicalContactEffect:
	Contact:
		Header: void contact(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
TypeBlocker:
	Block:
		Header: boolean block(Type attackType, ActivePokemon victim)
	*
	AlternateEffect:
		Header: void alternateEffect(Battle b, ActivePokemon victim)
	*
***
AttackBlocker:
	AttackBlock:
		Header: boolean block(AttackNamesies attackName, ActivePokemon victim)
	*
	AttackAlternateEffect:
		Header: void alternateEffect(Battle b, ActivePokemon victim)
	*
***
Override:
	BlockType:
		AddInterface: TypeBlocker
		AddMapField: Block:
		return attackType == Type.{00};
		###
		AddMapField: AlternateEffect:
		Messages.add(new MessageUpdate(victim.getName() + "'s " + this.getName() + " makes it immune to " + Type.{00}.getName() + " type moves!"));
		victim.getAttributes().modifyStage(victim, victim, 1, toIncrease(), b, CastSource.ABILITY);
		###
	*
***
Override:
	AbsorbType:
		AddInterface: TypeBlocker
		AddMapField: Block:
		return attackType == Type.{00};
		###
		AddMapField: AlternateEffect:
		Messages.add(new MessageUpdate(victim.getName() + "'s " + this.getName() + " makes it immune to " + Type.{00}.getName() + " moves!"));
		
		// Technically, according to the description, Heal Block prevents the prevention entirely (meaning this should be in Block), but that makes no sense, they shouldn't take damage, this way makes more sense
		if (victim.fullHealth() || victim.hasEffect(EffectNamesies.HEAL_BLOCK)) {
			return;
		}
		
		victim.healHealthFraction(1/4.0);
		Messages.add(new MessageUpdate(victim.getName() + "'s HP was restored instead!").updatePokemon(b, victim));
		###
	*
***
Override:
	EndTurnStatusCure:
		AddInterface: EndTurnEffect
		AddMapField: ApplyEndTurn: 
		if (victim.hasStatus() && {0}) {
			Status.removeStatus(b, victim, CastSource.ABILITY);
		}
		###
	*
***
Override:
	PinchAbility:
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier: 
		return user.getHPRatio() < 1/3.0 && user.getAttackType() == Type.{00} ? 1.5 : 1;
		###
	*
***
Override:
	StatusPreventAbility:
		AddInterface: StatusPreventionEffect
		AddMapField: StatusPrevent: 
		return status == StatusCondition.{11};
		###
		AddMapField: StatusPreventMessage: victim.getName() + "'s " + this.getName() + " prevents {2}!"
	*
***
Override:
	StatusContact:
		AddMapField: Contact: 
		if (RandomUtils.chanceTest(30)) {
			Status.giveStatus(b, victim, user, StatusCondition.{00}, true);
		}
		###
		AddInterface: PhysicalContactEffect
	*
***
Override:
	SpeedWeather:
		AddMapField: ToModify: Speed
		AddMapField: ModifyMultiplier: 2 b.getWeather().namesies() == EffectNamesies.{00}
	*
***
Override:
	WeatherStarter:
		AddInterface: EntryEffect
		AddMapField: Enter: 
		b.addEffect((Weather)EffectNamesies.{11}.getEffect());
		Messages.add(new MessageUpdate(enterer.getName() + "'s " + this.getName() + " {2-}!"));
		###
	*
***
Override:
	WeatherEvasion:
		AddInterface: StageChangingEffect
		AddMapField: StageChange: 
		return s == Stat.EVASION && b.getWeather().namesies() == EffectNamesies.{00} ? 1 : 0;
		###
	*
***
Override:
	WeatherEliminate:
		AddInterface: EntryEffect
		AddMapField: Enter: 
		// TODO: I think this isn't the intended effect of this ability
		b.addEffect((Weather)EffectNamesies.CLEAR_SKIES.getEffect());
		Messages.add(new MessageUpdate(enterer.getName() + "'s " + this.getName() + " eliminated the weather!"));
		###
	*
***
HalfWeightEffect:
	HalfAmount:
		Header: int getHalfAmount(int halfAmount)
		Body:
		return halfAmount + {0};
		###
	*
***
WeatherBlockerEffect:
	WeatherBlock:
		Header: boolean block(EffectNamesies weather)
	*
***
ApplyDamageEffect:
	OnApplyDamage:
		Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, int damage)
	*
***
ModifyStageValueEffect:
	ModifyStageValue:
		Header: int modifyStageValue(int modVal)
	*
***
SwitchOutEffect:
	SwitchOut:
		Header: void switchOut(ActivePokemon switchee)
	*
***
TakeDamageEffect:
	OnTakeDamage:
		Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
StallingEffect:
***
DefiniteEscape:
***
HoldItem:
	Fling:
		Header: int flingDamage()
		Body:
		return {0};
		###
	*
	FlingEffect:
		Header: void flingEffect(Battle b, ActivePokemon pelted)
		Optional: True
	*
***
TrainerUseItem:
	TrainerUse:
		Header: boolean use(Trainer t)
	*
***
PokemonUseItem:
	PokemonUse:
		Header: boolean use(ActivePokemon p)
	*
***
BattleUseItem:
	BattleUse:
		Header: boolean use(ActivePokemon p, Battle b)
	*
***
MoveUseItem:
	MoveUse:
		Header: boolean use(ActivePokemon p, Move m)
	*
***
Override:
	IncreaseStat:
		Header: Stat toIncrease()
		AccessModifier: Private
		Body:
		return Stat.{00};
		###
	*
***
Override:
	TypeTakeDamageStatIncrease:
		AddMapField: OnTakeDamage:
		if (user.getAttackType() == Type.{11} && victim.getAttributes().modifyStage(victim, victim, 1, Stat.{22}, b, CastSource.HELD_ITEM)) {
			victim.consumeItem(b);
		}
		###
		AddInterface: ConsumableItem
		AddInterface: TakeDamageEffect
	*
***
ConsumableItem:
	ConsumeItem:
		Optional: True
		AddInterface: Hidden-HoldItem
	*
***
Override:
	ChoiceItem:
		AddMapField: ToModify: {0}
		AddMapField: ModifyMultiplier: 1.5 true
		AddInterface: AttackSelectionEffect
		AddMapField: Usable:
		Move last = p.getAttributes().getLastMoveUsed();
		if (last == null || m == last) {
			return true;
		}
		
		return false;
		###
		AddMapField: UnusableMessage: p.getName() + "'s " + super.name + " only allows " + p.getAttributes().getLastMoveUsed().getAttack().getName() + " to be used!"
		AddInterface: HoldItem
		AddMapField: Fling: 10
	*
***
Override:
	Wing:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddMapField: EVIncreaseAmt: 1
		AddMapField: Price: 3000
		AddMapField: Fling: 20
		AddInterface: HoldItem
		AddMapField: Cat: Stat
	*
***
Override:	
	Vitamin:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
		AddMapField: EVIncreaseAmt: 10
		AddMapField: Price: 9800
		AddMapField: Fling: 30
		AddInterface: HoldItem
		AddMapField: Cat: Stat
	*
***
RepellingEffect:
	RepelChance:
		Header: double chance()
		Body:
		return {0};
		###
	*
***
Override:
	BuffetImmune:
		AddMapField: Field:
		private static final Type[] immunees = new Type[] { {0} };
		###
	*
***
Override:
	BuffetMessage:
		AddMapField: Field:
		private void buffet(Battle b, ActivePokemon p) {
			// Don't buffet the immune!
			for (Type type : immunees) {
				if (p.isType(b, type)) {
					return;
				}
			}
			
			// Srsly don't buffet the immune!!
			if (WeatherBlockerEffect.checkBlocked(b, p, this.namesies)) {
				return;
			}

			// Buffety buffety buffet
			Messages.add(new MessageUpdate({0}));
			p.reduceHealthFraction(b, 1/16.0);
		}
		###
	*
***
Override:
	PreBuffetMessage:
		AddInterface: Hidden-EndTurnEffect
		AddMapField: ApplyEndTurn:
		Messages.add(new MessageUpdate({0}));
				
		ActivePokemon other = b.getOtherPokemon(victim.isPlayer());
		buffet(b, victim);
		buffet(b, other);
		###
	*
***
Override:
	WeatherStatChange:
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.isAttackType(Type.{11})) {
			// {1} is fiddy percent stronger in tha weathz
			return 1.5;
		}
		else if (user.isAttackType(Type.{22})) {
			// {2} is fiddy percent weaker in tha weathz
			return .5;
		}
		else {
			return 1;
		}
		###
	*
***
WeatherExtendingEffect:
	WeatherType:
		Header: EffectNamesies getWeatherType()
		Body:
		return EffectNamesies.{00};
		###
	*
***
EVItem:
	GetEVs:
		Header: int[] getEVs(int[] vals)
		AddInterface: Hidden-HoldItem
	*
***
TargetSwapperEffect:
	TargetSwap:
		Header: boolean swapTarget(Battle b, ActivePokemon user, ActivePokemon opponent)
	*
***
Override:
	MagicReflection:
		AddInterface: TargetSwapperEffect
		AddMapField: TargetSwap:
		Attack attack = user.getAttack();
		if (!attack.isSelfTarget() && attack.isStatusMove() && !attack.isMoveType(MoveType.NO_MAGIC_COAT)) {
			Messages.add(new MessageUpdate(opponent.getName() + "'s " + {0} + " reflected " + user.getName() + "'s move!"));
			return true;
		}
		
		return false;
		###
	*
***
PowerItem:
	PowerStat:
		Header: Stat powerStat()
		Body:
		return Stat.{00};
		###
		AddMapField: ToModify: Speed
		AddMapField: ModifyMultiplier: .5 true
		AddInterface: Hidden-EVItem
		AddMapField: GetEVs:
		vals[powerStat().index()] += 4;
		return vals;
		###
		AddMapField: Fling: 70
		AddMapField: Price: 3000
		AddMapField: Cat: Misc
	*
***
Override:
	TypeEnhance:
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.isAttackType(Type.{00})) {
			return 1.2;
		}

		return 1;
		###
		AddInterface: HoldItem
		AddMapField: Cat: Misc
	*
***
Override:
	PPIncrease:
		AddMapField: Fling: 30
		AddMapField: Field:
		private String increase;
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + increase + "'s Max PP was increased!"
		AddMapField: MoveUse:
		increase = m.getAttack().getName();
		return m.increaseMaxPP({0});
		###
		AddInterface: MoveUseItem
		AddInterface: HoldItem
		AddMapField: Cat: Stat
	*
***
Override:
	Ether:
		AddInterface: MoveUseItem
		AddMapField: BattleCat: HP_PP
		AddMapField: MoveUse:
		// TODO: Need to be able to call these from the battle! (BattleMoveUse? yuck) -- Test messages once completed
		restore = m.getAttack().getName();
		return m.increasePP({0});
		###
		AddMapField: Field: 
		private String restore;
		###
		AddMapField: SuccessMessage: p.getName() + "'s PP for " + restore + " PP was restored!"
	*
***
Override:
	Elixir:
		Header: int increaseAmount(Move m)
		Body:
		return {0};
		###
		AddMapField: Field:
		private boolean use(List<Move> moves)
		{
			boolean changed = false;
			for (Move m : moves)
			{
				changed |= m.increasePP(increaseAmount(m));
			}
			
			return changed;
		}
		###
		AddMapField: BattleUse:
		return use(p.getMoves(b));
		###
		AddMapField: PokemonUse:
		return use(p.getActualMoves());
		###
		AddMapField: SuccessMessage: p.getName() + "'s PP was restored!"
		AddMapField: Fling: 30
		AddInterface: PokemonUseItem
		AddInterface: BattleUseItem
		AddInterface: HoldItem
		AddMapField: Cat: Medicine
		AddMapField: BattleCat: HP_PP
	*
***
Override:
	TimeSpaceOrb:
		Header: boolean canUseOrb(ActivePokemon user)
		Body:
		if (!user.isPokemon(PokemonNamesies.{11})) {
			return false;
		}
		
		return user.isAttackType(Type.DRAGON) || user.isAttackType(Type.{22});
		###
		AddMapField: Fling: 60
		AddMapField: Price: 10000
		AddInterface: HoldItem
		AddInterface: PowerChangeEffect
		AddMapField: Cat: Misc
		AddMapField: GetMultiplier:
		if (canUseOrb(user)) {
			return 1.2;
		}
		
		return 1;
		###
	*
***
Override:
	SpecialItemAbility:
		AddInterface: ChangeTypeEffect
		AddMapField: GetChangeTypeEffect:
		Item item = p.getHeldItem(b);
		if (item instanceof {0}) {
			return new Type[] { (({0})item).getType(), Type.NO_TYPE };
		}
		
		return p.getActualType();
		###
		AddMapField: Irrestealable: True
		AddMapField: Irreplaceable: True
	*
***
Override:
	SpecialItemMove:
		AddMapField: Type: Normal
		AddMapField: MoveType: Metronomeless
		AddMapField: GetType: 
		Item i = user.getHeldItem(b);
		if (i instanceof {0}) {
			return (({0})i).getType(); 
		}
		
		return super.type;
		###
	*
***
Override:
	SpecialTypeItem:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddMapField: Cat: Misc
	*
***
GemItem:
	GemType:
		AddMapField: SpecialTypeItem: {0}
		AddMapField: Price: 100
	*
***
PlateItem:
	PlateType:
		AddMapField: SpecialTypeItem: {0}
		AddMapField: Price: 1000
	*
***
DriveItem:
	DriveType:
		AddMapField: SpecialTypeItem: {0}
		AddMapField: Price: 1000
	*
***
MemoryItem:
	MemoryType:
		AddMapField: SpecialTypeItem: {0}
		AddMapField: Price: 1000
	*
***
Override:
	EvolutionItem:
		AddInterface: PokemonUseItem
		AddMapField: SuccessMessage: ""
		AddMapField: PokemonUse:
		return p.checkEvolution(this.namesies);
		###
	*
***
Override:
	FullHeal:
		Header: boolean removeStatus(ActivePokemon p, CastSource source)
		Body:
		// Does not apply to the dead
		if (p.hasStatus(StatusCondition.FAINTED)) {	
			return false;
		}
		
		// YOU'RE FINE
		if (!p.hasStatus()) {
			return false;
		}
		
		message = Status.getRemoveStatus(null, p, source);
		return true;
		###
		AddMapField: PokemonUse:
		return removeStatus(p, CastSource.USE_ITEM);
		###
		AddMapField: Field: 
		private String message;
		###
		AddMapField: SuccessMessage: message
		AddMapField: BattleCat: Status
		AddInterface: PokemonUseItem
	*
***
Override:
	Revive:
		AddInterface: PokemonUseItem
		AddInterface: HoldItem
		AddMapField: Cat: Medicine
		AddMapField: BattleCat: Status
		AddMapField: Fling: 30
		AddMapField: PokemonUse:
		// Only applies to the dead
		if (!p.hasStatus(StatusCondition.FAINTED)) {
			return false;
		}
		
		p.removeStatus();
		p.healHealthFraction({1});
		
		return true;
		###
		AddMapField: SuccessMessage: p.getName() + " was {2} revived!"
	*
***
Override:
	StatusRemove:
		Header: boolean removeStatus(ActivePokemon p, CastSource source)
		Body:
		if (!p.hasStatus(StatusCondition.{00})) {
			return false;
		}

		message = Status.getRemoveStatus(null, p, source);
		return true;
		###
		AddInterface: PokemonUseItem
		AddMapField: PokemonUse:
		return removeStatus(p, CastSource.USE_ITEM);
		###
		AddMapField: SuccessMessage: message
		AddMapField: Field:
		private String message;
		###
	*
***
Override:
	HealAmt:
		Header: int healAmount()
		Body:
		return {0};
		###
		AddInterface: PokemonUseItem
		AddMapField: PokemonUse:
		return p.heal(healAmount()) != 0;
		###
		AddMapField: SuccessMessage: p.getName() + "'s health was restored!"
		AddMapField: Cat: Medicine
		AddMapField: BattleCat: HP_PP
		AddMapField: Fling: 30
		AddInterface: HoldItem
	*
***
Override:
	XStageIncrease:
		Header: Stat toIncrease()
		AccessModifier: Private
		Body:
		return Stat.{00};
		###
		AddMapField: Fling: 30
		AddMapField: Cat: Stat
		AddMapField: BattleCat: Battle
		AddInterface: HoldItem
		AddInterface: BattleUseItem
		AddMapField: BattleUse:
		return p.getAttributes().modifyStage(p, p, 1, toIncrease(), b, CastSource.USE_ITEM);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toIncrease().getName() + " was raised!"
	*
***
Override:
	EVIncrease:
		Header: Stat toIncrease()
		Body:
		return Stat.{00};
		###
	*
***
Override:
	EVIncreaseAmt:
		Header: int increaseAmount()
		Body:
		return {0};
		###
		AddInterface: PokemonUseItem
		AddMapField: PokemonUse:
		int[] toAdd = new int[Stat.NUM_STATS];
		toAdd[toIncrease().index()] += increaseAmount();

		return p.addEVs(toAdd);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toIncrease().getName() + " was raised!"
	*
***
Override:
	CatchRateCondition:
		AddMapField: CatchRate:
		if ({2-}) {
			return new double[] { {1}, 0 };
		}
		
		return new double[] { 1, 0 };
		###
	*
***
BallItem:
	CatchRate:
		Header: double[] catchRate(ActivePokemon me, ActivePokemon o, Battle b)
		Try:
		return new double[] { {0}, 0 };
		###
		AddMapField: Cat: Ball
		AddMapField: BattleCat: Ball
	*
	AfterCaught:
		Header: void afterCaught(ActivePokemon p)
		Optional: True
	*
***
Override:
	EVDecreaseBerry:
		Header: Stat toDecrease()
		Body:
		return Stat.{00};
		###
		AddInterface: Berry
		AddInterface: PokemonUseItem
		AddMapField: PokemonUse:
		int decreaseIndex = toDecrease().index();
		int[] vals = new int[Stat.NUM_STATS];
		
		// For EVs over 110, the berry will decrease the EV to 100
		if (p.getEV(decreaseIndex) > 110) {
			vals[decreaseIndex] = 100 - p.getEV(decreaseIndex);
		}
		// Otherwise, just decreases by 10
		else {
			vals[decreaseIndex] -= 10;
		}

		return p.addEVs(vals);
		###
		AddMapField: SuccessMessage: p.getName() + "'s " + toDecrease().getName() + " was lowered!"
		AddMapField: NGPow: 90
	*
***
Override:
	SuperEffectivePowerReduceBerry:
		AddInterface: Berry
		AddMapField: NGPow: 80
		AddMapField: NGType: {0}
		AddInterface: OpponentPowerChangeEffect
		AddMapField: GetOppMultiplier:
		if (user.getAttackType() == Type.{00} && TypeAdvantage.isSuperEffective(user, victim, b)) {
			Messages.add(new MessageUpdate(victim.getName() + "'s " + this.name + " decreased " + user.getName() + "'s attack!"));
			victim.consumeItem(b);
			return .5;
		}

		return 1;
		###
	*
***
Override:
	HealthTriggeredStageIncreaseBerry:
		AddInterface: HealthTriggeredBerry
		AddMapField: GainEffect:
		return user.getAttributes().modifyStage(user, user, 1, Stat.{00}, b, source);
		###
		AddMapField: HealthTriggerRatio: 4
		AddMapField: SuccessMessage: p.getName() + "'s " + Stat.{00}.getName() + " increased!"
		AddMapField: HoldSuccessMessage: ""
		AddMapField: NGPow: 100
	*
***
Override:
	CategoryIncreaseBerry:
		AddMapField: NGPow: 100
		AddInterface: Berry
		AddInterface: TakeDamageEffect
		AddMapField: OnTakeDamage:
		if (user.getAttack().getCategory() == MoveCategory.{11} && victim.getAttributes().modifyStage(victim, victim, 1, Stat.{22}, b, CastSource.HELD_ITEM)) {
			victim.consumeItem(b);
		}
		###
	*
***
Override:
	CategoryDamagerBerry:
		Header: MoveCategory getCategory()
		Body:
		return MoveCategory.{00};
		###
		AddMapField: NGPow: 100
		AddInterface: Berry
		AddInterface: TakeDamageEffect
		AddMapField: OnTakeDamage:
		if (user.getAttack().getCategory() == getCategory()) {
			Messages.add(new MessageUpdate(user.getName() + " was hurt by " + victim.getName() + "'s " + this.name + "!"));
			user.reduceHealthFraction(b, 1/8.0);
			victim.consumeItem(b);
		}
		###
	*
***
Override:
	HealPartyStatus:
		AddMapField: ApplyEffects:
		for (ActivePokemon p : b.getTrainer(user.isPlayer()).getTeam()) {
			if (!p.hasStatus(StatusCondition.FAINTED)) {
				p.removeStatus();
			}
		}
		
		Messages.add(new MessageUpdate("All status problems were cured!"));
		###
		AddMapField: SelfTarget: True
	*
***
Override:
	RemoveAdvantageType:
		AddInterface: NoAdvantageChanger
		AddMapField: NegateNoAdvantage: defending == Type.{11} && ({2-})
	*
***
Override:
	ForesightEffect:
		AddMapField: CastMessage: user.getName() + " identified " + victim.getName() + "!"
		AddMapField: CanHave: True
		AddMapField: UsedProof: True
		AddMapField: RemoveAdvantageType: {0}
	*
***
Override:
	ForesightMove:
		AddMapField: Effect: {0}
		AddMapField: ApplyEffects: 
		super.applyEffects(b, user, victim);
		victim.getAttributes().resetStage(Stat.EVASION);
		###
		AddMapField: MoveType: Substitute_Piercing
	*
***
Override:
	AddTypeMove:
		AddInterface: ChangeTypeSource
		AddMapField: Effect: ChangeType
		AddMapField: ChangeType:
		Type primary = victim.getType(b)[0];
				
		return new Type[] { primary, primary == Type.{00} ? Type.NO_TYPE : Type.{00} };
		###
	*
***
Override:
	PrintFail:
		Header: boolean canPrintFail()
		Body:
		return {0};
		###
	*
***
Override:
	FutureAttackMove:
		AddMapField: Effect: {0}
		AddMapField: Apply:
		super.applyEffects(b, me, o); // Don't apply damage just yet!!
		###
		AddMapField: PrintFail: true
	*
***
Override:
	FutureAttackEffect:
		AddMapField: MinTurns: 2
		AddMapField: MaxTurns: 2
		AddMapField: NextTurnSubside: True
		AddMapField: Field: 
		private ActivePokemon theSeeer;
		###
		AddMapField: Subside: 
		Messages.add(new MessageUpdate(p.getName() + " took " + theSeeer.getName() + "'s attack!"));
			
		Attack attack = AttackNamesies.{00}.getAttack();
		
		// Don't do anything for moves that are uneffective
		if (!attack.effective(b, theSeeer, p)) {
			return;
		}
		
		theSeeer.setMove(new Move(attack));
		theSeeer.getAttack().applyDamage(theSeeer, p, b);
		###
		AddMapField: Cast: 
		theSeeer = caster;
		super.cast(b, caster, victim, source, printCast);
		###
		AddMapField: CastMessage: theSeeer.getName() + " foresaw an attack!"
	*
***
Override:
	EliminateStatChanges:
		AddMapField: ApplyEffects: 
		user.getAttributes().resetStages();
		victim.getAttributes().resetStages();
		Messages.add(new MessageUpdate("All stat changes were eliminated!"));
		###
	*
***
Override:
	StatSwapMove:
		AddMapField: Field:
		private static final Stat[] swapStats = { Stat.{11}, Stat.{22} };
		###
		AddMapField: ApplyEffects: 
		for (Stat s : swapStats) {
			user.getAttributes().swapStages(s, victim);
		}
		
		Messages.add(new MessageUpdate(user.getName() + " swapped its stats with " + victim.getName() + "!"));
		###
		AddMapField: MoveType: No_Magic_Coat
	*
***
StatusBerry:
	StatusBerryGainEffect:
		Optional: True
		AddMapField: GainEffect:
		if (!removeStatus(user, CastSource.HELD_ITEM)) {
			return false;
		}
		
		holdMessage = message;
		return true;
		###
		AddInterface: Hidden-GainableEffectBerry
		AddMapField: HoldSuccessMessage: holdMessage
		AddMapField: NGPow: 80
		AddMapField: Field:
		private String holdMessage;
		###
	*
***
GainableEffectBerry:
	GainEffect:
		Header: boolean beginGainBerryEffect(Battle b, ActivePokemon user, CastSource source)
		Optional: True
		Default:
		return use(user);
		###
		AddInterface: Hidden-Berry
		AddMapField: FlingEffect:
		gainBerryEffect(b, pelted, CastSource.USE_ITEM);
		###
	*
***
HealthTriggeredBerry:
	HealthTriggerRatio:
		AddInterface: Hidden-GainableEffectBerry
		Header: double healthTriggerRatio()
		Try:
		return 1/{0}.0;
		###
	*
***
Berry:
	NGPow:
		Header: int naturalGiftPower()
		Body:
		return {0};
		###
		AddMapField: Cat: Berry
		AddInterface: Hidden-HoldItem
		AddMapField: Fling: 10
		AddMapField: Price: 20
	*
	NGType:
		Header: Type naturalGiftType()
		Body:
		return Type.{00};
		###
	*
***
Override:
	RepelSteps:
		Header: int repelSteps()
		Body:
		return {0};
		###
		AddInterface: HoldItem
		AddMapField: Fling: 30
		AddInterface: TrainerUseItem
		AddMapField: TrainerUse:
		if (!(t instanceof CharacterData)) {
			Global.error("Only the character should be using a Repel item");
			return false;
		}

		CharacterData player = (CharacterData) t;
		if (player.isUsingRepel()) {
			return false;
		}

		player.addRepelSteps(repelSteps());
		return true;
		###
		AddMapField: SuccessMessage: "Weak wild Pok\u00e9mon will not appear for " + repelSteps() + " steps!"
		AddMapField: Cat: Misc
	*
***
CritBlockerEffect:
	BlockCrits:
		Header: boolean blockCrits()
		Optional: True
		Default:
		return true;
		###
	*
***
Override:
	PowderResist:
		Header: String getPreventMessage(ActivePokemon victim)
		AccessModifier: Private
		Body:
		return victim.getName() + "'s " + this.getName() + " protects it from powder moves!";
		###
		AddInterface: EffectBlockerEffect
		AddMapField: ValidMove:
		if (!user.getAttack().isMoveType(MoveType.POWDER)) {
			return true;
		}
		
		if (user.getAttack().isStatusMove()) {
			Messages.add(new MessageUpdate(getPreventMessage(victim)));
		}
		
		return false;
		###
	*
***
NoAdvantageChanger:
	NegateNoAdvantage:
		Header: boolean negateNoAdvantage(Type attacking, Type defending)
		Body:
		return {0};
		###
	*
***
AdvantageMultiplierMove:
	MultiplyAdvantage:
		Header: double multiplyAdvantage(Type attackingType, Type[] defendingTypes)
	*
***
Override:
	SuperEffectiveAdvantageType:
		AddInterface: AdvantageMultiplierMove
		AddMapField: MultiplyAdvantage:
		double multiplier = 1;
		for (Type defendingType : defendingTypes) {
			if (defendingType == Type.{00}) {
				multiplier *= 2/attackingType.getAdvantage().getAdvantage(defendingType);
			}
		}
		
		return multiplier;
		###
	*
***
Override:
	GetPow:
		Header: int setPower(Battle b, ActivePokemon me, ActivePokemon o)
	*
***
Override:
	ApplyDamage:
		Header: void applyDamage(ActivePokemon me, ActivePokemon o, Battle b)
	*
***
Override:
	GetAccuracy:
		Header: int getAccuracy(Battle b, ActivePokemon me, ActivePokemon o)
	*
***
Override:
	Apply:
		Header: void apply(ActivePokemon me, ActivePokemon o, Battle b)
	*
***
Override:
	Aura:
		Header: Type getAuraType()
		Body:
		return Type.{00};
		###
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		if (user.getAttackType() == getAuraType()) {
			return 1 + .33*(victim.hasAbility(AbilityNamesies.AURA_BREAK) ? -1 : 1);
		}
		
		return 1;
		###
	*
***
Override:
	StealItem:
		Header: void steal(Battle b, ActivePokemon thief, ActivePokemon victim)
		Body:
		// Dead Pokemon and wild Pokemon cannot steal; 
		// Cannot steal if victim is not holding an item or thief is already holding an item;
		// Cannot steal from a Pokemon with the Sticky Hold ability 
		if (thief.isFainted(b) || !victim.isHoldingItem(b) || thief.isHoldingItem(b) || b.getTrainer(thief.isPlayer()) instanceof WildPokemon || victim.hasAbility(AbilityNamesies.STICKY_HOLD)) {
			return;
		}
		
		// Stealers gon' steal
		Item stolen = victim.getHeldItem(b);
		Messages.add(new MessageUpdate(thief.getName() + " stole " + victim.getName() + "'s " + stolen.getName() + "!"));
		
		if (b.isWildBattle()) {
			victim.removeItem();
			thief.giveItem((HoldItem)stolen);
			return;
		}
		
		item = stolen;
		EffectNamesies.CHANGE_ITEM.getEffect().cast(b, thief, thief, CastSource.ABILITY, false);
		
		item = ItemNamesies.NO_ITEM.getItem();
		EffectNamesies.CHANGE_ITEM.getEffect().cast(b, thief, victim, CastSource.ABILITY, false);
		###
		AddInterface: ItemHolder
		AddMapField: Field:
		private Item item;
		###
		AddMapField: GetItem:
		return item;
		###
	*
***
Override:
	RaiseAllStats:
		AddMapField: StatChange: 7 Attack 1 Defense 1 Sp_Attack 1 Sp_Defense 1 Speed 1 Accuracy 1 Evasion 1
	*
***
Override:
	ConsumeBerry:
		AddMapField: ApplyEffects: 
		Item i = victim.getHeldItem(b);
		if (i instanceof Berry) {
			Messages.add(new MessageUpdate(user.getName() + " ate " + victim.getName() + "'s " + i.getName() + "!"));
			victim.consumeItem(b);
			
			if (i instanceof GainableEffectBerry) {
				((GainableEffectBerry)i).gainBerryEffect(b, user, CastSource.USE_ITEM);
			}
		}
		###
	*
***
Override:
	ApplyEffects:
		Header: void applyEffects(Battle b, ActivePokemon user, ActivePokemon victim)
	*
***
Override:
	SuccessMessage:
		Header: String getSuccessMessage(ActivePokemon p)
		Body:
		return {0};
		###
	*
***
Override:
	HoldSuccessMessage:
		Header: String getHoldSuccessMessage(Battle b, ActivePokemon p)
		Body:
		return {0};
		###
	*
***
ChangeAttackTypeEffect:
	ChangeAttackType:
		Header: Type changeAttackType(Attack attack, Type original)
	*
***
Override:
	NormalTypeChanger:
		Header: Type getType()
		Body:
		return Type.{00};
		###
		AddInterface: ChangeAttackTypeEffect
		AddMapField: ChangeAttackType:
		if (original == Type.NORMAL) {
			this.activated = true;
			return getType();
		}
		
		return original;
		###
		AddMapField: Field:
		private boolean activated;
		###
		AddMapField: Activate:
		this.activated = false;
		###
		AddInterface: EndTurnEffect
		AddMapField: ApplyEndTurn:
		this.activated = false;
		###
		AddInterface: PowerChangeEffect
		AddMapField: GetMultiplier:
		return activated ? 1.3 : 1;
		###
	*
***
StatLoweredEffect:
	NextLevel:
		Header: void takeItToTheNextLevel(Battle b, ActivePokemon caster, ActivePokemon victim)
		Body:
		victim.getAttributes().modifyStage(victim, victim, 2, Stat.{00}, b, CastSource.@SuperClass);
		###
	*
***
Override:
	FlinchItem:
		AddMapField: FlingEffect:
		PokemonEffect flinch = (PokemonEffect)EffectNamesies.FLINCH.getEffect();
		if (flinch.applies(b, pelted, pelted, CastSource.USE_ITEM)) {
			flinch.cast(b, pelted, pelted, CastSource.USE_ITEM, false);
			Messages.add(new MessageUpdate("The " + this.name + " caused " + pelted.getName() + " to flinch!"));
		}
		###
		AddMapField: OnApplyDamage:
		if (RandomUtils.chanceTest(10)) {
			PokemonEffect flinch = (PokemonEffect)EffectNamesies.FLINCH.getEffect();
			if (flinch.applies(b, user, victim, CastSource.HELD_ITEM)) {
				flinch.cast(b, user, victim, CastSource.HELD_ITEM, false);
				Messages.add(new MessageUpdate(user.getName() + "'s " + this.name + " caused " + victim.getName() + " to flinch!"));
			}
		}
		###
		AddInterface: ApplyDamageEffect
		AddInterface: HoldItem
	*
***
Override:
	StatusFling:
		AddMapField: FlingEffect:
		Status.giveStatus(b, pelted, pelted, StatusCondition.{00}, pelted.getName() + " was {0} by the " + this.name + "!");
		###
	*
***
Override:
	TM:
		Header: Attack getAttack()
		AccessModifier: PRIVATE
		Body:
		return AttackNamesies.getValueOf("{0}").getAttack();
		###
		AddMapField: Cat: TM
		AddInterface: MoveUseItem
		AddMapField: SuccessMessage: p.getName() + " learned " + getAttack().getName() + "!"
		AddMapField: MoveUse:
		Attack attack = getAttack();
		
		// Cannot learn if you already know the move
		if (p.hasActualMove(attack.namesies())) {
			return false;
		}

		// Cannot learn if the TM is not compatible with the Pokemon
		if (!p.getPokemonInfo().canLearnMove(attack.namesies())) {
			return false;
		}

		Move tmMove = new Move(attack);
		List<Move> moveList = p.getActualMoves();

		// If they don't have a full move list, append to the end
		if (moveList.size() < Move.MAX_MOVES) {
			p.addMove(null, tmMove, moveList.size());
			return true;
		}

		// Otherwise, go through their moves and find the one that matches and replace with the TM move
		for (int i = 0; i < moveList.size(); i++) {
			if (moveList.get(i).getAttack().namesies() == m.getAttack().namesies()) {
				p.addMove(tmMove, i, false);
				return true;
			}
		}

		// Did not find move to replace -- throw error
		Global.error("ActivePokemon " + p.getName() + " does not have move to replace " + m.getAttack().getName());
		return false;
		###
	*
***
PriorityChangeEffect:
	ChangePriority:
		Header: int changePriority(Battle b, ActivePokemon user, Attack attack, int priority)
		Body:
		if ({0}) {
			if (this instanceof ConsumableItem) {
				user.consumeItem(b);
			}
			
			priority++;
		}
		
		return priority;
		###
	*
***
IncenseItem:
	Baby:
		Header: PokemonNamesies getBaby()
		Body:
		return PokemonNamesies.{00};
		###
	*
***
AbsorbDamageEffect:
	AbsorbDamage:
		Header: boolean absorbDamage(Battle b, ActivePokemon damageTaker, int damageAmount)
	*
***
DamageTakenEffect:
	DamageTaken:
		Header: void damageTaken(Battle b, ActivePokemon damageTaker)
	*
***
SapHealthEffect:
	SapPercentage:
		Header: double sapPercentage()
		Optional: True
	*
	SapAmount:
		Header: int getSapAmount(ActivePokemon victim, int damageAmount)
		Optional: True
	*
	SapMessage:
		Header: String getSapMessage(ActivePokemon victim)
		Optional: True
	*
***
AlwaysCritEffect:
	ShouldCrit:
		Header: boolean shouldCrit(Battle b, ActivePokemon attacking, ActivePokemon defending)
		Optional: True
		Default: return true;
	*
***
Override:
	IgnoreAbilityMove:
		AddMapField: Apply:
		EffectNamesies.BREAKS_THE_MOLD.getEffect().cast(b, me, me, CastSource.ATTACK, false);
		super.apply(me, o, b);
		me.getAttributes().removeEffect(EffectNamesies.BREAKS_THE_MOLD);
		###
	*
***
StatusReceivedEffect:
	StatusReceived:
		Header: void receiveStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusCondition statusType)
	*
***
OpponentStatusReceivedEffect:
	OppStatusReceived:
		Header: void receiveStatus(Battle b, ActivePokemon victim, StatusCondition statusType)
	*
***
SleepyFightsterEffect:
***
SuperDuperEndTurnEffect:
	TheVeryEnd:
		Header: boolean theVeryVeryEnd(Battle b, ActivePokemon p)
	*
***
Override:
	PriorityPrevention:
		AddInterface: OpponentBeforeTurnAttackSelectionEffect
		AddMapField: Usable: 
		return b.getPriority(p, m.getAttack()) <= 0;
		###
		AddMapField: UnusableMessage: b.getOtherPokemon(p).getName() + "'s " + this.getName() + " prevents priority moves!!"
		AddMapField: Field:
		
		public String getFailMessage(Battle b, ActivePokemon p, ActivePokemon opp) {
			return getUnusableMessage(b, p);
		}
		###
	*
***
BeforeTurnAttackSelectionEffect:
	BeforeTurnAttackSelectionFail:
		AddInterface: Hidden-AttackSelectionEffect
		AddInterface: Hidden-BeforeTurnEffect
		Optional: True
	*
***
OpponentBeforeTurnAttackSelectionEffect:
	OpponentBeforeTurnAttackSelectionFail:
		AddInterface: Hidden-OpponentAttackSelectionEffect
		AddInterface: Hidden-OpponentBeforeTurnEffect
		Optional: True
	*
***
OpponentEndAttackEffect:
	OpponentEndAttack:
		Header: void endsies(Battle b, ActivePokemon attacking, Attack attack)
	*
***
Override:
	TerrainStarter:
		AddInterface: EntryEffect
		AddMapField: Enter:
		Messages.add(new MessageUpdate(enterer.getName() + "'s " + this.getName() + " changed the field to {0} Terrain!"));
		EffectNamesies.{00}_TERRAIN.getEffect().cast(b, enterer, enterer, CastSource.ABILITY, false);
		###
	*
***
Override:
	MoldBreakerBreaker:
		Header: boolean unbreakableMold()
		Body:
		// Ability is not ignored even when the opponent breaks the mold
		return true;
		###
	*
***
Override:
	Irreplaceable:
		Header: boolean isReplaceable()
		Body:
		return false;
		###
	*
***
Override:
	Irrestealable:
		Header: boolean isStealable()
		Body:
		return false;
		###
	*
***
Override:
	DropBelowHalfHealth:
		AddInterface: TakeDamageEffect
		AddMapField: OnTakeDamage:
		if (victim.getHPRatio() < .5 && (victim.getHP() + victim.getAttributes().getDamageTaken())/(double)victim.getMaxHP() >= .5) {
			{0}
		}
		###
	*
***
TerrainCastEffect:
	NewTerrain:
		Header: void newTerrain(Battle b, ActivePokemon p, TerrainType newTerrain)
	*
***
Override:
	TerrainSeed:
		AddInterface: ConsumableItem
		AddInterface: TerrainCastEffect
		AddMapField: NewTerrain:
		if (newTerrain == TerrainType.{11} && p.getAttributes().modifyStage(p, p, 1, Stat.{22}, b, CastSource.HELD_ITEM)) {
			p.consumeItem(b);
		}
		###
		AddMapField: Price: 4000
		AddMapField: Fling: 30
		AddMapField: Cat: Misc
	*
***
Override:
	FormChange:
		AddMapField: Irrestealable: True
		AddMapField: Irreplaceable: True
		AddMapField: Field:
		private static final int[] {33}_STATS = new int[] { {4}, {5}, {6}, {7}, {8}, {9} };
		private static final int[] {1010}_STATS = new int[] { {11}, {12}, {13}, {14}, {15}, {16} };
		
		private boolean {1};
		private int[] getStats() {
			return {1} ? {1010}_STATS : {33}_STATS;
		}
		###
		AddMapField: Activate:
		this.{1} = {2};
		###
		AddInterface: DifferentStatEffect
		AddMapField: GetStat:
		// Need to calculate the new stat -- yes, I realize this is super inefficient and whatever whatever whatever
		int index = stat.index();
		return Stat.getStat(index, user.getLevel(), getStats()[index], user.getIV(index), user.getEV(index), user.getNature().getNatureVal(index));
		###
	*
***
Override:
	EndTurnFormChange:
		Header: boolean formCheck(ActivePokemon formsie)
		AccessModifier: Private
		Body:
		return {17-};
		###
		AddMapField: FormChange: {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12} {13} {14} {15} {16}
		AddInterface: EndTurnEffect
		AddInterface: EntryEffect
		AddMapField: Enter:
		if (formCheck(enterer)) {
			{1} = true;
			Messages.add(new MessageUpdate(enterer.getName() + " changed into {10} Forme!"));
		}
		else {
			{1} = false;
			Messages.add(new MessageUpdate(enterer.getName() + " changed into {3} Forme!"));
		}
		###
		AddMapField: ApplyEndTurn:
		if (formCheck(victim)) {
			if (!{1}) {
				{1} = true;
				Messages.add(new MessageUpdate(victim.getName() + " changed into {10} Forme!"));	
			}
		}
		else if ({1}){
			{1} = false;
			Messages.add(new MessageUpdate(victim.getName() + " changed into {3} Forme!"));
		}
		###
	*
***