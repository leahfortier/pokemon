BeginAttack:
	Header: void beginAttack(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
UniqueEffects:
	Header: void uniqueEffects(Battle b, ActivePokemon user, ActivePokemon victim)
*
EndAttack:
	Header: void endAttack(Battle b, ActivePokemon user, ActivePokemon victim)
*
AfterApplyCheck:
	Header: void afterApplyCheck(Battle b, ActivePokemon user, ActivePokemon victim)
*
ShouldApplyDamage:
	Header: boolean shouldApplyDamage(Battle b, ActivePokemon user)
*
ShouldApplyEffects:
	Header: boolean shouldApplyEffects(Battle b, ActivePokemon user)
*
FixedDamage:
	AddMapField: ApplyDamage:
		o.reduceHealth(b, {0});
		###
*
GetPriority:
	Header: int getPriority(Battle b, ActivePokemon me)
*
GetType:
	Header: Type getType(Battle b, ActivePokemon user)
*
FullApplies:
	Header: boolean applies(Battle b, ActivePokemon user, ActivePokemon victim)
*
Applies:
	AddMapField: FullApplies:
		return {0};
		###
*
ExtraApplies:
	AddMapField: Applies: {0}
*
Recoil:
	Header: void applyRecoil(Battle b, ActivePokemon user, int damage)
	AddInterface: RecoilMove
*
RecoilPercentage:
	AddInterface: RecoilPercentageMove
	Header: int getDamagePercentageDenominator()
	Body:
		return {0};
		###
*
StatusFang:
	AddMapField: EffChance: 20
	AddMapField: Effect: Flinch
	AddMapField: MoveType: Biting
	AddMapField: BeginAttack:
		super.status = StatusCondition.NO_STATUS;
		super.effects.clear();
		
		// If the effect is being applied, 50/50 chance to give a status condition vs. flinching
		if (RandomUtils.chanceTest(50)) {
			super.status = StatusCondition.{00};
		}
		else {
			super.effects.add(EffectNamesies.FLINCH);
		}
		###
*
WeatherHeal:
	AddMapField: BasicHealing: 
		switch (b.getWeather().namesies()) {
			case CLEAR_SKIES:
				return 1/2.0;
			case SUNNY:
				return 2/3.0;
			case HAILING:
			case RAINING:
			case SANDSTORM:
				return 1/4.0;
			default:
				Global.error("Funky weather problems!!!!");
				return -1;
		}
		###
*
HealFraction:
	AddMapField: BasicHealing: 
		return {0};
		###
*
BasicHealing:
	AddMapField: SelfHealing: {0}
	AddMapField: UniqueEffects:
		this.heal(b, victim);
		###
*
SelfHealing:
	AddMapField: RawSelfHealing: {0}
	AddMapField: Applies: !user.fullHealth() && !user.hasEffect(EffectNamesies.HEAL_BLOCK)
*
RawSelfHealing:
	AddInterface: SelfHealingMove
	Header: double getHealFraction(Battle b, ActivePokemon victim)
	AddMapField: SelfTarget: True
	AddMapField: MoveType: Healing
*
ChargingMove:
	AddInterface: ChargingMove
	AddMapField: MultiTurn: True
	Header: String getChargeMessage(ActivePokemon user)
	Body:
		return {0};
		###
*
RechargingMove:
	AddInterface: RechargingMove
	AddMapField: MultiTurn: True
*
MultiTurn:
	AddMapField: AfterApplyCheck:
		if (this.isCharging(user)) {				
			Messages.add(this.getChargeMessage(user));
		}
		###
	AddMapField: MoveType: Sleep_Talk_Fail
*
SemiInv:
	Header: boolean semiInvulnerability()
	Body:
		return {0};
		###
*
IsMultiTurn:
	Header: boolean isMultiTurn(Battle b, ActivePokemon user)
*
MultiStrike:
	AddInterface: MultiStrikeMove
	AddMapField: GetMinHits: {1}
	AddMapField: GetMaxHits: {2}
	AddMapField: ApplyDamage:
		int hits = this.getNumHits(me);
		
		int hit = 1;
		for (; hit <= hits; hit++) {
			Messages.add("Hit " + hit + "!");
			super.applyDamage(me, o, b);
			
			// Stop attacking the dead
			if (o.isFainted(b)) {
				break;
			}
		}
		
		hit--;
		
		// Print hits and gtfo
		Messages.add("Hit " + hit + " time" + (hit == 1 ? "" : "s") + "!");
		###
*
GetMinHits:
	Header: int getMinHits()
	Body: return {0};
*
GetMaxHits:
	Header: int getMaxHits()
	Body: return {0};
*
ChangeType:
	AddInterface: ChangeTypeSource
	Header: Type[] getType(Battle b, ActivePokemon caster, ActivePokemon victim)
*
RemoveType:
	AddMapField: ChangeType: 
		Type[] type = victim.getType(b);
				
		// TODO: Rewrite this because it looks stupid
		if (type[0] == Type.{00}) {
			return new Type[] { type[1], Type.NO_TYPE };
		}

		if (type[1] == Type.{00}) {
			return new Type[] { type[0], Type.NO_TYPE };
		}

		return null;
		###
*
StartTurn:
	Header: void startTurn(Battle b, ActivePokemon me)
*
SwitchItemMessage:
	Header: String getSwitchMessage(ActivePokemon user, Item userItem, ActivePokemon victim, Item victimItem)
	Body:
		return {0};
		###
*
BattleEffect:
	AddMapField: Effect: {0}
	AddMapField: MoveType: No_Magic_Coat, Field
*
ProtectingAttack:
	AddMapField: Effect: {0}
	AddMapField: Priority: 4
	AddMapField: SelfTarget: True
	AddMapField: MoveType: Successive_Decay, Assistless, Metronomeless, Non_Snatchable
*
OHKO:
	AddMapField: Applies: user.getLevel() >= victim.getLevel()
	AddMapField: ApplyDamage:
		// Certain death
		o.reduceHealth(b, o.getHP());
		Messages.add("It's a One-Hit KO!");
		###
	AddMapField: MoveType: One_Hit_KO
	AddMapField: GetAccuracy:
		return super.accuracy + (me.getLevel() - o.getLevel());
		###
*
SwitchStat:
	Header: Stat switchStat(Stat s)
*
OppSwitchStat:
	Header: Stat switchStat(Stat s)
*
CrashDamage:
	Header: void crash(Battle b, ActivePokemon user)
	Body:
		Messages.add(user.getName() + " kept going and crashed!");
		user.reduceHealth(b, user.getMaxHP()/{0});
		###
*
StatSplit:
	AddInterface: StatChangingEffect
	AddMapField: ChangeStat:
		
		// If the stat is a splitting stat, return the average between the user and the opponent
		if (s == Stat.{11} || s == Stat.{22}) {
			return (p.getStat(b, s) + opp.getStat(b, s))/2;
		}
		
		return stat;
		###
*
StageChange:
	Header: int adjustStage(Battle b,  ActivePokemon p, ActivePokemon opp, Stat s)
*
IgnoreStage: 
	Header: boolean ignoreStage(Stat s)
*
StatusCureMove:
	AddMapField: PowerMultiplierCondition: 2 victim.hasStatus(StatusCondition.{00})
	AddMapField: UniqueEffects:
		if (victim.hasStatus(StatusCondition.{00})) {
			Status.removeStatus(b, victim, CastSource.ATTACK);
		}
		###
*
StormyMove:
	AddMapField: GetAccuracy:
		// Accuracy is only 50% when sunny
		if (b.getWeather().namesies() == EffectNamesies.SUNNY) {
			return 50;
		}
		
		return super.accuracy;
		###
	AddMapField: BypassAccuracy:
		// Always hits when the opponent is flying or it is raining (unless they're non-flying semi-invulnerable)
		return defending.isSemiInvulnerableFlying() || (b.getWeather().namesies() == EffectNamesies.RAINING && defending.isSemiInvulnerable());
		###
	AddMapField: HitFly: True
*
HitFly:
	AddMapField: BypassAccuracy:
		// Always hit when the opponent is flying
		return defending.isSemiInvulnerableFlying();
		###
	AddMapField: Comments: // Twice as strong when the opponent is flying
	AddMapField: PowerMultiplierCondition: 2 victim.isSemiInvulnerableFlying()
*
HitDig:
	AddMapField: BypassAccuracy:
		// Always hit when the opponent is underground
		return defending.isSemiInvulnerableDigging();
		###
	AddMapField: GetPow:
		int power = 1;
		
		// Power is halved during Grassy Terrain
		if (b.hasEffect(EffectNamesies.GRASSY_TERRAIN)) {
			power *= .5;
		}
		
		// Power is doubled when the opponent is underground
		if (o.isSemiInvulnerableDigging()) {
			power *= 2;
		}
		
		return power;
		###
*
HPRatioMove:
	AddMapField: GetPow:
		return (int)Math.min(1, ({1}*{2}.getHPRatio()));
		###
*
Flailing:
	AddMapField: GetPow: 
		double ratio = me.getHPRatio();
		if (ratio > .7) return 20;
		if (ratio > .35) return 40;
		if (ratio > .2) return 80;
		if (ratio > .1) return 100;
		if (ratio > .04) return 150;
		return 200;
		###
*
LightClay:
	AddMapField: Cast: 
		super.cast(b, caster, victim, source, printCast);
		if (caster.isHoldingItem(b, ItemNamesies.LIGHT_CLAY)) {
			Effect.getEffect(b.getEffects(victim), this.namesies).setTurns(8);
		}
		###
	AddMapField: MinTurns: 5
	AddMapField: MaxTurns: 5
*
Barrier:
	AddMapField: LightClay: True
	AddMapField: ToModify: {1}
	AddMapField: ModifyMultiplier: 2 !opp.hasAbility(AbilityNamesies.INFILTRATOR)
	AddMapField: CastMessage: user.getName() + " raised the " + Stat.{11}.getName().toLowerCase() + " of its team!"
	AddMapField: SubsideMessage: "The effects of {2-} faded."
	AddMapField: Defog: "The effects of {2-} faded."
	AddMapField: BreakBarrier: {2-}
*
BreakBarrier:
	Header: void breakBarrier(Battle b, ActivePokemon breaker)
	Body:
		Messages.add(breaker.getName() + " broke the {0} barrier!");
		b.getEffects(!breaker.isPlayer()).remove(this);
		###
*
SpecificAbilityChange:
	AddInterface: ChangeAbilityMove
	AddMapField: Applies: victim.getAbility().isReplaceable()
	AddMapField: Effect: ChangeAbility
	AddMapField: AbilityChange:
		return AbilityNamesies.{00}.getNewAbility();
		###
	AddMapField: AbilityMessage: 
		return victim.getName() + "'s ability was changed to " + AbilityNamesies.{00}.getName() + "!";
		###
*
HitMinimize:
	AddMapField: BypassAccuracy:
		return !defending.isSemiInvulnerable() && defending.hasEffect(EffectNamesies.USED_MINIMIZE);
		###
	AddMapField: PowerMultiplierCondition: 2 victim.hasEffect(EffectNamesies.USED_MINIMIZE)
*
BypassAccuracy:
	AddInterface: AccuracyBypassEffect
	Header: boolean bypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
OpponentBypassAccuracy:
AddInterface: OpponentAccuracyBypassEffect
	Header: boolean opponentBypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
AbilityChange:
	Header: Ability getAbility(Battle b, ActivePokemon caster, ActivePokemon victim)
*
AbilityMessage:
	Header: String getMessage(Battle b, ActivePokemon caster, ActivePokemon victim)
*
MirrorMove:
	AddMapField: MoveType: Sleep_Talk_Fail, Encoreless, Metronomeless, Assistless, No_Magic_Coat, Mirrorless
	AddMapField: Field:
		private Move mirror;
		###
	AddMapField: BeginAttack:
		this.mirror = defending.getAttributes().getLastMoveUsed();
		###
	AddMapField: Applies: mirror != null && !mirror.getAttack().isMoveType(MoveType.MIRRORLESS)
	AddMapField: CallNewMove: new Move(mirror.getAttack())
*
Countering:
	AddMapField: Priority: -5
	AddMapField: MoveType: Assistless, Metronomeless
	AddMapField: PP: 20
	AddMapField: Acc: 100
	AddMapField: Applies: user.getAttributes().getDamageTaken() > 0 && victim.getMove() != null && victim.getAttack().getCategory() == MoveCategory.{00} && !b.isFirstAttack()
	AddMapField: ApplyDamage: 
		// Fails if no damage to reflect or if the opponent isn't using an attack of the proper category
		int damageTaken = me.getAttributes().getDamageTaken();
		o.reduceHealth(b, damageTaken*2);
		###
*
CallNewMove:
	AddMapField: UniqueEffects:
		user.callNewMove(b, victim, {0});
		###
*
SwapOpponent:
	Header: String getSwapMessage(ActivePokemon user, ActivePokemon victim)
	Body:
		return {0};
		###
	AddMapField: MoveType: Assistless
	AddMapField: Priority: -6
	AddMapField: Applies: user.canSwapOpponent(b, victim)
	AddMapField: UniqueEffects:
		user.swapOpponent(b, victim, this);
		###
*
SelfSwitching:
	AddMapField: UniqueEffects:
		user.switcheroo(b, user, CastSource.ATTACK, true);
		###
*
ApplyEndTurn:
	Header: void applyEndTurn(ActivePokemon victim, Battle b)
*
CanAttack:
	Header: boolean canAttack(ActivePokemon p, ActivePokemon opp, Battle b)
*
OpponentCanAttack:
	Header: boolean opposingCanAttack(ActivePokemon p, ActivePokemon opp, Battle b)
*
ProtectingEffect:
	AddInterface: ProtectingEffect
	AddMapField: MinTurns: 1
	AddMapField: MaxTurns: 1
	AddMapField: CastMessage: victim.getName() + " protected itself!"
	AddMapField: SuccessiveDecay: True
*
ProtectingCondition:
	Header: boolean protectingCondition(Battle b, ActivePokemon attacking)
*
OnProtectingSuccess:
	Header: void protectingEffects(Battle b, ActivePokemon p, ActivePokemon opp)
*
SuccessiveDecay:
	AddMapField: Cast:
		if (!RandomUtils.chanceTest((int)(100*caster.getAttributes().getSuccessionDecayRate()))) {
			Messages.add(this.getFailMessage(b, caster, victim));
			return;
		}

		super.cast(b, caster, victim, source, printCast);
		###
*
Trapped:
	Header: boolean trapped(Battle b, ActivePokemon escaper)
*
TrappingMessage:
	Header: String trappingMessage(ActivePokemon trapped)
	Body:
		return {0};
		###
*
OpponentTrappingAbility:
	AddMapField: OppTrapped:
		return {0};
		###
	AddMapField: OppTrappingMessage:
		return trapper.getName() + "'s " + this.getName() + " prevents " + escaper.getName() + " from escaping!";
		###
*
OppTrapped: 
	Header: boolean trapOpponent(Battle b, ActivePokemon escaper, ActivePokemon trapper)
	AddInterface: OpponentTrappingEffect
*
OppTrappingMessage:
	Header: String opponentTrappingMessage(ActivePokemon escaper, ActivePokemon trapper)
*
PartialTrap:
	AddMapField: Cast:
		super.cast(b, caster, victim, source, printCast);
		if (caster.isHoldingItem(b, ItemNamesies.GRIP_CLAW)) setTurns(5);
		###
	AddInterface: EndTurnEffect
	AddInterface: TrappingEffect
	AddInterface: RapidSpinRelease
	AddMapField: MinTurns: 4
	AddMapField: MaxTurns: 5
	AddMapField: NextTurnSubside: True
	AddMapField: CastMessage: {2-}
	AddMapField: SubsideMessage: victim.getName() + " is no longer trapped by {1_}."
	AddMapField: RapidSpin: releaser.getName() + " was released from {1_}!"
	AddMapField: TrappingMessage: trapped.getName() + " cannot be recalled due to {1_}!"
	AddMapField: ApplyEndTurn:
		if (victim.hasAbility(AbilityNamesies.MAGIC_GUARD)) {
			return;
		}
		
		Messages.add(victim.getName() + " is hurt by {1_}!");
		
		// Reduce 1/8 of the victim's total health, or 1/6 if holding a binding band
		victim.reduceHealthFraction(b, b.getOtherPokemon(victim).isHoldingItem(b, ItemNamesies.BINDING_BAND) ? 1/6.0 : 1/8.0);
		###
*
SafeguardEffect:
	AddMapField: CastMessage: user.getName() + " is covered by a veil!"
	AddMapField: SubsideMessage: "The effects of " + victim.getName() + "'s {0} faded."
	AddMapField: MinTurns: 5
	AddMapField: MaxTurns: 5
	AddInterface: StatusPreventionEffect
	AddMapField: StatusPrevent: 
		return !caster.hasAbility(AbilityNamesies.INFILTRATOR);
		###
	AddMapField: StatusPreventMessage: "{0} protects " + victim.getName() + " from status conditions!"
*
UsedProof:
	AddMapField: CanHave: True
	AddMapField: Cast: 
		if (!victim.hasEffect(this.namesies)) {
			super.cast(b, caster, victim, source, printCast);
		}
		else {
			Messages.add(getCastMessage(b, caster, victim, source));
		}
		###
*
Cast:
	Header: void cast(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source, boolean printCast)
*
CastMessage:
	Header: String getCastMessage(Battle b, ActivePokemon user, ActivePokemon victim, CastSource source)
	Body:
		return {0};
		###
*
SubsideMessage:
	Header: String getSubsideMessage(ActivePokemon victim)
	Body:
		return {0};
		###
*
WeightBased:
	AddMapField: GetPow: 
		double weight = {0}.getWeight(b);
		if (weight < 22) return 20;
		if (weight < 55) return 40;
		if (weight < 110) return 60;
		if (weight < 220) return 80;
		if (weight < 440) return 100;
		return 120;
		###
*
WeightRatio:
	AddMapField: GetPow: 
		double ratio = {1}.getWeight(b)/{2}.getWeight(b);
		if (ratio > .5) return 40;
		if (ratio > .33) return 60;
		if (ratio > .25) return 80;
		if (ratio > .2) return 100;
		return 120;
		###
*
StatRatio:
	AddMapField: GetPow: 
		double ratio = (double)Stat.getStat(Stat.{11}, {2}, {3}, b)/Stat.getStat(Stat.{11}, {3}, {2}, b);
		if (ratio > .5) return 60;
		if (ratio > .33) return 80;
		if (ratio > .25) return 120;
		return 150;
		###
*
RapidSpin:
	Header: void releaseRapidSpin(Battle b, ActivePokemon releaser)
	Body:
		Messages.add({0});
		
		// This is a little hacky and I'm not a super fan but I don't feel like distinguishing in the generator if this a PokemonEffect or a TeamEffect, so just try to remove from both list
		releaser.getEffects().remove(this);
		b.getEffects(releaser).remove(this);
		###
*
ChangeStat:
	Header: int modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s, int stat)
*
ModifyStat:
	Header: double modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s)
*
SimpleGetModifier:
	Header: double getModifier()
	Body: return {0};
*	
SimpleModifier:
	AddMapField: SimpleGetModifier: {1}
	AddInterface: SimpleStatModifyingEffect
*
ModifyMultiplier:
	AddMapField: SimpleModifier: {1}
	AddMapField: CanModify: {2-}
*
CanModify:
	Header: boolean canModifyStat(Battle b, ActivePokemon p, ActivePokemon opp)
	Body: return {0};
*
TwoModify:
	Header: boolean isModifyStat(Stat s)
	Body:
		return s == Stat.{11} || s == Stat.{22};
		###
*
ToModify:
	Header: boolean isModifyStat(Stat s)
	Body:
		return s == Stat.{00};
		###
*
GetForceMove:
	Header: Move getForcedMove()
*
Subside:
	Header: void subside(Battle b, ActivePokemon p)
*
Usable:
	Header: boolean usable(Battle b, ActivePokemon p, Move m)
*
UnusableMessage:
	Header: String getUnusableMessage(Battle b, ActivePokemon p)
	Body: 
		return {0};
		###
*
OpponentUsable:
*
ShouldSubside:
	Header: boolean shouldSubside(Battle b, ActivePokemon victim)
*
Enter:
	Header: void enter(Battle b, ActivePokemon enterer)
*
GetChangeTypeEffect:	
	Header: Type[] getType(Battle b, ActivePokemon p, boolean display)
*
GetNameChange:
	Header: String getNameChange()
*
SetNameChange:
	Header: void setNameChange(Battle b, ActivePokemon victim)
*
AbilityIsActive:
	Header: boolean isActive()
*
EffectIsActive:
	Header: boolean isActive(Battle b)
*
Deactivate:
	Header: void deactivate(Battle b, ActivePokemon victim)
*
GetTurns:
	Header: int getTurns()
*
StatusPrevent:
	Header: boolean preventStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusCondition status)
*
StatusPreventMessage:
	Header: String statusPreventionMessage(ActivePokemon victim)
	Body:
		return {0};
		###
*
PowerMultiplierCondition:
	AddMapField: GetMultiplier:
		return {2-} ? {1} : 1;
		###
*
GetMultiplier:
	AddInterface: PowerChangeEffect
	Header: double getMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
*
GetOppMultiplier:
	Header: double getOpponentMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
*
ValidMove:
	Header: boolean validMove(Battle b, ActivePokemon user, ActivePokemon victim)
*
StatProtect:
	AddMapField: StatProtectingEffect: {0}
	AddMapField: StatProtectMessage:
		return p.getName() + "'s " + this.getName() + " prevents its " + s.getName().toLowerCase() + " from being lowered!";
		###
*
StatProtectingEffect:
	Header: boolean prevent(Battle b, ActivePokemon caster, ActivePokemon victim, Stat stat)
*
StatProtectMessage:
	Header: String preventionMessage(ActivePokemon p, Stat s)
*
Sporty:
	AddMapField: PowerMultiplierCondition: .33 user.getAttackType() == Type.{11}
	AddMapField: CastMessage: "{2}'s power was weakened!"
	AddMapField: MinTurns: 5
	AddMapField: MaxTurns: 5
	AddMapField: SubsideMessage: "The effects of {3} Sport wore off."
*
SpecialRoom:
	AddMapField: MinTurns: 5
	AddMapField: MaxTurns: 5
	AddMapField: SubsideMessage: "The dimensions of the {1} room returned to normal."
	AddMapField: CastMessage: user.getName() + " twisted the dimensions to {2-}!"
	AddMapField: CanHave: True
	AddMapField: Cast: 
		Effect roomsies = Effect.getEffect(b.getEffects(), this.namesies);
		if (roomsies == null) {
			super.cast(b, caster, victim, source, printCast);
			return;
		}
	
		// Remove the effect if it's already in play
		Messages.add(roomsies.getSubsideMessage(caster));
		Effect.removeEffect(b.getEffects(), this.namesies);
		###
*
MoveTypePrevent:
	AddInterface: AttackBlocker
	AddMapField: Block:
		return user.getAttack().isMoveType(MoveType.{11});
		###
	AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " prevents {2-}!"
*
DeathWish:
	Header: void deathWish(Battle b, ActivePokemon dead, ActivePokemon murderer)
	AccessModifier: Private
	AddInterface: StatusReceivedEffect
	AddMapField: StatusReceived:
		if (statusType == StatusCondition.FAINTED) {
			ActivePokemon murderer = b.getOtherPokemon(victim);
			
			// Only grant death wish if murdered through direct damage
			if (murderer.getAttributes().isAttacking()) {
				// DEATH WISH GRANTED
				deathWish(b, victim, murderer);
			}
		}
		###
*
KillWish:
	Header: void killWish(Battle b, ActivePokemon dead, ActivePokemon murderer)
*
FailMessage:
	Header: String getFailMessage(Battle b, ActivePokemon user, ActivePokemon victim)
	End:
		
		return super.getFailMessage(b, user, victim);
		###
*
Defog:
	Header: void releaseDefog(Battle b, ActivePokemon victim)
	Body:
		Messages.add({0});
		
		// This is a little hacky and I'm not a super fan but I don't feel like distinguishing in the generator if this a PokemonEffect or a TeamEffect, so just try to remove from both lists
		victim.getEffects().remove(this);
		b.getEffects(victim).remove(this);
		###
*
GetAbility:
	Header: Ability getAbility()
*
GetItem:
	Header: Item getItem()
*
Bracing:
	Header: boolean isBracing(Battle b, ActivePokemon bracer, boolean fullHealth)
*
BraceMessage:
	Header: String braceMessage(ActivePokemon bracer)
	Body:
		return {0};
		###
*
GetMoveList:
	Header: List<Move> getMoveList(List<Move> actualMoves)
*
GetStat:
	Header: Integer getStat(ActivePokemon user, Stat stat)
*
IncreaseCritStage:
	Header: int increaseCritStage(int stage, ActivePokemon p)
*
FallMessage:
	Header: void fall(Battle b, ActivePokemon fallen)
	Body:
		Messages.add({0});
		
		// TODO: Fix this it's broken
		// Effect.removeEffect(fallen.getEffects(), this.namesies());
		###
*
Terrain:
	AddMapField: Cast:
		// Remove all other Terrain Effects
		for (int i = 0; i < b.getEffects().size(); i++) {
			Effect effect = b.getEffects().get(i);
			if (effect instanceof TerrainEffect) {
				b.getEffects().remove(i);
				i--;
			}
		}
		
		super.cast(b, caster, victim, source, printCast);
		b.setTerrainType(TerrainType.{00}, false);
		###
	AddMapField: Subside:
		super.subside(b, p);
		b.resetTerrain();
		###
	AddMapField: MinTurns: 5
	AddMapField: MaxTurns: 5
*
EndBattle:
	Header: void afterBattle(Trainer player, Battle b, ActivePokemon p)
*
Contact:
	Header: void contact(Battle b, ActivePokemon user, ActivePokemon victim)
*
SelfBlock:
	Header: boolean block(Battle b, ActivePokemon user)
*
SelfAlternateEffect:
	Header: void alternateEffect(Battle b, ActivePokemon user)
*
SelfBlockMessage:
	Header: String getBlockMessage(Battle b, ActivePokemon user)
*
Block:
	Header: boolean block(Battle b, ActivePokemon user, ActivePokemon victim)
*
AlternateEffect:
	Header: void alternateEffect(Battle b,  ActivePokemon user, ActivePokemon victim)
*
BlockMessage:
	Header: String getBlockMessage(Battle b, ActivePokemon user, ActivePokemon victim)
	Body:
		return {0};
		###
*
BlockType:
	AddInterface: AttackBlocker
	AddMapField: Block:
		return user.getAttackType() == Type.{00};
		###
	AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " makes it immune to " + Type.{00}.getName() + " type moves!"
	AddMapField: AlternateEffect:
		victim.getAttributes().modifyStage(victim, victim, 1, toIncrease(), b, CastSource.ABILITY);
		###
*
AbsorbType:
	AddInterface: AttackBlocker
	AddMapField: Block:
		return user.getAttackType() == Type.{00};
		###
	AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " makes it immune to " + Type.{00}.getName() + " moves!"
	AddMapField: AlternateEffect: 
		// Technically, according to the description, Heal Block prevents the prevention entirely (meaning this should be in Block), but that makes no sense, they shouldn't take damage, this way makes more sense
		if (victim.fullHealth() || victim.hasEffect(EffectNamesies.HEAL_BLOCK)) {
			return;
		}
		
		victim.healHealthFraction(1/4.0);
		Messages.add(new MessageUpdate(victim.getName() + "'s HP was restored instead!").updatePokemon(b, victim));
		###
*
EndTurnStatusCure:
	AddInterface: EndTurnEffect
	AddMapField: ApplyEndTurn: 
		if (victim.hasStatus() && {0}) {
			Status.removeStatus(b, victim, CastSource.ABILITY);
		}
		###
*
PinchAbility:
	AddMapField: PowerMultiplierCondition: 1.5 user.getHPRatio() < 1/3.0 && user.getAttackType() == Type.{00}
*
StatusPreventAbility:
	AddInterface: StatusPreventionEffect
	AddMapField: StatusPrevent: 
		return status == StatusCondition.{11};
		###
	AddMapField: StatusPreventMessage: victim.getName() + "'s " + this.getName() + " prevents {2}!"
	AddMapField: Field:
		private void removeStatus(Battle b, ActivePokemon victim) {
			if (victim.hasStatus(StatusCondition.{11})) {
				Status.removeStatus(b, victim, CastSource.ABILITY);
			}
		}
		###
	AddInterface: EntryEffect
	AddInterface: EndTurnEffect
	AddMapField: Enter: 
		removeStatus(b, enterer);
		###
	AddMapField: ApplyEndTurn: 
		removeStatus(b, victim);
		###
*
StatusContact:
	AddMapField: Contact: 
		if (RandomUtils.chanceTest(30)) {
			Status.giveStatus(b, victim, user, StatusCondition.{00}, true);
		}
		###
	AddInterface: PhysicalContactEffect
*
SpeedWeather:
	AddMapField: ToModify: Speed
	AddMapField: ModifyMultiplier: 2 b.getWeather().namesies() == EffectNamesies.{00}
*
WeatherStarter:
	AddInterface: EntryEffect
	AddMapField: Enter: 
		b.addEffect((Weather)EffectNamesies.{11}.getEffect());
		Messages.add(enterer.getName() + "'s " + this.getName() + " {2-}!");
		###
*
WeatherEvasion:
	AddInterface: StageChangingEffect
	AddMapField: StageChange: 
		return s == Stat.EVASION && b.getWeather().namesies() == EffectNamesies.{00} ? 1 : 0;
		###
*
WeatherEliminate:
	AddInterface: EntryEffect
	AddMapField: Enter: 
		// TODO: I think this isn't the intended effect of this ability
		b.addEffect((Weather)EffectNamesies.CLEAR_SKIES.getEffect());
		Messages.add(enterer.getName() + "'s " + this.getName() + " eliminated the weather!");
		###
*
HalfAmount:
	Header: int getHalfAmount(int halfAmount)
	Body:
		return halfAmount + {0};
		###
*
WeatherBlock:
	Header: boolean block(EffectNamesies weather)
*
OnApplyDamage:
	Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, int damage)
*
OpponentApplyDamage:
	Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, int damage)
*
ModifyStageValue:
	Header: int modifyStageValue(int modVal)
*
SwitchOut:
	Header: void switchOut(ActivePokemon switchee)
*
OnTakeDamage:
	Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
*
OpponentTakeDamage:
	Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
*
Fling:
	AddMapField: FlingDamage:
		return {0};
		###
*
FlingDamage:
	Header: int flingDamage()
*
FlingEffect:
	Header: void flingEffect(Battle b, ActivePokemon pelted)
*
FullItemUse:
	Header: boolean use(Battle b, ActivePokemon p, Move m)
*
PlayerUse:
	Header: boolean use()
*
PokemonUse:
	Header: boolean use(ActivePokemon p)
*
BattleUse:
	Header: boolean use(ActivePokemon p, Battle b)
*
MoveUse:
	Header: boolean use(ActivePokemon p, Move m)
*
IncreaseStat:
	Header: Stat toIncrease()
	AccessModifier: Private
	Body:
		return Stat.{00};
		###
*
TypeTakeDamageStatIncrease:
	AddMapField: OnTakeDamage:
		if (user.getAttackType() == Type.{11} && victim.getAttributes().modifyStage(victim, victim, 1, Stat.{22}, b, CastSource.HELD_ITEM)) {
			victim.consumeItem(b);
		}
		###
	AddInterface: ConsumableItem
	AddInterface: TakeDamageEffect
*
ChoiceItem:
	AddMapField: ToModify: {0}
	AddMapField: SimpleModifier: 1.5
	AddInterface: AttackSelectionEffect
	AddMapField: Usable:
		Move last = p.getAttributes().getLastMoveUsed();
		return last == null || m == last;
		###
	AddMapField: UnusableMessage: p.getName() + "'s " + super.name + " only allows " + p.getAttributes().getLastMoveUsed().getAttack().getName() + " to be used!"
	AddInterface: HoldItem
	AddMapField: Fling: 10
*
Wing:
	AddMapField: EVIncreaseAmt: {0}
	AddMapField: Price: 3000
	AddInterface: Wing
*
Vitamin:
	AddMapField: EVIncreaseAmt: {0}
	AddMapField: Price: 9800
	AddInterface: Vitamin
*
RepelEffectItem:
	AddInterface: RepellingEffect
	Header: boolean shouldRepel(ActivePokemon attacking, WildEncounter wildPokemon)
	Body:
		return RandomUtils.chanceTest(1, 3) && wildPokemon.getLevel() <= attacking.getLevel();
		###
*
TypedWildEncounterSelector:
	AddInterface: TypedWildEncounterSelector
	Header: Type getType()
	Body:
		return Type.{00};
		###
*
EncounterRateMultiplier:
	AddInterface: EncounterRateMultiplier
	Header: double getMultiplier()
	Body:
		return {0};
		###
*
WeatherEncounterRateDecreaser:
	AddMapField: EncounterRateMultiplier: Game.getPlayer().getArea().getWeather() == WeatherState.{00} ? .5 : 1
*
BuffetImmune:
	AddMapField: Field:
		private static final Type[] immunees = new Type[] { {0} };
		###
*
BuffetMessage:
	AddMapField: Field:
		private void buffet(Battle b, ActivePokemon p) {
			// Don't buffet the immune!
			for (Type type : immunees) {
				if (p.isType(b, type)) {
					return;
				}
			}
			
			// Srsly don't buffet the immune!!
			if (WeatherBlockerEffect.checkBlocked(b, p, this.namesies)) {
				return;
			}

			// Buffety buffety buffet
			Messages.add({0});
			p.reduceHealthFraction(b, 1/16.0);
		}
		###
*
PreBuffetMessage:
	AddMapField: ApplyEndTurn:
		Messages.add({0});
				
		ActivePokemon other = b.getOtherPokemon(victim);
		buffet(b, victim);
		buffet(b, other);
		###
*
WeatherStatChange:
	AddMapField: GetMultiplier:
		if (user.isAttackType(Type.{11})) {
			// {1} is fiddy percent stronger in tha weathz
			return 1.5;
		}
		else if (user.isAttackType(Type.{22})) {
			// {2} is fiddy percent weaker in tha weathz
			return .5;
		}
		else {
			return 1;
		}
		###
*
WeatherType:
	Header: EffectNamesies getWeatherType()
	Body:
		return EffectNamesies.{00};
		###
*
GetEVs:
	Header: int[] getEVs(int[] vals)
*
TargetSwap:
	Header: boolean swapTarget(Battle b, ActivePokemon user, ActivePokemon opponent)
*
MagicReflection:
	AddInterface: TargetSwapperEffect
	AddMapField: TargetSwap:
		Attack attack = user.getAttack();
		if (!attack.isSelfTarget() && attack.isStatusMove() && !attack.isMoveType(MoveType.NO_MAGIC_COAT)) {
			Messages.add(opponent.getName() + "'s " + {0} + " reflected " + user.getName() + "'s move!");
			return true;
		}
		
		return false;
		###
*
PowerStat:
	Header: Stat powerStat()
	Body:
		return Stat.{00};
		###
	AddMapField: ToModify: Speed
	AddMapField: SimpleModifier: .5
	AddMapField: GetEVs:
		vals[powerStat().index()] += 4;
		return vals;
		###
	AddMapField: Fling: 70
	AddMapField: Price: 3000
	AddMapField: Cat: Misc
*
TypeEnhance:
	AddMapField: PowerMultiplierCondition: 1.2 user.isAttackType(Type.{00})
	AddInterface: HoldItem
	AddMapField: Cat: Misc
*
PPIncrease:
	AddMapField: MoveUse:
		if (m.increaseMaxPP({0})) {
			Messages.add(p.getName() + "'s " + m.getAttack().getName() + "'s Max PP was increased!");
			return true;
		}
		
		return false;
		###
	AddInterface: MoveUseItem
	AddInterface: HoldItem
	AddMapField: Cat: Stat
*
Ether:
	AddMapField: BattleCat: HP_PP
	AddInterface: PPHealer
	AddMapField: PPRestoreAmount:
		return {0};
		###
*
PPRestoreAmount:
	Header: int restoreAmount(Move toRestore)
*
AllPPRestoreAmount:
	Header: int restoreAmount(Move toRestore)
*
Elixir:
	AddInterface: AllPPHealer
	AddMapField: AllPPRestoreAmount:
		return {0};
		###
	AddInterface: HoldItem
	AddMapField: Cat: Medicine
	AddMapField: BattleCat: HP_PP
*
TimeSpaceOrb:
	AddMapField: Fling: 60
	AddMapField: Price: 10000
	AddInterface: HoldItem
	AddMapField: Cat: Misc
	AddMapField: PowerMultiplierCondition: 1.2 user.isPokemon(PokemonNamesies.{11}) && (user.isAttackType(Type.DRAGON) || user.isAttackType(Type.{22}))
*
SpecialItemAbility:
	AddInterface: ChangeTypeEffect
	AddMapField: GetChangeTypeEffect:
		Item item = p.getHeldItem(b);
		if (item instanceof {0}) {
			return new Type[] { (({0})item).getType(), Type.NO_TYPE };
		}
		
		return p.getActualType();
		###
	AddMapField: Irrestealable: True
	AddMapField: Irreplaceable: True
*
SpecialItemMove:
	AddMapField: Type: Normal
	AddMapField: MoveType: Metronomeless
	AddMapField: GetType: 
		Item item = user.getHeldItem(b);
		if (item instanceof {0}) {
			return (({0})item).getType(); 
		}
		
		return super.type;
		###
*
SpecialTypeItem:
	Header: Type getType()
	Body:
		return Type.{00};
		###
	AddMapField: Cat: Misc
*
GemType:
	AddMapField: SpecialTypeItem: {0}
	AddMapField: Price: 100
*
PlateType:
	AddMapField: SpecialTypeItem: {0}
	AddMapField: Price: 1000
*
DriveType:
	AddMapField: SpecialTypeItem: {0}
	AddMapField: Price: 1000
*
MemoryType:
	AddMapField: SpecialTypeItem: {0}
	AddMapField: Price: 1000
*
EvolutionItem:
	AddInterface: PokemonUseItem
	AddMapField: PokemonUse:
		return p.checkEvolution(this.namesies);
		###
*
StatusHealAll:
	AddMapField: BattleCat: Status
	AddInterface: StatusHealer
	AddMapField: ShouldHealStatus:
		// Does not apply to the healthy and the dead
		return statusCondition != StatusCondition.NO_STATUS && statusCondition != StatusCondition.FAINTED;
		###
*
Revive:
	AddInterface: PokemonUseItem
	AddInterface: HoldItem
	AddMapField: Cat: Medicine
	AddMapField: BattleCat: Status
	AddMapField: PokemonUse:
		// Only applies to the dead
		if (!p.isActuallyDead()) {
			return false;
		}
		
		p.removeStatus();
		p.healHealthFraction({1});
		
		Messages.add(p.getName() + " was {2} revived!");
		
		return true;
		###
*
ShouldHealStatus:
	Header: boolean shouldHeal(StatusCondition statusCondition)
*
StatusRemove:
	AddInterface: StatusHealer
	AddMapField: ShouldHealStatus:
		return statusCondition == StatusCondition.{00};
		###
*
FixedHealAmount:
	Header: int getFixedHealAmount(ActivePokemon p)
*
GetAmountHealed:
	Header: int getAmountHealed(ActivePokemon p)
*
HealAmt:
	AddInterface: FixedHpHealer
	AddMapField: FixedHealAmount:
		return {0};
		###
	AddMapField: Cat: Medicine
	AddMapField: BattleCat: HP_PP
*
XStageIncrease:
	AddMapField: Cat: Stat
	AddMapField: BattleCat: Battle
	AddInterface: HoldItem
	AddInterface: BattleUseItem
	AddMapField: BattleUse:
		return p.getAttributes().modifyStage(p, p, 1, Stat.{00}, b, CastSource.USE_ITEM);
		###
*
EVIncrease:
	Header: Stat toIncrease()
	Body:
		return Stat.{00};
		###
*
EVIncreaseAmt:
	AddMapField: EVIncrease: {0}
	AddMapField: Cat: Stat
*
CatchRateCondition:
	AddMapField: BallItem: True
	AddMapField: CatchRate:
		return {2-} ? {1} : 1;
		###
*
FixedCatchRate:
	AddMapField: BallItem: True
	AddMapField: CatchRate:
		return {0};
		###
*
BallItem:
	AddInterface: BallItem
	AddMapField: Cat: Ball
	AddMapField: BattleCat: Ball
*
CatchRate:
	Header: double getModifier(ActivePokemon me, ActivePokemon o, Battle b)
*
AdditiveCatch:
	Header: int getAdditive(ActivePokemon me, ActivePokemon o, Battle b)
*
AfterCaught:
	Header: void afterCaught(ActivePokemon p)
*
EVDecreaseBerry:
	AddMapField: DecreaseEVs:
		return Stat.{00};
		###
	AddInterface: EvDecreaseBerry
*
DecreaseEVs:
	Header: Stat toDecrease()
*
SuperEffectivePowerReduceBerry:
	AddMapField: HiddenBerry: True 
	AddInterface: SuperEffectivePowerReduceBerry
	AddMapField: SuperDuperEffectivePowerReduceBerry:
		return Type.{00};
		###
*
SuperDuperEffectivePowerReduceBerry:
	Header: Type getType()
*
HealthTriggeredStageIncreaseBerryField:
	Header: Stat getStat()
*
HealthTriggeredStageIncreaseBerry:
	AddInterface: HealthTriggeredStageIncreaseBerry
	AddMapField: HealthTriggeredStageIncreaseBerryField: 
		return Stat.{00};
		###
*
CategoryIncreaseBerry:
	AddMapField: NGPow: 100
	AddInterface: Berry
	AddInterface: TakeDamageEffect
	AddMapField: OnTakeDamage:
		if (user.getAttack().getCategory() == MoveCategory.{11} && victim.getAttributes().modifyStage(victim, victim, 1, Stat.{22}, b, CastSource.HELD_ITEM)) {
			victim.consumeItem(b);
		}
		###
*
CategoryDamagerBerry:
	AddMapField: NGPow: 100
	AddInterface: Berry
	AddInterface: OpponentApplyDamageEffect
	AddMapField: OpponentApplyDamage:
		if (user.getAttack().getCategory() == MoveCategory.{00}) {
			Messages.add(user.getName() + " was hurt by " + victim.getName() + "'s " + this.name + "!");
			user.reduceHealthFraction(b, 1/8.0);
			victim.consumeItem(b);
		}
		###
*
HealPartyStatus:
	AddMapField: UniqueEffects:
		for (ActivePokemon p : b.getTrainer(user).getTeam()) {
			if (!p.isActuallyDead()) {
				p.removeStatus();
			}
		}
		
		Messages.add("All status problems were cured!");
		###
	AddMapField: SelfTarget: True
*
RemoveAdvantageType:
	AddInterface: NoAdvantageChanger
	AddMapField: NegateNoAdvantage: defending == Type.{11} && ({2-})
*
ForesightEffect:
	AddMapField: CastMessage: user.getName() + " identified " + victim.getName() + "!"
	AddMapField: CanHave: True
	AddMapField: UsedProof: True
	AddMapField: RemoveAdvantageType: {0}
*
ForesightMove:
	AddMapField: Effect: {0}
	AddMapField: UniqueEffects: 
		victim.getAttributes().resetStage(Stat.EVASION);
		###
	AddMapField: MoveType: Substitute_Piercing
*
AddTypeMove:
	AddMapField: Effect: ChangeType
	AddMapField: ChangeType:
		Type primary = victim.getType(b)[0];
				
		return new Type[] { primary, primary == Type.{00} ? Type.NO_TYPE : Type.{00} };
		###
*
PrintFail:
	Header: boolean canPrintFail()
	Body:
		return {0};
		###
*
FutureAttackMove:
	AddMapField: Effect: {0}
	AddMapField: ShouldApplyDamage:
		// Don't apply damage just yet!!
		return false;
		###
	AddMapField: PrintFail: true
*
FutureAttackEffect:
	AddMapField: MinTurns: 2
	AddMapField: MaxTurns: 2
	AddMapField: NextTurnSubside: True
	AddMapField: Field: 
		private ActivePokemon theSeeer;
		###
	AddMapField: Subside: 
		Messages.add(p.getName() + " took " + theSeeer.getName() + "'s attack!");
			
		Attack attack = AttackNamesies.{00}.getAttack();
		
		// Don't do anything for moves that are uneffective
		if (!attack.effective(b, theSeeer, p)) {
			return;
		}
		
		theSeeer.setMove(new Move(attack));
		theSeeer.getAttack().applyDamage(theSeeer, p, b);
		###
	AddMapField: Cast: 
		theSeeer = caster;
		super.cast(b, caster, victim, source, printCast);
		###
	AddMapField: CastMessage: theSeeer.getName() + " foresaw an attack!"
*
EliminateStatChanges:
	AddMapField: UniqueEffects: 
		user.getAttributes().resetStages();
		victim.getAttributes().resetStages();
		Messages.add("All stat changes were eliminated!");
		###
*
StatSwapMove:
	AddMapField: Field:
		private static final Stat[] swapStats = { Stat.{11}, Stat.{22} };
		###
	AddMapField: UniqueEffects: 
		for (Stat s : swapStats) {
			user.getAttributes().swapStages(s, victim);
		}
		
		Messages.add(user.getName() + " swapped its stats with " + victim.getName() + "!");
		###
	AddMapField: MoveType: No_Magic_Coat
*
GainEffect:
	Header: boolean gainBerryEffect(Battle b, ActivePokemon user, CastSource source)
*
FixedBerryHealthTrigger:
	AddInterface: HealthTriggeredBerry
	AddMapField: HealthTriggerRatio:
		return 1/{0}.0;
		###
*
HealthTriggerRatio:
	Header: double healthTriggerRatio()
*
NGPow:
	AddMapField: NaturalGiftPower:
		return {0};
		###
*
NGType:
	AddMapField: HiddenBerry: True
	AddMapField: NaturalGiftType:
		return Type.{00};
		###
*
HiddenBerry:
	AddMapField: Cat: Berry
	AddMapField: Price: 20
*
NaturalGiftPower:
	Header: int naturalGiftPower()
*
NaturalGiftType:
	Header: Type naturalGiftType()
*
RepelSteps:
	Header: int repelSteps()
	Body: return {0};
	AddMapField: Cat: Misc
*
BlockCrits:
	Header: boolean blockCrits()
*
PowderResist:
	AddInterface: AttackBlocker
	AddMapField: Block:
		return user.getAttack() instanceof PowderMove;
		###
	AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " protects it from powder moves!"
*
NegateNoAdvantage:
	Header: boolean negateNoAdvantage(Type attacking, Type defending)
	Body:
		return {0};
		###
*
MultiplyAdvantage:
	Header: double multiplyAdvantage(Type attackingType, Type[] defendingTypes)
*
SuperEffectiveAdvantageType:
	AddInterface: AdvantageMultiplierMove
	AddMapField: MultiplyAdvantage:
		double multiplier = 1;
		for (Type defendingType : defendingTypes) {
			if (defendingType == Type.{00}) {
				multiplier *= 2/attackingType.getAdvantage().getAdvantage(defendingType);
			}
		}
		
		return multiplier;
		###
*
GetPow:
	Header: int getPower(Battle b, ActivePokemon me, ActivePokemon o)
*
ApplyDamage:
	Header: void applyDamage(ActivePokemon me, ActivePokemon o, Battle b)
*
GetAccuracy:
	Header: int getAccuracy(Battle b, ActivePokemon me, ActivePokemon o)
*
Aura:
	AddMapField: GetMultiplier:
		if (user.getAttackType() == Type.{00}) {
			return 1 + .33*(victim.hasAbility(AbilityNamesies.AURA_BREAK) ? -1 : 1);
		}
		
		return 1;
		###
*
RaiseAllStats:
	AddMapField: StatChange: 7 Attack 1 Defense 1 Sp_Attack 1 Sp_Defense 1 Speed 1 Accuracy 1 Evasion 1
*
ConsumeBerry:
	AddMapField: UniqueEffects: 
		user.stealBerry(b, victim);
		###
*
GenericMessage:
	Header: String getGenericMessage(ActivePokemon p)
	Body:
		return {0};
		###
*
SourceMessage:
	Header: String getSourceMessage(ActivePokemon p, String sourceName)
	Body:
		return {0};
		###
*
ChangeAttackType:
	Header: Type changeAttackType(Attack attack, Type original)
*
NormalTypeChanger:
	Header: Type getType()
	Body:
		return Type.{00};
		###
	AddInterface: ChangeAttackTypeEffect
	AddMapField: ChangeAttackType:
		if (original == Type.NORMAL) {
			this.activated = true;
			return getType();
		}
		
		return original;
		###
	AddMapField: Field:
		private boolean activated;
		###
	AddMapField: Activate:
		this.activated = false;
		###
	AddInterface: EndTurnEffect
	AddMapField: ApplyEndTurn:
		this.activated = false;
		###
	AddMapField: PowerMultiplierCondition: 1.3 activated
*
NextLevel:
	Header: void takeItToTheNextLevel(Battle b, ActivePokemon caster, ActivePokemon victim)
	Body:
		victim.getAttributes().modifyStage(victim, victim, 2, Stat.{00}, b, CastSource.@SuperClass);
		###
*
FlinchItem:
	AddMapField: FlingEffect:
		if (EffectNamesies.FLINCH.getEffect().apply(b, pelted, pelted, CastSource.USE_ITEM, false)) {
			Messages.add("The " + this.name + " caused " + pelted.getName() + " to flinch!");
		}
		###
	AddMapField: OpponentTakeDamage:
		if (RandomUtils.chanceTest(10)) {
			if (EffectNamesies.FLINCH.getEffect().apply(b, user, victim, CastSource.HELD_ITEM, false)) {
				Messages.add(user.getName() + "'s " + this.name + " caused " + victim.getName() + " to flinch!");
			}
		}
		###
	AddInterface: OpponentTakeDamageEffect
	AddInterface: HoldItem
*
StatusFling:
	AddMapField: FlingEffect:
		Status.giveStatus(b, pelted, pelted, StatusCondition.{00}, pelted.getName() + " was {0} by the " + this.name + "!");
		###
*
TM:
	Header: AttackNamesies getAttack()
	Body:
		return AttackNamesies.{0};
		###
	AddMapField: Cat: TM
*
ChangePriorityAbility:
	AddInterface: PriorityChangeEffect
	AddMapField: ChangePriority:
		return {0} ? 1 : 0;
		###
*
ChangePriority:
	Header: int changePriority(Battle b, ActivePokemon user, Attack attack)
*
Baby:
	Header: PokemonNamesies getBaby()
	Body:
		return PokemonNamesies.{00};
		###
*
AbsorbDamage:
	Header: boolean absorbDamage(Battle b, ActivePokemon damageTaker, int damageAmount)
*
DamageTaken:
	Header: void damageTaken(Battle b, ActivePokemon damageTaker)
*
SapPercentage:
	Header: double sapPercentage()
*
SapAmount:
	Header: int getSapAmount(ActivePokemon victim, int damageAmount)
*
SapMessage:
	Header: String getSapMessage(ActivePokemon victim)
*
ShouldCrit:
	Header: boolean shouldCrit(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
IgnoreAbilityMove:
	AddMapField: BeginAttack:
		EffectNamesies.BREAKS_THE_MOLD.getEffect().cast(b, attacking, attacking, CastSource.ATTACK, false);
		###
	AddMapField: EndAttack:
		user.getAttributes().removeEffect(EffectNamesies.BREAKS_THE_MOLD);
		###
*
StatusReceived:
	Header: void receiveStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusCondition statusType)
*
OppStatusReceived:
	Header: void receiveStatus(Battle b, ActivePokemon victim, StatusCondition statusType)
*
TheVeryEnd:
	AddInterface: SuperDuperEndTurnEffect
	Header: boolean theVeryVeryEnd(Battle b, ActivePokemon p)
*
PriorityPrevention:
	AddInterface: OpponentAttackSelectionBlockerEffect
	AddMapField: Usable: 
		return b.getPriority(p, m.getAttack()) <= 0;
		###
	AddMapField: UnusableMessage: b.getOtherPokemon(p).getName() + "'s " + this.getName() + " prevents priority moves!!"
*
OpponentEndAttack:
	Header: void endsies(Battle b, ActivePokemon attacking, Attack attack)
*
TerrainStarter:
	AddInterface: EntryEffect
	AddMapField: Enter:
		Messages.add(enterer.getName() + "'s " + this.getName() + " changed the field to {0} Terrain!");
		EffectNamesies.{00}_TERRAIN.getEffect().cast(b, enterer, enterer, CastSource.ABILITY, false);
		###
*
MoldBreakerBreaker:
	Header: boolean unbreakableMold()
	Body:
		// Ability is not ignored even when the opponent breaks the mold
		return true;
		###
*
Irreplaceable:
	Header: boolean isReplaceable()
	Body:
		return false;
		###
*
Irrestealable:
	Header: boolean isStealable()
	Body:
		return false;
		###
*
DropBelowHalfHealth:
	AddInterface: TakeDamageEffect
	AddMapField: OnTakeDamage:
		if (victim.getHPRatio() < .5 && (victim.getHP() + victim.getAttributes().getDamageTaken())/(double)victim.getMaxHP() >= .5) {
			{0}
		}
		###
*
WildPokemonAlterer:
	Header: void alterWildPokemon(ActivePokemon attacking, ActivePokemon wildPokemon, WildEncounter encounterData)
	AddInterface: WildEncounterAlterer
*
NewTerrain:
	Header: void newTerrain(Battle b, ActivePokemon p, TerrainType newTerrain)
*
TerrainSeed:
	AddInterface: ConsumableItem
	AddInterface: TerrainCastEffect
	AddMapField: NewTerrain:
		if (newTerrain == TerrainType.{11} && p.getAttributes().modifyStage(p, p, 1, Stat.{22}, b, CastSource.HELD_ITEM)) {
			p.consumeItem(b);
		}
		###
	AddMapField: Comments: // TODO: Still have not confirmed fling damage
	AddMapField: Price: 4000
	AddMapField: Cat: Misc
*
FormChange:
	AddMapField: Irrestealable: True
	AddMapField: Irreplaceable: True
	AddMapField: Field:
		private static final int[] {33}_STATS = new int[] { {4}, {5}, {6}, {7}, {8}, {9} };
		private static final int[] {1010}_STATS = new int[] { {11}, {12}, {13}, {14}, {15}, {16} };
		
		private boolean {1};
		private int[] getStats() {
			return {1} ? {1010}_STATS : {33}_STATS;
		}
		###
	AddMapField: Activate:
		this.{1} = {2};
		###
	AddInterface: DifferentStatEffect
	AddMapField: GetStat:
		// Need to calculate the new stat -- yes, I realize this is super inefficient and whatever whatever whatever
		int index = stat.index();
		return Stat.getStat(index, user.getLevel(), getStats()[index], user.getIV(index), user.getEV(index), user.getNature().getNatureVal(index));
		###
*
EndTurnFormChange:
	Header: boolean formCheck(ActivePokemon formsie)
	AccessModifier: Private
	Body:
		return {17-};
		###
	AddMapField: FormChange: {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12} {13} {14} {15} {16}
	AddInterface: EndTurnEffect
	AddInterface: EntryEffect
	AddMapField: Enter:
		if (formCheck(enterer)) {
			{1} = true;
			Messages.add(enterer.getName() + " changed into {10} Forme!");
		}
		else {
			{1} = false;
			Messages.add(enterer.getName() + " changed into {3} Forme!");
		}
		###
	AddMapField: ApplyEndTurn:
		if (formCheck(victim)) {
			if (!{1}) {
				{1} = true;
				Messages.add(victim.getName() + " changed into {10} Forme!");	
			}
		}
		else if ({1}){
			{1} = false;
			Messages.add(victim.getName() + " changed into {3} Forme!");
		}
		###
*
GET_DAT_CASH_MONEY_TWICE_ITEM:
	Header: void getDatCashMoneyGetDatCashMoneyCast(Battle b, ActivePokemon gettinDatCashMoneyTwice)
	AccessModifier: Private
	Body:
		EffectNamesies.GET_DAT_CASH_MONEY_TWICE.getEffect().cast(b, gettinDatCashMoneyTwice, gettinDatCashMoneyTwice, CastSource.HELD_ITEM, false);
		###
	AddInterface: EntryEffect
	AddMapField: Enter:
		getDatCashMoneyGetDatCashMoneyCast(b, enterer);
		###
	AddInterface: EndTurnEffect
	AddMapField: ApplyEndTurn:
		getDatCashMoneyGetDatCashMoneyCast(b, victim);
		###
*
