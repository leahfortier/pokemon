BeginAttack:
    Header: void beginAttack(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
UniqueEffects:
    Header: void uniqueEffects(Battle b, ActivePokemon user, ActivePokemon victim)
*
EndAttack:
    Header: void endAttack(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
AfterApplyCheck:
    Header: void afterApplyCheck(Battle b, ActivePokemon user, ActivePokemon victim)
*
ShouldApplyDamage:
    Header: boolean shouldApplyDamage(Battle b, ActivePokemon user)
*
ShouldApplyEffects:
    Header: boolean shouldApplyEffects(Battle b, ActivePokemon user, ActivePokemon victim)
*
FixedDamage:
    Header: int getFixedDamageAmount(ActivePokemon me, ActivePokemon o)
    Body:
        return {0};
        ###
    AddInterface: FixedDamageMove
*
GetPriority:
    Header: int getPriority(Battle b, ActivePokemon me)
*
GetType:
    Header: Type getType(Battle b, ActivePokemon user)
*
# This is for attacks, not effects
FullApplies:
    Header: boolean applies(Battle b, ActivePokemon user, ActivePokemon victim)
*
Applies:
    AddMapField: FullApplies:
        return {0};
        ###
*
ExtraApplies:
    AddMapField: Applies: {0}
*
EffectApplies:
    AddMapField: TotalEffectApplies:
        return ApplyResult.newResult({0});
        ###
*
# Not totally sure why there's an extra space in between these two lines...
FullEffectApplies:
    AddMapField: TotalEffectApplies:
        {0}
        return ApplyResult.success();
        ###
*
TotalEffectApplies:
    Header: ApplyResult applies(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source)
*
StatusBaseApplies:
    Header: ApplyResult applies(Battle b, ActivePokemon user, ActivePokemon victim)
*
StatusApplies:
    Header: boolean statusApplies(Battle b, ActivePokemon caster, ActivePokemon victim)
    Body:
        return {0};
        ###
*
GenericCastMessage:
    Header: String getGenericCastMessage(ActivePokemon p)
    Body:
        return {0};
        ###
*
SourceCastMessage:
    Header: String getSourceCastMessage(ActivePokemon sourcerer, ActivePokemon victim, String sourceName)
    Body:
        return {0};
        ###
*
GenericRemoveMessage:
    Header: String getGenericRemoveMessage(ActivePokemon victim)
    Body:
        return {0};
        ###
*
SourceRemoveMessage:
    Header: String getSourceRemoveMessage(ActivePokemon victim, String sourceName)
    Body:
        return {0};
        ###
*
SourcePreventionMessage:
    AddMapField: FullSourcePreventionMessage: victim.getName() + "'s " + sourceName + " prevents {0}!"
*
FullSourcePreventionMessage:
    Header: String getSourcePreventionMessage(ActivePokemon victim, String sourceName)
    Body:
        return {0};
        ###
*
IsStatusType:
    Header: boolean isType(StatusNamesies statusCondition)
*
PoisonCondition:
    AddMapField: ShortName: PSN
    AddMapField: CatchMod: 1.5
    AddMapField: Comments: // Poison-type and Steel-type Pokemon cannot be poisoned unless the caster has the Corrosion ability
    AddMapField: StatusApplies: (!victim.isType(b, Type.POISON, Type.STEEL) || caster.hasAbility(AbilityNamesies.CORROSION))
    AddMapField: GenericRemoveMessage: victim.getName() + " is no longer poisoned!"
    AddMapField: SourceRemoveMessage: victim.getName() + "'s " + sourceName + " cured it of its poison!"
    AddMapField: SourcePreventionMessage: poison
    AddInterface: EndTurnEffect
    AddMapField: ApplyEndTurn:
        if (victim.hasAbility(AbilityNamesies.POISON_HEAL)) {
            victim.healHealthFraction(1/8.0, b, victim.getName() + "'s " + AbilityNamesies.POISON_HEAL.getName() + " restored its health!");
        } else {
            victim.reduceHealthFraction(b, {0}, victim.getName() + " was hurt by its poison!");
        }
        ###
*
Recoil:
    Header: void applyRecoil(Battle b, ActivePokemon user)
    AddInterface: RecoilMove
*
RecoilPercentage:
    AddInterface: RecoilPercentageMove
    Header: int getDamagePercentageDenominator()
    Body:
        return {0};
        ###
*
StatusFang:
    AddMapField: EffChance: 20
    AddMapField: MoveType: Biting
    AddMapField: BeginAttack:
        super.status = StatusNamesies.NO_STATUS;
        super.effect = null;

        // If the effect is being applied, 50/50 chance to give a status condition vs. flinching
        if (RandomUtils.chanceTest(50)) {
            super.status = StatusNamesies.{00};
        } else {
            super.effect = PokemonEffectNamesies.FLINCH;
        }
        ###
*
WeatherHeal:
    AddMapField: BasicHealing:
        switch (b.getWeather().namesies()) {
            case SUNNY:
                return 2/3.0;
            case HAILING:
            case RAINING:
            case SANDSTORM:
                return 1/4.0;
            default:
                return 1/2.0;
        }
        ###
*
HealFraction:
    AddMapField: BasicHealing:
        return {0};
        ###
*
BasicHealing:
    AddMapField: SelfHealing: {0}
    AddMapField: UniqueEffects:
        this.heal(b, victim);
        ###
*
SelfHealing:
    AddMapField: RawSelfHealing: {0}
    AddMapField: Applies: user.canHeal()
*
RawSelfHealing:
    AddInterface: SelfHealingMove
    Header: double getHealFraction(Battle b, ActivePokemon victim)
    AddMapField: SelfTarget: True
    AddMapField: MoveType: Healing
*
ChargingMoveNoInterface:
    AddMapField: MultiTurn: True
    Header: String getChargeMessage(ActivePokemon user)
    Body:
        return {0};
        ###
*
ChargingMove:
    AddInterface: ChargingMove
    AddMapField: ChargingMoveNoInterface: {0}
*
RechargingMove:
    AddInterface: RechargingMove
    AddMapField: MultiTurn: True
*
MultiTurn:
    Header: boolean isCharging()
    Body:
        return this.isCharging;
        ###
    AddMapField: MoveType: Sleep_Talk_Fail
    AddMapField: Field:
        private boolean isCharging;
        ###
    AddMapField: ResetReady: True
    AddMapField: SwitchReady: True
    AddMapField: Constructor: 
        this.resetReady();
        ###
*
# For Multi-Turn Moves
ResetReady:
    Header: void resetReady()
    Body:
        this.isCharging = !this.chargesFirst();
        ###
*
# For Multi-Turn Moves
SwitchReady:
    Header: void switchReady()
    Body:
        this.isCharging = !this.isCharging;
        ###
*
SemiInv:
    AddMapField: ChargingMoveNoInterface: {2-}
    AddInterface: SemiInvulnerableMove
    Header: boolean isOverground()
    Body:
        return {1};
        ###
*
RequiresCharge:
    Header: boolean requiresCharge(Battle b)
*
SunlightCharger:
    AddMapField: ChargingMove: user.getName() + " began taking in sunlight!"
    AddMapField: GetMultiplier:
        switch (b.getWeather().namesies()) {
            case HAILING:
            case RAINING:
            case SANDSTORM:
                return .5;
            default:
                return 1;
        }
        ###
    AddMapField: RequiresCharge:
        // Does not need to charge during harsh sunlight
        return !b.isWeather(WeatherNamesies.SUNNY);
        ###
*
MultiStrike:
    AddInterface: MultiStrikeMove
    AddMapField: GetMinHits: {1}
    AddMapField: GetMaxHits: {2}
*
GetMinHits:
    Header: int getMinHits()
    Body: return {0};
*
GetMaxHits:
    Header: int getMaxHits()
    Body: return {0};
*
ChangeType:
    AddInterface: ChangeTypeSource
    Header: PokeType getType(Battle b, ActivePokemon caster, ActivePokemon victim)
*
# Special moves that use the opponent's Defense stat
SpecialDefenseMove:
    AddInterface: OpponentStatSwitchingEffect
    AddMapField: OppSwitchStat:
        return s == Stat.SP_DEFENSE ? Stat.DEFENSE : s;
        ###
    AddMapField: Cat: Special
*
IgnoreStageMove:
    AddInterface: OpponentIgnoreStageEffect
    AddMapField: OpponentIgnoreStage:
        // Ignore stages on the other pokemon
        return s.isDefending();
        ###
*
FusionMove:
    AddMapField: PowerMultiplierCondition: 2 !b.isFirstAttack() && victim.getAttack().namesies() == AttackNamesies.{00}
*
RemoveType:
    AddMapField: ChangeType:
        PokeType type = victim.getType(b);
        if (type.getFirstType() == Type.{00}) {
            return new PokeType(type.getSecondType());
        }

        if (type.getSecondType() == Type.{00}) {
            return new PokeType(type.getFirstType());
        }

        return null;
        ###
*
StartTurn:
    Header: void startTurn(Battle b, ActivePokemon me)
*
SwitchItemMessage:
    AddMapField: FullSwitchItemMessage:
        return {0};
        ###
*
FullSwitchItemMessage:
    AddInterface: ItemSwapperEffect
    Header: String getSwitchMessage(ActivePokemon user, HoldItem userItem, ActivePokemon victim, HoldItem victimItem)
*
SwapItemsMove:
    AddMapField: Applies: user.canSwapItems(b, victim)
    AddMapField: UniqueEffects:
        this.swapItems(b, user, victim);
        ###
    AddMapField: FullSwitchItemMessage:
        if (userItem.namesies() == ItemNamesies.NO_ITEM) {
            return user.getName() + " switched with " + victim.getName() + "'s " + victimItem.getName() + "!";
        } else if (victimItem.namesies() == ItemNamesies.NO_ITEM) {
            return user.getName() + " switched its " + userItem.getName() + " with " + victim.getName() + "!";
        } else {
            return user.getName() + " switched its " + userItem.getName() + " with " + victim.getName() + "'s " + victimItem.getName() + "!";
        }
        ###
    AddMapField: MoveType: Assistless, Metronomeless, No_Magic_Coat
*
ItemStealerMove:
    AddMapField: UniqueEffects:
        if (user.canStealItem(b, victim)) {
            this.swapItems(b, user, victim);
        }
        ###
    AddMapField: SwitchItemMessage: user.getName() + " stole " + victim.getName() + "'s " + victimItem.getName() + "!"
*
BattleEffect:
    AddMapField: {1}: {2}
    AddMapField: MoveType: No_Magic_Coat, Field
*
ProtectingAttack:
    AddMapField: PokemonEffect: {0}
    AddMapField: Priority: 4
    AddMapField: SelfTarget: True
    AddMapField: MoveType: Successive_Decay, Assistless, Metronomeless, Non_Snatchable
*
OHKO:
    AddInterface: OhkoMove
*
OhkoAccuracy:
    Header: int baseAccuracy(Battle b, ActivePokemon user)
*
SwitchStat:
    Header: Stat getSwitchStat(Battle b, ActivePokemon statPokemon, Stat s)
*
OppSwitchStat:
    Header: Stat getSwitchStat(Stat s)
*
CrashDamage:
    AddInterface: CrashDamageMove
    Header: int getMaxHealthPercentageDenominator()
    Body:
        return {0};
        ###
*
StatSplit:
    AddInterface: StatChangingEffect
    AddMapField: ChangeStat:
        // If the stat is a splitting stat, return the average between the user and the opponent
        if (s == Stat.{11} || s == Stat.{22}) {
            return (p.getStat(b, s) + opp.getStat(b, s))/2;
        }

        return stat;
        ###
    AddMapField: CastMessage: user.getName() + " split the {3}!"
*
StageChange:
    Header: int adjustStage(Battle b, ActivePokemon p, ActivePokemon opp, Stat s)
*
IgnoreStage:
    Header: boolean ignoreStage(Stat s, int stage)
*
OpponentIgnoreStage:
    Header: boolean ignoreStage(Stat s)
*
StatusCureMove:
    AddMapField: PowerMultiplierCondition: 2 victim.hasStatus(StatusNamesies.{00})
    AddMapField: UniqueEffects:
        if (victim.hasStatus(StatusNamesies.{00})) {
            victim.removeStatus(b, CastSource.ATTACK);
        }
        ###
*
SpecificStatusBooster:
    AddMapField: ToModifyMultiplier: {11} {2} p.hasStatus(StatusNamesies.{33})
*
StatStatusBooster:
    AddInterface: StatStatusBoosterEffect
    AddMapField: ToModify: {2}
    AddMapField: SimpleGetModifier: {1}
*
PowerStatusBooster:
    AddInterface: PowerStatusBoosterEffect
    Header: double getStatusBoost()
    Body:
        return {0};
        ###
*
StatModifyingStatus:
    AddInterface: StatModifyingStatus
    AddMapField: ToModify: {2}
    AddMapField: SimpleGetModifier: {1}
*
SelfHpRatioMove:
    AddMapField: Pow: {1}
    AddMapField: GetPow:
        return (int)Math.min(1, (super.power*me.getHPRatio()));
        ###
*
TargetHpRatioMove:
    AddMapField: GetPow:
        return (int)Math.min(1, ({1}*o.getHPRatio()));
        ###
*
Flailing:
    AddMapField: GetPow:
        double ratio = me.getHPRatio();
        if (ratio > .7) {
            return 20;
        } else if (ratio > .35) {
            return 40;
        } else if (ratio > .2) {
            return 80;
        } else if (ratio > .1) {
            return 100;
        } else if (ratio > .04) {
            return 150;
        } else {
            return 200;
        }
        ###
*
BarrierBreaker:
    AddMapField: UniqueEffects:
        BarrierEffect.breakBarriers(b, victim, user);
        ###
*
SimpleBarrier:
    AddMapField: ToModify: {1}
    AddMapField: CastMessage: user.getName() + " raised the " + Stat.{11}.getName().toLowerCase() + " of its team!"
    AddMapField: Barrier: {2-}
*
Barrier:
    AddMapField: NumTurns: 5
    AddMapField: SubsideMessage: "The effects of {0} faded."
    AddMapField: Defog: "The effects of {0} faded."
    AddInterface: BarrierEffect
    Header: String getBreakMessage(ActivePokemon breaker)
    Body:
        return breaker.getName() + " broke the {0} barrier!";
        ###
*
# Note: Does not include replaceable apply check (only used for status moves)
AbilityChangeMove:
    AddInterface: ChangeAbilitySource
    AddMapField: PokemonEffect: ChangeAbility
    AddMapField: AbilityChange:
        return AbilityNamesies.{00}.getNewAbility();
        ###
*
SpecificAbilityChange:
    AddMapField: Applies: victim.getAbility().isReplaceable()
    AddMapField: AbilityChangeMove: {0}
    AddMapField: AbilityMessage:
        return victim.getName() + "'s ability was changed to " + AbilityNamesies.{00}.getName() + "!";
        ###
*
SuppressAbilityMove:
    AddMapField: AbilityChangeMove: NO_ABILITY
    AddMapField: AbilityMessage:
        return caster.getName() + " suppressed " + victim.getName() + "'s ability!";
        ###
*
SemiInvulnerableBypass:
    AddInterface: SemiInvulnerableBypasser
    Header: boolean semiInvulnerableBypass(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
BasicBypassAccuracy:
    AddInterface: BasicAccuracyBypassEffect
    Header: boolean bypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
OpponentBypassAccuracy:
AddInterface: OpponentAccuracyBypassEffect
    Header: boolean opponentBypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
AbilityChange:
    Header: Ability getAbility(Battle b, ActivePokemon caster, ActivePokemon victim)
*
AbilityMessage:
    Header: String getMessage(Battle b, ActivePokemon caster, ActivePokemon victim)
*
MirrorMove:
    AddMapField: MoveType: Sleep_Talk_Fail, Encoreless, Metronomeless, Assistless, No_Magic_Coat, Mirrorless, Protect_Piercing
    AddMapField: Field:
        private AttackNamesies mirror;
        ###
    AddMapField: BeginAttack:
        Move lastMoveUsed = defending.getLastMoveUsed();
        this.mirror = lastMoveUsed == null ? null : lastMoveUsed.getAttack().namesies();
        ###
    AddMapField: Applies: mirror != null && !mirror.getNewAttack().isMoveType(MoveType.MIRRORLESS)
    AddMapField: CallNewMove: this.mirror
*
EffectChanceMultiplier:
    AddInterface: EffectChanceMultiplierEffect
    Header: double getEffectChanceMultiplier(ActivePokemon user)
    Body:
        return {0};
        ###
*
Countering:
    AddMapField: Priority: -5
    AddMapField: MoveType: Assistless, Metronomeless, Mirrorless
    AddMapField: PP: 20
    AddMapField: Acc: 100
    AddMapField: Applies: user.getDamageTaken() > 0 && victim.getMove() != null && victim.getAttack().getCategory() == MoveCategory.{00} && !b.isFirstAttack()
    AddMapField: Comments: // Fails if no damage to reflect or if the opponent isn't using an attack of the proper category
    AddMapField: FixedDamage: me.getDamageTaken()
*
CallNewMove:
    AddMapField: UniqueEffects:
        user.callNewMove(b, victim, {0});
        ###
*
CallFullNewMove:
    AddMapField: UniqueEffects:
        user.callFullNewMove(b, victim, {0});
        ###
*
SwapOpponentOnly:
    AddMapField: SwapOpponent: {0}
    AddMapField: MoveType: Substitute_Piercing, Protect_Piercing
*
SwapOpponent:
    Header: String getSwapMessage(ActivePokemon user, ActivePokemon victim)
    Body:
        return {0};
        ###
    AddInterface: SwapOpponentEffect
    AddMapField: MoveType: Assistless
    AddMapField: Priority: -6
    AddMapField: Applies: user.canSwapOpponent(b, victim)
    AddMapField: UniqueEffects:
        this.swapOpponent(b, user, victim);
        ###
*
SelfSwitching:
    AddMapField: UniqueEffects:
        user.switcheroo(b, user, CastSource.ATTACK, true);
        ###
*
ApplyEndTurn:
    Header: void applyEndTurn(ActivePokemon victim, Battle b)
*
# For BattleEndTurnEffects
BattleEndTurn:
    Header: void singleEndTurnEffect(Battle b, ActivePokemon victim)
*
BattleEndTurnMessage:
    Header: String getEndTurnMessage(Battle b)
    Body:
        return {0};
        ###
*
CanAttack:
    Header: boolean canAttack(ActivePokemon attacking, ActivePokemon defending, Battle b)
*
ProtectingEffect:
    AddMapField: ProtectingEffectNoDecay: True
    AddMapField: SuccessiveDecay: True
*
ProtectingEffectNoDecay:
    AddInterface: ProtectingEffect
    AddMapField: NumTurns: 1
    AddMapField: CastMessage: victim.getName() + " protected itself!"
*
ProtectingCondition:
    Header: boolean protectingCondition(Battle b, ActivePokemon attacking)
*
OnProtectingSuccess:
    Header: void protectingEffects(Battle b, ActivePokemon p, ActivePokemon opp)
*
SuccessiveDecay:
    AddMapField: EffectApplies: RandomUtils.chanceTest((int)(100*caster.getSuccessionDecayRate()))
*
TrappingMessage:
    Header: String trappingMessage(ActivePokemon trapped)
    Body:
        return {0};
        ###
*
OpponentTrappingAbility:
    AddMapField: OppTrapped:
        return {0};
        ###
    AddMapField: OppTrappingMessage:
        return trapper.getName() + "'s " + this.getName() + " prevents " + escaper.getName() + " from escaping!";
        ###
*
OppTrapped:
    Header: boolean trapOpponent(Battle b, ActivePokemon escaper, ActivePokemon trapper)
    AddInterface: OpponentTrappingEffect
*
OppTrappingMessage:
    Header: String opponentTrappingMessage(ActivePokemon escaper, ActivePokemon trapper)
*
PartialTrap:
    Header: String getReduceMessage(ActivePokemon victim)
    Body:
        return victim.getName() + " is hurt by {1_}!";
        ###
    AddInterface: PartialTrappingEffect
    AddMapField: MinTurns: 4
    AddMapField: MaxTurns: 5
    AddMapField: CastMessage: {2-}
    AddMapField: SubsideMessage: victim.getName() + " is no longer trapped by {1_}."
    AddMapField: RapidSpinNoInterface: released.getName() + " was released from {1_}!"
    AddMapField: TrappingMessage: trapped.getName() + " cannot be recalled due to {1_}!"
*
LockingEffect:
    AddInterface: LockingEffect
    Header: List<ActivePokemon> getLocking()
    Body:
        return List.of({0});
        ###
*
UsedProof:
    AddMapField: CanHave: True
    AddMapField: AlternateCast:
        this.addCastMessage(b, caster, victim, source, castMessage);
        ###
*
AlternateCast:
    AddMapField: HasAlternateCast: True
    Header: void alternateCast(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source, CastMessageGetter castMessage)
*
BeforeCast:
    Header: void beforeCast(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source)
*
AfterCast:
    Header: void afterCast(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source)
*
CastMessage:
    Header: String getCastMessage(Battle b, ActivePokemon user, ActivePokemon victim, CastSource source)
    Body:
        return {0};
        ###
*
SubsideMessage:
    Header: String getSubsideMessage(ActivePokemon victim)
    Body:
        return {0};
        ###
*
WeightBased:
    AddMapField: GetPow:
        double weight = {0}.getWeight(b);
        if (weight < 22) {
            return 20;
        } else if (weight < 55) {
            return 40;
        } else if (weight < 110) {
            return 60;
        } else if (weight < 220) {
            return 80;
        } else if (weight < 440) {
            return 100;
        } else {
            return 120;
        }
        ###
*
WeightRatio:
    AddMapField: GetPow:
        double ratio = {1}.getWeight(b)/{2}.getWeight(b);
        if (ratio > .5) {
            return 40;
        } else if (ratio > .33) {
            return 60;
        } else if (ratio > .25) {
            return 80;
        } else if (ratio > .2) {
            return 100;
        } else {
            return 120;
        }
        ###
*
StatRatio:
    AddMapField: GetPow:
        double ratio = (double)Stat.{11}.getBasicStat(b, {2})/Stat.{11}.getBasicStat(b, {3});
        if (ratio > .5) {
            return 60;
        } else if (ratio > .33) {
            return 80;
        } else if (ratio > .25) {
            return 120;
        } else {
            return 150;
        }
        ###
*
RapidSpin:
    AddInterface: RapidSpinRelease
    AddMapField: RapidSpinNoInterface: {0}
*
RapidSpinNoInterface:
    Header: String getRapidSpinReleaseMessage(ActivePokemon released)
    Body:
        return {0};
        ###
*
ChangeStat:
    Header: int modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s, int stat)
*
ModifyStat:
    Header: double modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s)
*
SimpleGetModifier:
    Header: double getModifier()
    Body: return {0};
*
SimpleModifier:
    AddMapField: SimpleGetModifier: {1}
    AddInterface: SimpleStatModifyingEffect
*
# <Stat> <Multiplier>
SimpleToModify:
    AddMapField: ToModify: {1}
    AddMapField: SimpleModifier: {2}
*
# <Stat> <Multiplier> <Condition>
ToModifyMultiplier:
    AddMapField: ToModify: {1}
    AddMapField: ModifyMultiplier: {2-}
*
# <FirstStat> <SecondStat> <Multiplier> <Condition>
TwoModifyMultiplier:
    AddMapField: TwoModify: {1} {2}
    AddMapField: ModifyMultiplier: {3-}
*
ModifyMultiplier:
    AddMapField: SimpleModifier: {1}
    AddMapField: CanModify: {2-}
*
CanModify:
    Header: boolean canModifyStat(Battle b, ActivePokemon p, ActivePokemon opp)
    Body: 
        return {0};
        ###
*
TwoModify:
    Header: boolean isModifyStat(Stat s)
    Body:
        return s == Stat.{11} || s == Stat.{22};
        ###
*
ToModify:
    Header: boolean isModifyStat(Stat s)
    Body:
        return s == Stat.{00};
        ###
*
GetForceMove:
    Header: Move getForcedMove(ActivePokemon attacking)
*
Subside:
    Header: void subside(Battle b, ActivePokemon p)
*
Usable:
    Header: boolean usable(Battle b, ActivePokemon p, Move m)
*
UnusableMessage:
    Header: String getUnusableMessage(Battle b, ActivePokemon p)
    Body:
        return {0};
        ###
*
ShouldSubside:
    Header: boolean shouldSubside(Battle b, ActivePokemon victim)
*
Enter:
    Header: void enter(Battle b, ActivePokemon enterer)
*
GetChangeTypeEffect:
    Header: PokeType getType(Battle b, ActivePokemon p, boolean display)
*
GetNameChange:
    Header: String getNameChange()
*
SetNameChange:
    Header: void setNameChange(Battle b, ActivePokemon victim)
*
AbilityIsActive:
    Header: boolean isActive()  
*
Deactivate:
    Header: void deactivate(Battle b, ActivePokemon victim)
*
GetTurns:
    Header: int getTurns()
*
SetTurns:
    Header: void setTurns(int turns)
*
StatusPrevent:
    Header: ApplyResult preventStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusNamesies status)
    AddInterface: StatusPreventionEffect
    End:
        
        return ApplyResult.success();
        ###
*
EffectPrevent:
    Header: PokemonEffectNamesies getPreventableEffect()
    AddInterface: SingleEffectPreventionAbility
    Body:
        return PokemonEffectNamesies.{00};
        ###
*
MultipleEffectPreventionAbility:
    Header: Set<PokemonEffectNamesies> getPreventableEffects()
    AddInterface: MultipleEffectPreventionAbility
    Body:
        return {0};
        ###
*
FullEffectPrevent:
    Header: ApplyResult preventEffect(Battle b, ActivePokemon caster, ActivePokemon victim, EffectNamesies effectName)
    AddInterface: EffectPreventionEffect
*
EffectSourcePreventMessage:
    Header: String getSourcePreventMessage(ActivePokemon victim, String sourceName)
    Body:
        return victim.getName() + "'s " + sourceName + " prevents {0}!";
        ###
*
EffectSourceRemoveMessage:
    Header: String getSourceRemoveMessage(ActivePokemon victim, String sourceName)
    Body:
        return victim.getName() + " is no longer {0} due to its " + sourceName + "!";
        ###
*
PowerMultiplierCondition:
    AddMapField: GetMultiplier:
        return {2-} ? {1} : 1;
        ###
*
GetMultiplier:
    AddInterface: PowerChangeEffect
    Header: double getMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
*
GetOppMultiplier:
    Header: double getOpponentMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
*
StatProtect:
    AddMapField: StatProtectingEffect: 
        return stat == Stat.{00};
        ###
    AddMapField: StatProtectMessage: p.getName() + "'s " + this.getName() + " prevents its " + s.getName() + " from being lowered!"
    AddInterface: StatProtectingEffect
*
StatProtectAll:
    AddMapField: StatProtectingEffect: 
        return {0};
        ###
    AddMapField: StatProtectMessage: p.getName() + "'s " + this.getName() + " prevents its stats from being lowered!"
    AddInterface: StatProtectingEffect
*
StatProtectingEffect:
    Header: boolean prevent(Battle b, ActivePokemon caster, ActivePokemon victim, Stat stat)
*
StatProtectMessage:
    Header: String preventionMessage(Battle b, ActivePokemon p, Stat s)
    Body:
        return {0};
        ###
*
Sporty:
    AddMapField: PowerMultiplierCondition: .33 user.isAttackType(Type.{11})
    AddMapField: CastMessage: "{2}'s power was weakened!"
    AddMapField: NumTurns: 5
    AddMapField: SubsideMessage: "The effects of {3} Sport wore off."
*
SpecialRoom:
    AddMapField: NumTurns: 5
    AddMapField: SubsideMessage: "The dimensions of the {1} room returned to normal."
    AddMapField: CastMessage: user.getName() + " twisted the dimensions to {2-}!"
    AddMapField: CanHave: True
    AddMapField: AlternateCast:
        // Remove the effect if it's already in play
        this.subside(b, caster);
        ###
*
MoveTypePrevent:
    AddInterface: AttackBlocker
    AddMapField: Block:
        return user.getAttack().isMoveType(MoveType.{11});
        ###
    AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " prevents {2-}!"
*
DeathWish:
    Header: void deathWish(Battle b, ActivePokemon dead, ActivePokemon murderer)
    AddInterface: FaintEffect
*
KillWish:
    Header: void killWish(Battle b, ActivePokemon dead, ActivePokemon murderer)
*
Defog:
    AddInterface: DefogRelease
    Header: String getDefogReleaseMessage(ActivePokemon released)
    Body:
        return {0};
        ###
*
EntryHazard:
    AddInterface: EntryHazard
    Header: String getReleaseMessage()
    Body:
        return {0};
        ###
*
AbilityHolder:
    AddInterface: AbilityHolder
    Header: Ability getAbility()
    Body:
        return {0};
        ###
*
ItemHolder:
    AddInterface: ItemHolder
    Header: HoldItem getItem()
    Body:
        return {0};
        ###
*
PokemonHolder:
    AddInterface: PokemonHolder
    Header: PokemonNamesies getPokemon()
    Body:
        return {0};
        ###
*
ItemListHolder:
    AddInterface: ItemListHolder
    Header: List<ItemNamesies> getItems()
    Body:
        return {0};
        ###
*
Bracing:
    Header: boolean isBracing(Battle b, ActivePokemon bracer, boolean fullHealth)
*
BraceMessage:
    Header: String braceMessage(ActivePokemon bracer)
    Body:
        return {0};
        ###
*
GetMoveList:
    Header: MoveList getMoveList(MoveList actualMoves)
*
GetStat:
    Header: Integer getStat(ActivePokemon user, Stat stat)
*
IncreaseCritStage:
    Header: int increaseCritStage(ActivePokemon p)
*
FallMessage:
    Header: void fall(Battle b, ActivePokemon fallen)
    Body:
        Messages.add({0});
        this.deactivate();
        ###
*
EndBattle:
    Header: void afterBattle(Trainer player, Battle b, ActivePokemon p)
*
Contact:
    Header: void contact(Battle b, ActivePokemon user, ActivePokemon victim)
*
SelfBlock:
    Header: boolean block(Battle b, ActivePokemon user)
*
SelfAlternateEffect:
    Header: void alternateEffect(Battle b, ActivePokemon user)
*
SelfBlockMessage:
    Header: String getBlockMessage(Battle b, ActivePokemon user)
*
Block:
    Header: boolean block(Battle b, ActivePokemon user, ActivePokemon victim)
*
AlternateEffect:
    Header: void alternateEffect(Battle b, ActivePokemon user, ActivePokemon victim)
*
BlockMessage:
    Header: String getBlockMessage(Battle b, ActivePokemon user, ActivePokemon victim)
    Body:
        return {0};
        ###
*
BlockType:
    AddInterface: AttackBlocker
    AddMapField: Block:
        return user.isAttackType(Type.{00});
        ###
    AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " makes it immune to " + Type.{00}.getName() + "-type moves!"
*
IncreaseBlockType:
    AddMapField: BlockType: {1}
    AddMapField: AlternateEffect:
        victim.getStages().modifyStage(victim, 1, Stat.{22}, b, CastSource.ABILITY);
        ###
*
AbsorbType:
    AddInterface: AttackBlocker
    AddMapField: Block:
        return user.isAttackType(Type.{00});
        ###
    AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " makes it immune to " + Type.{00}.getName() + " moves!"
    AddMapField: AlternateEffect:
        // Technically, according to the description, Heal Block prevents the prevention entirely (meaning this should be in Block), but that makes no sense, they shouldn't take damage, this way makes more sense
        victim.healHealthFraction(1/4.0, b, victim.getName() + "'s HP was restored instead!");
        ###
*
EndTurnStatusCure:
    AddInterface: EndTurnEffect
    AddMapField: ApplyEndTurn:
        if (victim.hasStatus() && {0}) {
            victim.removeStatus(b, CastSource.ABILITY);
        }
        ###
*
EndTurnBigRootHealer:
    AddInterface: EndTurnEffect
    AddMapField: ApplyEndTurn:
        int healAmount = victim.getHealHealthFractionAmount(1/16.0);
        if (victim.isHoldingItem(b, ItemNamesies.BIG_ROOT)) {
            healAmount *= 1.3;
        }

        victim.heal(healAmount, b, victim.getName() + " restored some HP due to {0}!");
        ###
*
PinchAbility:
    AddMapField: PowerMultiplierCondition: 1.5 user.getHPRatio() < 1/3.0 && user.isAttackType(Type.{00})
*
StatusPreventAbility:
    AddInterface: StatusPreventionAbility
    Header: StatusNamesies getStatus()
    Body:
        return StatusNamesies.{00};
        ###
*
StatusContact:
    AddMapField: Contact:
        if (RandomUtils.chanceTest(30)) {
            StatusNamesies.{00}.getStatus().apply(b, victim, user, CastSource.ABILITY);
        }
        ###
    AddInterface: PhysicalContactEffect
*
DecreaseContactAbility:
    AddInterface: PhysicalContactEffect
    AddMapField: Contact:
        user.getStages().modifyStage(victim, -1, Stat.{00}, b, CastSource.ABILITY);
        ###
*
# Srsly don't worry about it
OtherPangoro:
    AddInterface: EntryEffect
    AddMapField: Enter:
        if (enterer.namesies() == PokemonNamesies.PANGORO) {
            Messages.add(enterer.getName() + " does not break the mold!!!!!!!");
        }
        ###
*
SpeedWeather:
    AddMapField: ToModifyMultiplier: Speed 2 b.isWeather(WeatherNamesies.{00})
*
WeatherStarter:
    AddInterface: EntryEffect
    AddMapField: Enter:
        Messages.add(enterer.getName() + "'s " + this.getName() + " {2-}!");
        b.addEffect(WeatherNamesies.{11}.getEffect());
        ###
*
WeatherEvasion:
    AddInterface: StageChangingEffect
    AddMapField: StageChange:
        return s == Stat.EVASION && b.isWeather(WeatherNamesies.{00}) ? 1 : 0;
        ###
*
WeatherEliminate:
    Header: String getEliminateMessage(ActivePokemon eliminator)
    AddInterface: WeatherEliminatingEffect
    Body:
        return eliminator.getName() + "'s " + this.getName() + " eliminated the weather!";
        ###
*
HalfAmount:
    Header: int getHalfAmount()
    Body:
        return {0};
        ###
*
WeatherBlock:
    Header: boolean block(WeatherNamesies weather)
*
WeatherBlocker:
    AddInterface: WeatherBlockerEffect
    AddMapField: WeatherBlock:
        return weather == WeatherNamesies.{00};
        ###
*
WeatherHealer:
    AddInterface: EndTurnEffect
    AddMapField: ApplyEndTurn:
        if (b.isWeather(WeatherNamesies.{00})) {
            victim.healHealthFraction(1/16.0, b, victim.getName() + "'s HP was restored due to its " + this.getName() + "!");
        }
        ###
*
OnApplyDamage:
    Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim)
*
OpponentApplyDamage:
    Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim)
*
ModifyStageValue:
    Header: int modifyStageValue()
    AddInterface: ModifyStageValueEffect
    Body:
        return {0};
        ###
*
SwitchOut:
    Header: void switchOut(ActivePokemon switchee)
*
OnTakeDamage:
    Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
*
OpponentTakeDamage:
    Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
*
Fling:
    AddMapField: FlingDamage:
        return {0};
        ###
*
FlingDamage:
    Header: int flingDamage()
*
FlingEffect:
    Header: void flingEffect(Battle b, ActivePokemon pelted)
*
FullItemUse:
    Header: boolean use(Battle b, ActivePokemon p, Move m)
*
PlayerUse:
    Header: boolean use()
*
PokemonUse:
    Header: boolean use(ActivePokemon p)
*
BattleUse:
    Header: boolean use(ActivePokemon p, Battle b)
*
MoveUse:
    Header: boolean use(ActivePokemon p, Move m)
*
TypeTakeDamageStatIncrease:
    AddMapField: OnTakeDamage:
        if (user.isAttackType(Type.{11}) && victim.getStages().modifyStage(victim, 1, Stat.{22}, b, CastSource.HELD_ITEM)) {
            this.consumeItem(b, victim);
        }
        ###
    AddInterface: HoldItem
    AddInterface: TakeDamageEffect
*
ChoiceItem:
    AddMapField: ChoiceEffect: {0}
    AddInterface: HoldItem
    AddMapField: Fling: 10
    AddMapField: Price: 4000
    AddMapField: Cat: Misc
*
ChoiceEffect:
    AddInterface: ChoiceEffect
    Header: Stat getBoosted()
    Body:
        return Stat.{00};
        ###
*
Wing:
    AddMapField: EVIncreaseAmt: {0}
    AddMapField: Price: 3000
    AddInterface: Wing
*
Vitamin:
    AddMapField: EVIncreaseAmt: {0}
    AddMapField: Price: 10000
    AddInterface: Vitamin
*
RepelEffectItem:
    AddInterface: RepellingEffect
    Header: boolean shouldRepel(ActivePokemon playerFront, WildEncounter wildPokemon)
    Body:
        return RandomUtils.chanceTest(1, 3) && wildPokemon.getLevel() <= playerFront.getLevel();
        ###
*
TypedWildEncounterSelector:
    AddInterface: TypedWildEncounterSelector
    Header: Type getEncounterType()
    Body:
        return Type.{00};
        ###
*
EncounterRateMultiplier:
    AddInterface: EncounterRateMultiplier
    Header: double getEncounterRateMultiplier()
    Body:
        return {0};
        ###
*
WeatherEncounterRateDecreaser:
    AddMapField: EncounterRateMultiplier: Game.getPlayer().getArea().getWeather() == WeatherState.{00} ? .5 : 1
*
BuffetMessage:
    AddMapField: BattleEndTurn:
        // Don't buffet the immune!
        if (victim.isType(b, {1_})) {
            return;
        }

        // Srsly don't buffet the immune!!
        if (WeatherBlockerEffect.checkBlocked(b, victim, this.namesies())) {
            return;
        }

        // Buffety buffety buffet
        victim.reduceHealthFraction(b, 1/16.0, {2-});
        ###
*
WeatherStatChange:
    AddMapField: GetMultiplier:
        if (user.isAttackType(Type.{11})) {
            // {1} is fiddy percent stronger in tha weathz
            return 1.5;
        } else if (user.isAttackType(Type.{22})) {
            // {2} is fiddy percent weaker in tha weathz
            return .5;
        } else {
            return 1;
        }
        ###
*
GetEVs:
    Header: int[] getEVs(int[] vals)
*
TargetSwap:
    Header: boolean swapTarget(Battle b, ActivePokemon user, ActivePokemon opponent)
*
MagicReflection:
    AddInterface: TargetSwapperEffect
    AddMapField: TargetSwap:
        if (user.getAttack().isMagicReflectable()) {
            Messages.add(opponent.getName() + "'s " + {0} + " reflected " + user.getName() + "'s move!");
            return true;
        }

        return false;
        ###
*
PowerStat:
    Header: Stat powerStat()
    Body:
        return Stat.{00};
        ###
    AddMapField: SimpleToModify: Speed .5
    AddMapField: GetEVs:
        vals[powerStat().index()] += 4;
        return vals;
        ###
    AddMapField: Fling: 70
    AddMapField: Price: 3000
    AddMapField: Cat: Misc
    AddInterface: PowerItem
*
TypeEnhance:
    AddMapField: PowerMultiplierCondition: 1.2 user.isAttackType(Type.{00})
    AddInterface: HoldItem
    AddMapField: Cat: Misc
*
PPIncrease:
    AddMapField: MoveUse:
        if (m.increaseMaxPP({0})) {
            Messages.add(p.getName() + "'s " + m.getAttack().getName() + "'s Max PP was increased!");
            return true;
        }

        return false;
        ###
    AddInterface: MoveUseItem
    AddInterface: HoldItem
    AddMapField: Cat: Stat
*
# Need to add this back in once these can be used in battle: BattleCat: HP_PP
Ether:
    AddMapField: Comments: // TODO: These currently cannot be used in battle :(
    AddInterface: PPHealer
    AddMapField: PPRestoreAmount:
        return {0};
        ###
*
PPRestoreAmount:
    Header: int restoreAmount(Move toRestore)
*
AllPPRestoreAmount:
    Header: int restoreAmount(Move toRestore)
*
Elixir:
    AddInterface: AllPPHealer
    AddMapField: AllPPRestoreAmount:
        return {0};
        ###
    AddInterface: HoldItem
    AddMapField: Cat: Medicine
    AddMapField: BattleCat: HP_PP
*
TimeSpaceOrb:
    AddMapField: Fling: 60
    AddMapField: Price: 10000
    AddInterface: HoldItem
    AddMapField: Cat: Misc
    AddMapField: PowerMultiplierCondition: 1.2 user.isPokemon(PokemonNamesies.{11}) && user.isAttackType(Type.DRAGON, Type.{22})
*
SpecialItemAbility:
    AddInterface: ChangeTypeEffect
    AddMapField: GetChangeTypeEffect:
        HoldItem item = p.getHeldItem(b);
        if (item instanceof {0}) {
            return new PokeType((({0})item).getType());
        }

        return p.getActualType();
        ###
    AddMapField: Irrestealable: True
    AddMapField: Irreplaceable: True
*
SpecialItemMove:
    AddMapField: Type: Normal
    AddMapField: MoveType: Metronomeless
    AddMapField: GetType:
        HoldItem item = user.getHeldItem(b);
        if (item instanceof {0}) {
            return (({0})item).getType();
        }

        return super.type;
        ###
*
SpecialTypeItem:
    Header: Type getType()
    Body:
        return Type.{00};
        ###
    AddMapField: Cat: Misc
*
GemType:
    AddMapField: SpecialTypeItem: {0}
    AddMapField: Price: 200
    AddInterface: GemItem
*
PlateType:
    AddMapField: SpecialTypeItem: {0}
    AddMapField: Price: 1000
    AddInterface: PlateItem
*
DriveType:
    AddMapField: SpecialTypeItem: {0}
    AddMapField: Price: 1000
    AddInterface: DriveItem
*
MemoryType:
    AddMapField: SpecialTypeItem: {0}
    AddMapField: Price: 1000
    AddInterface: MemoryItem
*
StatusHealAll:
    AddMapField: BattleCat: Status
    AddInterface: StatusHealer
    AddMapField: ShouldHealStatus:
        // Can't heal what you don't have
        return p.hasStatus();
        ###
*
Revive:
    AddInterface: BattlePokemonUseItem
    AddInterface: HoldItem
    AddMapField: Cat: Medicine
    AddMapField: BattleCat: Status
    AddMapField: BattleUse:
        // Only applies to the dead
        if (!p.isActuallyDead()) {
            return false;
        }

        p.removeStatus();
        p.healHealthFraction({1});

        Messages.add(p.getName() + " was {2} revived!");
        return true;
        ###
*
ShouldHealStatus:
    Header: boolean shouldHeal(ActivePokemon p)
*
StatusRemove:
    AddInterface: StatusHealer
    AddMapField: BattleCat: Status
    AddMapField: ShouldHealStatus:
        return p.hasStatus(StatusNamesies.{00});
        ###
*
GetAmountHealed:
    Header: int getHealAmount(ActivePokemon p)
    AddMapField: BattleCat: HP_PP
    AddInterface: HpHealer
    Body:
        return {0};
        ###
*
HealAmt:
    AddMapField: GetAmountHealed: {0}
    AddMapField: Cat: Medicine
*
XStageIncrease:
    AddMapField: Cat: Stat
    AddMapField: BattleCat: Battle
    AddInterface: HoldItem
    AddInterface: BattleUseItem
    AddMapField: BattleUse:
        return p.getStages().modifyStage(p, 2, Stat.{00}, b, CastSource.USE_ITEM);
        ###
*
EVIncrease:
    Header: Stat toIncrease()
    Body:
        return Stat.{00};
        ###
*
EVIncreaseAmt:
    AddMapField: EVIncrease: {0}
    AddMapField: Cat: Stat
*
CatchRateCondition:
    AddMapField: BallItem: True
    AddMapField: CatchRate:
        return {2-} ? {1} : 1;
        ###
*
FixedCatchRate:
    AddMapField: BallItem: True
    AddMapField: CatchRate:
        return {0};
        ###
*
BallItem:
    AddInterface: BallItem
    AddMapField: Cat: Ball
    AddMapField: BattleCat: Ball
*
CatchRate:
    Header: double getModifier(ActivePokemon me, ActivePokemon o, Battle b)
*
AdditiveCatch:
    Header: int getAdditive(ActivePokemon me, ActivePokemon o, Battle b)
*
AfterCaught:
    Header: void afterCaught(ActivePokemon p)
*
EVDecreaseBerry:
    AddMapField: DecreaseEVs:
        return Stat.{00};
        ###
    AddInterface: EvDecreaseBerry
*
DecreaseEVs:
    Header: Stat toDecrease()
*
TypedPowerReduceBerry:
    Header: Type getType()
    Body:
        return Type.{00};
        ###
    AddMapField: Berry: True
*
SuperEffectivePowerReduceBerry:
    AddInterface: SuperEffectiveTypedPowerReduceBerry
    AddMapField: TypedPowerReduceBerry: {0}
*
HealthTriggeredStageIncreaseBerry:
    AddInterface: HealthTriggeredStageIncreaseBerry
    Header: Stat getStat()
    Body:
        return Stat.{00};
        ###
*
CategoryBerry:
    Header: MoveCategory getCategory()
    Body:
        return MoveCategory.{00};
        ###
*
CategoryIncreaseBerry:
    Header: Stat getStat()
    Body:
        return Stat.{22};
        ###
    AddMapField: CategoryBerry: {1}
    AddInterface: CategoryIncreaseBerry
*
CategoryDamagerBerry:
    AddInterface: CategoryDamageBerry
    AddMapField: CategoryBerry: {0}
*
HealPartyStatus:
    AddMapField: UniqueEffects:
        for (ActivePokemon p : b.getTrainer(user).getActiveTeam()) {
            if (!p.isActuallyDead()) {
                p.removeStatus();
            }
        }

        Messages.add("All status problems were cured!");
        ###
    AddMapField: SelfTarget: True
*
RemoveAdvantageType:
    AddMapField: NegateNoAdvantage: defending == Type.{11} && ({2-})
*
ForesightEffect:
    AddMapField: CastMessage: user.getName() + " identified " + victim.getName() + "!"
    AddMapField: UsedProof: True
    AddInterface: DefendingNoAdvantageChanger
    AddMapField: RemoveAdvantageType: {0}
    AddInterface: IgnoreStageEffect
    AddMapField: IgnoreStage:
        // Ignore this Pokemon's increased evasion
        return s == Stat.EVASION && stage > 0;
        ###
*
ForesightMove:
    AddMapField: PokemonEffect: {0}
    AddMapField: MoveType: Substitute_Piercing
*
ChangeTypeMove:
    AddMapField: PokemonEffect: ChangeType
    AddMapField: ChangeType:
        return new PokeType(Type.{00});
        ###
    AddMapField: FullApplies:
        // Fails is the Pokemon is a pure-{0} type
        PokeType type = victim.getType(b);
        return !type.isType(Type.{00}) || type.isDualTyped();
        ###
*
AddTypeMove:
    AddMapField: PokemonEffect: ChangeType
    AddMapField: ChangeType:
        Type primary = victim.getType(b).getFirstType();
        return new PokeType(primary, primary == Type.{00} ? Type.NO_TYPE : Type.{00});
        ###
    AddMapField: FullApplies:
        // Fails is the Pokemon is already {0} type
        return !victim.getType(b).isType(Type.{00});
        ###
*
PrintFail:
    Header: boolean canPrintFail()
    Body:
        return {0};
        ###
*
FutureAttackMove:
    AddMapField: TeamEffect: {0}
    AddMapField: ShouldApplyDamage:
        // Don't apply damage just yet!!
        return false;
        ###
    AddMapField: PrintFail: true
    AddMapField: MoveType: Protect_Piercing, Mirrorless
*
FutureAttackEffect:
    AddMapField: NumTurns: 3
    AddMapField: Field:
        private ActivePokemon theSeeer;
        ###
    AddMapField: Subside:
        Messages.add(p.getName() + " took " + theSeeer.getName() + "'s attack!");

        Attack attack = AttackNamesies.{00}.getNewAttack();

        // Don't do anything for moves that are uneffective
        if (!attack.effective(b, theSeeer, p)) {
            return;
        }

        theSeeer.callTempMove(attack.namesies(), () -> theSeeer.getAttack().applyDamage(theSeeer, p, b));
        ###
    AddMapField: BeforeCast:
        theSeeer = caster;
        ###
    AddMapField: CastMessage: theSeeer.getName() + " foresaw an attack!"
*
EliminateStatChanges:
    AddMapField: UniqueEffects:
        user.getStages().reset();
        victim.getStages().reset();
        Messages.add("All stat changes were eliminated!");
        ###
*
StatSwapMove:
    AddMapField: Field:
        private static final Stat[] swapStats = { Stat.{11}, Stat.{22} };
        ###
    AddMapField: UniqueEffects:
        for (Stat s : swapStats) {
            user.getStages().swapStages(s, victim);
        }

        Messages.add(user.getName() + " swapped its stats with " + victim.getName() + "!");
        ###
    AddMapField: MoveType: No_Magic_Coat
*
GainEffect:
    Header: boolean gainBerryEffect(Battle b, ActivePokemon user, CastSource source)
*
FixedBerryHealthTrigger:
    AddInterface: HealthTriggeredBerry
    AddMapField: HealthTriggerRatio:
        return 1/{0}.0;
        ###
*
HealthTriggerRatio:
    Header: double healthTriggerRatio()
*
Berry:
    AddMapField: Cat: Berry
    AddMapField: Price: 20
*
NGPow:
    Header: int naturalGiftPower()
    Body:
        return {0};
        ###
*
NGType:
    AddMapField: Berry: True
    Header: Type naturalGiftType()
    Body:
        return Type.{00};
        ###
*
HarvestHours:
    Header: int getHarvestHours()
    Body:
        return {0};
        ###
*
RepelSteps:
    Header: int repelSteps()
    Body: 
        return {0};
        ###
    AddMapField: Cat: Misc
    AddInterface: RepelItem
*
PowderResist:
    AddInterface: PowderBlocker
    AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " protects it from powder moves!"
*
NegateNoAdvantage:
    Header: boolean negateNoAdvantage(Type attacking, Type defending)
    Body:
        return {0};
        ###
*
MultiplyAdvantage:
    Header: double multiplyAdvantage(Type attackingType, PokeType defendingTypes)
*
SuperEffectiveAdvantageType:
    AddInterface: AdvantageMultiplierMove
    AddMapField: MultiplyAdvantage:
        double multiplier = 1;
        for (Type defendingType : defendingTypes) {
            if (defendingType == Type.{00}) {
                multiplier *= 2/attackingType.getAdvantage().getAdvantage(defendingType);
            }
        }

        return multiplier;
        ###
*
GetPow:
    Header: int getPower(Battle b, ActivePokemon me, ActivePokemon o)
*
EmptyPowerString:
    Header: String getPowerString()
    Body:
        return "--";
        ###
*
ApplyDamage:
    Header: void applyDamage(ActivePokemon me, ActivePokemon o, Battle b)
*
Aura:
    AddMapField: GetMultiplier:
        if (user.isAttackType(Type.{00})) {
            return 1 + .33*(victim.hasAbility(AbilityNamesies.AURA_BREAK) ? -1 : 1);
        }

        return 1;
        ###
*
RaiseAllStats:
    AddMapField: StatChange: Attack 1 Defense 1 Sp_Attack 1 Sp_Defense 1 Speed 1
*
ConsumeBerry:
    AddMapField: UniqueEffects:
        HoldItem item = victim.getHeldItem(b);
        if (item instanceof Berry) {
            Berry berry = (Berry)item;
            berry.eatBerry(b, user, victim);
        }
        ###
*
GenericMessage:
    Header: String getGenericMessage(ActivePokemon p)
    Body:
        return {0};
        ###
*
SourceMessage:
    Header: String getSourceMessage(ActivePokemon p, String sourceName)
    Body:
        return {0};
        ###
*
ChangeAttackType:
    Header: Type changeAttackType(Attack attack, Type original)
*
GetAttackType:
    Header: Type getAttackType(Type original)
*
AttackTypeMessage:
    Header: String getMessage(Battle b, ActivePokemon caster, ActivePokemon victim)
*
NormalTypeChanger:
    AddInterface: ChangeAttackTypeEffect
    AddMapField: ChangeAttackType:
        if (original == Type.NORMAL) {
            this.activated = true;
            return Type.{00};
        }

        return original;
        ###
    AddMapField: Field:
        private boolean activated;
        ###
    AddMapField: Constructor:
        this.activated = false;
        ###
    AddInterface: EndTurnEffect
    AddMapField: ApplyEndTurn:
        this.activated = false;
        ###
    AddMapField: PowerMultiplierCondition: 1.2 activated
*
NextLevel:
    AddMapField: StatLowered:
        // Doesn't raise for self-inflicted lowers
        if (caster != victim) {
            victim.getStages().modifyStage(victim, 2, Stat.{00}, b, CastSource.@SuperClass);
        }
        ###
*
StatLowered:
    AddInterface: StatLoweredEffect
    Header: void takeItToTheNextLevel(Battle b, ActivePokemon caster, ActivePokemon victim)
*
FlinchItem:
    AddMapField: FlingEffect:
        String message = "The " + this.getName() + " caused " + pelted.getName() + " to flinch!";
        Effect.apply(PokemonEffectNamesies.FLINCH, b, pelted, pelted, CastSource.USE_ITEM, message);
        ###
    AddMapField: OpponentTakeDamage:
        if (RandomUtils.chanceTest(10)) {
            String message = user.getName() + "'s " + this.getName() + " caused " + victim.getName() + " to flinch!";
            Effect.apply(PokemonEffectNamesies.FLINCH, b, user, victim, CastSource.HELD_ITEM, message);
        }
        ###
    AddInterface: OpponentTakeDamageEffect
    AddInterface: HoldItem
*
StatusFling:
    AddMapField: FlingEffect:
        StatusNamesies.{00}.getStatus().apply(b, pelted, pelted, pelted.getName() + " was {0_} by the " + this.getName() + "!");
        ###
*
# Like Flame Orb and Toxic Orb
StatusSelfInflictor:
    AddInterface: HoldItem, EndTurnEffect
    AddMapField: Price: 1000
    AddMapField: Cat: Misc
    AddMapField: StatusFling: {0}
    AddMapField: ApplyEndTurn:
        StatusNamesies.{00}.getStatus().apply(b, victim, victim, victim.getName() + " was {0_} by its " + this.getName() + "!");
        ###
*
TM:
    Header: AttackNamesies getAttack()
    Body:
        return AttackNamesies.{00};
        ###
    AddMapField: Cat: TM
*
ChangePriorityAbility:
    AddInterface: PriorityChangeEffect
    AddMapField: ChangePriority:
        return {2-} ? {1} : 0;
        ###
*
ChangePriority:
    Header: int changePriority(Battle b, ActivePokemon user)
*
Baby:
    Header: PokemonNamesies getBaby()
    Body:
        return PokemonNamesies.{00};
        ###
    AddInterface: IncenseItem
    AddMapField: Price: 5000
*
AbsorbDamage:
    Header: boolean absorbDamage(Battle b, ActivePokemon damageTaker, int damageAmount)
*
DamageTaken:
    Header: void damageTaken(Battle b, ActivePokemon damageTaker)
*
SapHealthMove:
    AddInterface: SapHealthMove
    AddMapField: MoveType: Healing
*
SapPercentage:
    Header: double sapPercentage()
    Body:
        return {0};
        ###
*
SapMessage:
    Header: String getSapMessage(ActivePokemon victim)
*
ShouldCrit:
    Header: boolean shouldCrit(Battle b, ActivePokemon attacking, ActivePokemon defending)
*
TempEffectMove:
    AddMapField: Field:
        private Effect effect;
        ###
    AddMapField: BeginAttack:
        this.effect = Effect.cast(PokemonEffectNamesies.{00}, b, attacking, attacking, CastSource.ATTACK, false);
        ###
    AddMapField: EndAttack:
        this.effect.deactivate();
        ###
*
IgnoreAbilityMove:
    AddMapField: TempEffectMove: BREAKS_THE_MOLD
*
GetCurableEffects:
    Header: Set<PokemonEffectNamesies> getCurableEffects()
    Body:
        return {0};
        ###
*
ReceiveEffect:
    AddInterface: EffectReceivedEffect
    Header: void receiveEffect(Battle b, ActivePokemon caster, ActivePokemon victim, EffectNamesies effectType)
*
StatusReceived:
    Header: void receiveStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusNamesies statusType)
*
OppStatusReceived:
    Header: void receiveStatus(Battle b, ActivePokemon victim, StatusNamesies statusType)
*
TheVeryEnd:
    AddInterface: SuperDuperEndTurnEffect
    Header: boolean theVeryVeryEnd(Battle b, ActivePokemon p)
*
PriorityPrevention:
    AddInterface: AttackBlocker
    AddMapField: Block:
        return b.getAttackPriority(user) > 0;
        ###
    AddMapField: BlockMessage: victim.getName() + "'s " + this.getName() + " prevents priority moves!!"
*
OpponentEndAttack:
    Header: void endsies(Battle b, ActivePokemon attacking)
*
TerrainStarter:
    AddInterface: EntryEffect
    AddMapField: Enter:
        String message = enterer.getName() + "'s " + this.getName() + " changed the field to {0} Terrain!";
        Effect.cast(TerrainNamesies.{00}_TERRAIN, b, enterer, enterer, CastSource.ABILITY, message);
        ###
*
MoldBreakerBreaker:
    Header: boolean unbreakableMold()
    Body:
        // Ability is not ignored even when the opponent breaks the mold
        return true;
        ###
*
Irreplaceable:
    Header: boolean isReplaceable()
    Body:
        return false;
        ###
*
Irrestealable:
    Header: boolean isStealable()
    Body:
        return false;
        ###
*
DropBelowHalfHealth:
    AddInterface: TakeDamageEffect
    AddMapField: OnTakeDamage:
        if (victim.getHPRatio() < .5 && (victim.getHP() + victim.getDamageTaken())/(double)victim.getMaxHP() >= .5) {
            {0}
        }
        ###
*
WildPokemonAlterer:
    Header: void alterWildPokemon(ActivePokemon playerFront, WildEncounterInfo encounterData, WildEncounter encounter)
    AddInterface: WildEncounterAlterer
*
NewTerrain:
    Header: void newTerrain(Battle b, ActivePokemon p, TerrainType newTerrain)
*
TerrainSeed:
    AddInterface: HoldItem
    AddInterface: TerrainCastEffect
    AddMapField: NewTerrain:
        if (newTerrain == TerrainType.{11} && p.getStages().modifyStage(p, 1, Stat.{22}, b, CastSource.HELD_ITEM)) {
            this.consumeItem(b, p);
        }
        ###
    AddMapField: Price: 4000
    AddMapField: Cat: Misc
    AddMapField: Fling: 10
*
BlockItem:
    AddInterface: OpponentItemBlockerEffect
    Header: boolean blockItem(Battle b, ActivePokemon p, ItemNamesies item)
*
FormChange:
    Header: void changeForm(ActivePokemon formsie)
    AccessModifier: Private
    Body:
        this.{1} = !{1};
        Messages.add(new MessageUpdate(formsie.getName() + " changed into " + ({1} ? "{4}" : "{2}") + " Forme!")
                        .withImageName(formsie.getPokemonInfo().getImageName(formsie.isShiny(), !formsie.isPlayer(), {1}), formsie.isPlayer())
        );
        ###
    AddMapField: Irrestealable: True
    AddMapField: Irreplaceable: True
    AddMapField: Field:
        private static final BaseStats {22}_STATS = new BaseStats(new int[] { {3_} });
        private static final BaseStats {44}_STATS = new BaseStats(new int[] { {5_} });

        private boolean {1};
        
        private BaseStats getStats() {
            return {1} ? {44}_STATS : {22}_STATS;
        }
        ###
    AddMapField: Constructor:
        this.{1} = false;
        ###
    AddInterface: DifferentStatEffect
    AddMapField: GetStat:
        // Need to calculate the new stat -- yes, I realize this is super inefficient and whatever whatever whatever
        return user.stats().calculate(stat, this.getStats());
        ###
*
EndTurnFormChange:
    Header: void checkFormChange(ActivePokemon formsie)
    AccessModifier: Private
    Body:
        if (this.{1} != {6-}) {
            changeForm(formsie);
        }
        ###
    AddMapField: FormChange: {1} {2} {3} {4} {5}
    AddInterface: EndTurnEffect
    AddInterface: EntryEffect
    AddMapField: Enter:
        {1} = false;
        checkFormChange(enterer);
        ###
    AddMapField: ApplyEndTurn:
        checkFormChange(victim);
        ###
*
EntryEndTurn:
    AddInterface: EntryEndTurnEffect
    Header: void applyEffect(Battle b, ActivePokemon p)
*
WeatherExtendingItem:
    AddInterface: HoldItem
    AddMapField: Cat: Misc
    AddMapField: Price: 4000
    AddInterface: WeatherExtendingEffect
    Header: WeatherNamesies getWeatherType()
    Body:
        return WeatherNamesies.{00};
        ###
*
ExtendEffect:
    Header: int getExtensionTurns(Effect receivedEffect, int numTurns)
    AddInterface: EffectExtendingEffect
*
PowerCountMove:
    AddInterface: PowerCountMove
    Header: boolean doubleDefenseCurled()
    Body:
        return {0};
        ###
*
# Heal Switch and Lunar Dance
HealSwitcher:
    AddMapField: Cat: Status
    AddMapField: TeamEffect: HealSwitch
    AddMapField: SelfTarget: True
    AddMapField: MoveType: User_Faints, Healing
*
FocusMove:
    AddMapField: MoveType: Assistless, Sleep_Talk_Fail, Metronomeless, Mirrorless
    AddMapField: Priority: -3
    AddMapField: PokemonEffect: {0}
    AddMapField: SelfTarget: True
    AddMapField: StartTurn:
        super.applyBasicEffects(b, me, me);
        me.setReducePP(true);
        ###
    AddMapField: ShouldApplyEffects:
        return false;
        ###
*
StoredPowerMove:
    AddMapField: Pow: 20
    AddMapField: Acc: 100
    AddMapField: PP: 10
    AddMapField: GetMultiplier:
        return 1 + user.getStages().totalStatIncreases();
        ###
*
StrikeFirstEffect:
    AddInterface: StrikeFirstEffect
    Header: boolean strikeFirst(Battle b, ActivePokemon striker)
*
StrikeFirstMessage:
    Header: String getStrikeFirstMessage(ActivePokemon striker)
    Body:
        return {0};
        ###
*
GET_DAT_CASH_MONEY_TWICE_ITEM:
    Header: void getDatCashMoneyGetDatCashMoneyCast(Battle b, ActivePokemon gettinDatCashMoneyTwice)
    AccessModifier: Private
    Body:
        Effect.cast(TeamEffectNamesies.GET_DAT_CASH_MONEY_TWICE, b, gettinDatCashMoneyTwice, gettinDatCashMoneyTwice, CastSource.HELD_ITEM, false);
        ###
    AddMapField: EntryEndTurn:
        // This is named too fantastically to just be applyEffect
        getDatCashMoneyGetDatCashMoneyCast(b, p);
        ###
*
