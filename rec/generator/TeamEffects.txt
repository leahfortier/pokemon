# The name of each effect and its contents.
# Blocks are separated by '*'
# Any function must be terminated by ### on a line by itself
# Fields can be specified in any order

Constructor:
    Namesies Enum TeamEffectNamesies
    MinTurns Default -1 Int
    MaxTurns Default -1 Int
    HasAlternateCast Default False Boolean
*
Failure:
    Header boolean applies(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source)
    CanHave Not Default True Boolean b.getTrainer(victim).hasEffect(this.namesies())
*

***

Reflect:
    SimpleBarrier: Defense reflect
*
LightScreen:
    SimpleBarrier: Sp_Defense light screen
*
Tailwind:
    ToModify: Speed
    SimpleModifier: 2 
    NumTurns: 4
    SubsideMessage: "The effects of tailwind faded."
    CastMessage: user.getName() + " raised the speed of its team!"
*
AuroraVeil:
    TwoModify: Defense Sp_Defense
    CastMessage: user.getName() + " is covered by an aurora veil!"
    Barrier: aurora veil
*
StickyWeb:
    Int: EntryEffect
    Enter:
        if (enterer.isLevitating(b)) {
            return;
        }

        // The sticky web lowered Charmander's Speed!
        enterer.getStages().modifyStage(
            b.getOtherPokemon(enterer), -1, Stat.SPEED, b, CastSource.EFFECT,
            (victimName, statName, changed) -> "The sticky web " + changed + " " + enterer.getName() + "'s " + statName + "!"
        );
        ###
    CastMessage: "Sticky web covers everything!"
    RapidSpin: "The sticky web spun away!"
    Defog: "The sticky web dispersed!"
*
StealthRock:
    Int: EntryEffect
    Enter: 
        double advantage = Type.ROCK.getAdvantage().getAdvantage(enterer, b);
        enterer.reduceHealthFraction(b, advantage/8.0, enterer.getName() + " was hurt by stealth rock!");
        ###
    CastMessage: "Floating rocks were scattered all around!"
    RapidSpin: "The floating rocks spun away!"
    Defog: "The floating rocks dispersed!"
*
ToxicSpikes:
    Int: EntryEffect
    Field: 
        private int layers;
        ###
    Activate: 
        this.layers = 1;
        ###
    Enter:
        // Can't touch this
        if (enterer.isLevitating(b)) {
            return;
        }
        
        // Poison-type Pokes absorb Toxic Spikes
        if (enterer.isType(b, Type.POISON)) {
            Messages.add(enterer.getName() + " absorbed the Toxic Spikes!");
            this.deactivate();
            return;
        }
        
        // Poison those bros
        ActivePokemon theOtherPokemon = b.getOtherPokemon(enterer);
        StatusNamesies poisonCondition = layers >= 2 ? StatusNamesies.BADLY_POISONED : StatusNamesies.POISONED;
        poisonCondition.getStatus().apply(b, theOtherPokemon, enterer, CastSource.EFFECT);
        ###
    CastMessage: "Toxic spikes were scattered all around!"
    CanHave: True
    AlternateCast:
        this.addCastMessage(b, caster, victim, source, printCast);
        this.layers++;
        ###
    RapidSpin: "The toxic spikes dispersed!"
    Defog: "The toxic spikes dispersed!"
*
Spikes:
    Int: EntryEffect
    Field: 
        private int layers;
        
        private double getReduceFraction() {
            switch (layers) {
                case 1:
                    return 1/8.0;
                case 2:
                    return 1/6.0;
                default:
                    return 1/4.0;
            }
        }
        ###
    Activate: 
        this.layers = 1;
        ###
    Enter: 
        if (!enterer.isLevitating(b)) {
            enterer.reduceHealthFraction(b, this.getReduceFraction(), enterer.getName() + " was hurt by spikes!");
        }
        ###
    CastMessage: "Spikes were scattered all around!"
    CanHave: True
    AlternateCast:
        this.addCastMessage(b, caster, victim, source, printCast);
        this.layers++;
        ###
    RapidSpin: "The spikes dispersed!"
    Defog: "The spikes dispersed!"
*
Wish:
    NumTurns: 2
    Field: 
        private String casterName;
        ###
    Subside:
        Messages.add(casterName + "'s wish came true!");
        p.healHealthFraction(1/2.0, b, p.getName() + "'s health was restored!");
        ###
    BeforeCast: 
        casterName = caster.getName();
        ###
    CastMessage: casterName + " made a wish!"
*
LuckyChant:
    NumTurns: 5
    CastMessage: "The lucky chant shielded " + victim.getName() + "'s team from critical hits!"
    SubsideMessage: "The effects of lucky chant wore off."
    Int: CritBlockerEffect
*
FutureSight:
    FutureAttackEffect: Future_Sight
*
DoomDesire:
    FutureAttackEffect: Doom_Desire
*
HealSwitch:
    Field: 
        private String wish;
        ###
    Int: EntryEffect
    Enter: 
        enterer.removeStatus();
        enterer.healHealthFraction(1, b, enterer.getName() + " health was restored due to the " + wish + "!");
        this.deactivate();
        ###
    BeforeCast: 
        wish = caster.getAttack().namesies() == AttackNamesies.LUNAR_DANCE ? "lunar dance" : "healing wish";
        ###
*
DeadAlly:
    NumTurns: 2
    CanHave: True
*
PayDay:
    Int: EndBattleEffect
    Field: 
        private int coins;
        ###
    AlternateCast:
        // TODO: This should be a battle effect since it only applies to the player
        this.addCastMessage(b, caster, victim, source, printCast);
        this.coins += 5*caster.getLevel();
        ###
    BeforeCast:
        coins = 5*caster.getLevel();
        ###
    CastMessage: "Coins scattered everywhere!"
    CanHave: True
    EndBattle:
        Messages.add(player.getName() + " picked up " + coins + " pokedollars!");
        player.getDatCashMoney(coins);
        ###
*
Safeguard:
    Defog: "The effects of " + released.getName() + "'s Safeguard faded."
    SafeguardEffect: Safeguard
*
GuardSpecial:
    SafeguardEffect: Guard Special
*
GetDatCashMoneyTwice:
*
