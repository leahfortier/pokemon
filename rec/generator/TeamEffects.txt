# The name of each effect and its contents.
# Blocks are separated by '*'
# Any function must be terminated by ### on a line by itself
# Fields can be specified in any order

Constructor:
    Namesies Enum TeamEffectNamesies
    MinTurns Default -1 Int
    MaxTurns Default -1 Int
    NextTurnSubside Default False Boolean
    HasAlternateCast Default False Boolean
*
Failure:
    Header boolean applies(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source)
    CanHave Not Default True Boolean b.getTrainer(victim).hasEffect(this.namesies())
*

***

Reflect:
    SimpleBarrier: Defense reflect
*
LightScreen:
    SimpleBarrier: Sp_Defense light screen
*
Tailwind:
    ToModify: Speed
    SimpleModifier: 2 
    NumTurns: 4
    SubsideMessage: "The effects of tailwind faded."
    CastMessage: user.getName() + " raised the speed of its team!"
*
AuroraVeil:
    TwoModify: Defense Sp_Defense
    CastMessage: user.getName() + " is covered by an aurora veil!"
    Barrier: aurora veil
*
StickyWeb:
    Int: EntryEffect
    Enter:
        if (enterer.isLevitating(b)) {
            return;
        }

        // The sticky web lowered Charmander's Speed!
        enterer.getStages().modifyStage(
            b.getOtherPokemon(enterer), -1, Stat.SPEED, b, CastSource.EFFECT,
            (victimName, statName, changed) -> "The sticky web " + changed + " " + enterer.getName() + "'s " + statName + "!"
        );
        ###
    CastMessage: "Sticky web covers everything!"
    RapidSpin: "The sticky web spun away!"
    Defog: "The sticky web dispersed!"
*
StealthRock:
    Int: EntryEffect
    Enter: 
        if (enterer.hasAbility(AbilityNamesies.MAGIC_GUARD)) {
            return;
        }
        
        double advantage = Type.ROCK.getAdvantage().getAdvantage(enterer, b);
        if (advantage == 0) {
            // Technically not totally necessary since Rock is not ineffective against any type but just in case anything changes we don't want to print
            return;
        }

        Messages.add(enterer.getName() + " was hurt by stealth rock!");
        enterer.reduceHealthFraction(b, advantage/8.0);
        ###
    CastMessage: "Floating rocks were scattered all around!"
    RapidSpin: "The floating rocks spun away!"
    Defog: "The floating rocks dispersed!"
*
ToxicSpikes:
    Int: EntryEffect
    Field: 
        private int layers;
        ###
    Activate: 
        this.layers = 1;
        ###
    Enter: 
        if (enterer.isLevitating(b)) {
            return;
        }
        
        if (enterer.isType(b, Type.POISON)) {
            Messages.add(enterer.getName() + " absorbed the Toxic Spikes!");
            super.active = false;
            return;
        }
        
        ActivePokemon theOtherPokemon = b.getOtherPokemon(enterer);
        StatusNamesies poisonCondition = layers >= 2 ? StatusNamesies.BADLY_POISONED : StatusNamesies.POISONED;
        poisonCondition.getStatus().apply(b, theOtherPokemon, enterer, CastSource.EFFECT);
        ###
    CastMessage: "Toxic spikes were scattered all around!"
    CanHave: True
    AlternateCast:
        ToxicSpikes spikesies = (ToxicSpikes)b.getEffects(victim).get(this.namesies);        
        spikesies.layers++;
        
        this.addCastMessage(b, caster, victim, source, printCast);
        ###
    RapidSpin: "The toxic spikes dispersed!"
    Defog: "The toxic spikes dispersed!"
*
Spikes:
    Int: EntryEffect
    Field: 
        private int layers;
        ###
    Activate: 
        this.layers = 1;
        ###
    Enter: 
        if (enterer.isLevitating(b) || enterer.hasAbility(AbilityNamesies.MAGIC_GUARD)) {
            return;
        }
        
        Messages.add(enterer.getName() + " was hurt by spikes!");
        if (layers == 1) {
            enterer.reduceHealthFraction(b, 1/8.0);
        } else if (layers == 2) {
            enterer.reduceHealthFraction(b, 1/6.0);
        } else {
            enterer.reduceHealthFraction(b, 1/4.0);
        }
        ###
    CastMessage: "Spikes were scattered all around!"
    CanHave: True
    AlternateCast:
        Spikes spikesies = (Spikes)b.getEffects(victim).get(this.namesies);
        spikesies.layers++;
        
        this.addCastMessage(b, caster, victim, source, printCast);
        ###
    RapidSpin: "The spikes dispersed!"
    Defog: "The spikes dispersed!"
*
Wish:
    NumTurns: 1
    NextTurnSubside: True
    Field: 
        private String casterName;
        ###
    Subside: 
        p.healHealthFraction(1/2.0, b, casterName + "'s wish came true!");
        ###
    BeforeCast: 
        casterName = caster.getName();
        ###
*
LuckyChant:
    NumTurns: 5
    CastMessage: "The lucky chant shielded " + victim.getName() + "'s team from critical hits!"
    SubsideMessage: "The effects of lucky chant wore off."
    Int: CritBlockerEffect
*
FutureSight:
    FutureAttackEffect: Future_Sight
*
DoomDesire:
    FutureAttackEffect: Doom_Desire
*
HealSwitch:
    Field: 
        private String wish;
        ###
    Int: EntryEffect
    Enter: 
        enterer.removeStatus();
        enterer.healHealthFraction(1, b, enterer.getName() + " health was restored due to the " + wish + "!");
        super.active = false;
        ###
    BeforeCast: 
        wish = caster.getAttack().namesies() == AttackNamesies.LUNAR_DANCE ? "lunar dance" : "healing wish";
        ###
*
DeadAlly:
    NumTurns: 2
    CanHave: True
*
PayDay:
    Int: EndBattleEffect
    Field: 
        private int coins;
        ###
    AlternateCast:
        PayDay payday = (PayDay)b.getEffects(true).get(this.namesies);
        payday.coins += 5*caster.getLevel();
        
        this.addCastMessage(b, caster, victim, source, printCast);
        ###
    BeforeCast:
        coins = 5*caster.getLevel();
        ###
    CastMessage: "Coins scattered everywhere!"
    CanHave: True
    EndBattle: 
        Messages.add(player.getName() + " picked up " + coins + " pokedollars!");
        player.getDatCashMoney(coins);
        ###
*
Safeguard:
    Defog: "The effects of " + released.getName() + "'s Safeguard faded."
    SafeguardEffect: Safeguard
*
GuardSpecial:
    SafeguardEffect: Guard Special
*
GetDatCashMoneyTwice:
*
