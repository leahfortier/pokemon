# The name of each effect and its contents.
# Blocks are separated by '*'
# Any function must be terminated by ### on a line by itself
# Fields can be specified in any order

Constructor:
    Namesies Enum StandardBattleEffectNamesies
    MinTurns Default -1 Int
    MaxTurns Default -1 Int
    CanHave Default False Boolean
    HasAlternateCast Default False Boolean
*

***

Gravity:
    NumTurns: 5
    Int: GroundedEffect, StageChangingEffect
    StageChange:
        return s == Stat.EVASION ? -2 : 0;
        ###
    CastMessage: "Gravity intensified!"
    AfterCast:
        removeLevitation(b, caster);
        removeLevitation(b, victim);
        ###
    SubsideMessage: "The gravity returned to normal."
*
WaterSport:
    Sporty: Fire Fire Water
*
MudSport:
    Sporty: Electric Electricity Mud
*
WonderRoom:
    Int: StatSwitchingEffect
    SwitchStat:
        // Defense and Special Defense are swapped
        if (s == Stat.DEFENSE) {
            return Stat.SP_DEFENSE;
        } else if (s == Stat.SP_DEFENSE) {
            return Stat.DEFENSE;
        } else {
            return s;
        }
        ###
    SpecialRoom: wonder switch defense and special defense
*
TrickRoom:
    SpecialRoom: trick switch speeds
*
MagicRoom:
    Int: ItemBlockerEffect
    SpecialRoom: magic prevent using items
*
FieldUproar:
    StatusPrevent:
        if (status == StatusNamesies.ASLEEP) {
            return ApplyResult.failure("The uproar prevents sleep!!");
        }
        ###
    TheVeryEnd:
        if (b.getPlayer().front().hasEffect(PokemonEffectNamesies.UPROAR) || b.getOpponent().front().hasEffect(PokemonEffectNamesies.UPROAR)) {
            return false;
        }

        this.deactivate();
        return true;
        ###
*
PowerSplit:
    StatSplit: Attack Sp_Attack power
*
GuardSplit:
    StatSplit: Defense Sp_Defense defense
*
JawLocked:
    Field:
        // The player Pokemon and opponent Pokemon that are locked by the jaw
        private ActivePokemon p;
        private ActivePokemon opp;
        
        // Checks if Pokemon are still Jaw Locked, and deactives and returns false if not
        private boolean checkActive(Battle b) {
            // If either Pokemon is no longer jaw locked, then neither of them are
            if (this.unlocked(b, p) || this.unlocked(b, opp)) {
                this.deactivate();
                return false;
            }

            // Still jaw locked
            return true;
        }

        // Returns true if the Pokemon is no longer jaw locked
        // Confirms this by the Pokemon being dead or not the front Pokemon
        // Note: Still need to confirm the same is true for the other
        private boolean unlocked(Battle b, ActivePokemon jawLocked) {
            return jawLocked.isFainted(b) || b.getTrainer(jawLocked).front() != jawLocked;
        }
        ###
    Int: TrappingEffect, BattleEndTurnEffect
    TrappingMessage: trapped.getName() + " is trapped by Jaw Lock!"
    Trapped:
        // TODO: Maybe check once there's more information if this should work on Ghost-type Pokemon (currently it does)
        // TODO: Also I made Jaw Lock a biting move which it should be regardless but if I already have a todo to look it up might as well confirm that too
        // Check if Pokemon are still Jaw Locked together
        if (this.checkActive(b)) {
            // Just to be safe
            return escaper == p || escaper == opp;
        }

        return false;
        ###
    BeforeCast:
        if (caster.isPlayer() == victim.isPlayer()) {
            Global.error("Caster and victim should be the opposite teams for Jaw Lock.");
        }

        this.p = caster.isPlayer() ? caster : victim;
        this.opp = caster.isPlayer() ? victim : caster;
        ###
    CastMessage: user.getName() + " locked jaws with " + victim.getName() + "!"
    BattleEndTurn:
        // Deactivate if Jaw Locked Pokemon aren't around
        this.checkActive(b);
        ###
*
