# The EffectList parameter should contain the ActivePokemon parameter that represents the entire invokee list
# If this is unspecified, then the invokee list will default to being passed in as a new parameter in the invoke method

ApplyDamageEffect:
	Comments: // This is used when the user applies direct damage to an opponent, and has special effects associated with the user
	Method:
		Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, int damage)
		Comments:
			// b: The current battle
			// user: The user of that attack, the one who is implementing this effect
			// victim: The Pokemon that received the attack
			// damage: The amount of damage that was dealt to victim by the user
			###
		Invoke: Void
		EffectList: user
		InvokeAttack: user
		Deadsies: user
	*
***
OpponentApplyDamageEffect:
	Comments: // This is used when the user applies direct damage to an opponent, and has special effects associated with the user
	Method:
		Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, int damage)
		Comments:
			// b: The current battle
			// user: The user of that attack
			// victim: The Pokemon that received the attack, the one who is probably implementing this effect
			// damage: The amount of damage that was dealt to victim by the user
			###
		Invoke: Void
		EffectList: victim
		Deadsies: user
	*
***
EndTurnEffect:
	Method:
		Header: void applyEndTurn(ActivePokemon victim, Battle b)
		Invoke: Void
		Deadsies: victim
		SetInvokees:
			// Weather is handled separately
			List<InvokeEffect> invokees = b.getEffectsList(victim);
			invokees.remove(b.getWeather());
			###
	*
***
SuperDuperEndTurnEffect:
	Method:
		Header: boolean theVeryVeryEnd(Battle b, ActivePokemon p)
		Invoke: Check true
		EffectList: p
	*
***
RecoilMove:
	Method:
		Header: void applyRecoil(Battle b, ActivePokemon user, int damage)
	*
	Extends: AttackInterface, ApplyDamageEffect
	Method:
		Override: True
		Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, int damage)
		Default:
			this.applyRecoil(b, user, damage);
			###
	*
***
RecoilPercentageMove:
	Extends: RecoilMove
	Method:
		Header: int getDamagePercentageDenominator()
	*
	Method:
		Override: True
		Header: void applyRecoil(Battle b, ActivePokemon user, int damage)
		Default:
			if (user.hasAbility(AbilityNamesies.ROCK_HEAD) || user.hasAbility(AbilityNamesies.MAGIC_GUARD)) {
                return;
            }

            Messages.add(user.getName() + " was hurt by recoil!");
            user.reduceHealth(b, (int)Math.ceil((double)damage/getDamagePercentageDenominator()), false);
			###
	*
***
SelfHealingMove:
    Extends: AttackInterface
	Method:
		Header: double getHealFraction(Battle b, ActivePokemon victim)
	*
	Method:
		Header: void heal(Battle b, ActivePokemon victim)
		Default:
			// Heal yourself!
			victim.healHealthFraction(this.getHealFraction(b, victim));

			// TODO: Make sure the message is set up correctly for the hp change
			Messages.add(new MessageUpdate(victim.getName() + "'s health was restored!").updatePokemon(b, victim));
			###
	*
***
PhysicalContactEffect:
	Method:
		Comments:
			// b: The current battle
			// user: The user of the attack that caused the physical contact
			// victim: The Pokemon that received the physical contact attack
			###
		Header: void contact(Battle b, ActivePokemon user, ActivePokemon victim)
	*
	Extends: OpponentApplyDamageEffect
	Method:
		Override: True
		Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, int damage)
		Default:
			// Only apply if physical contact is made
			if (user.getAttack().isMoveType(MoveType.PHYSICAL_CONTACT) && !user.hasAbility(AbilityNamesies.LONG_REACH)) {
				this.contact(b, user, victim);
			}
			###
	*
***
TakeDamageEffect:
	Method:
		Comments:
			// b: The current battle
			// user: The user of the attack
			// victim: The one who is taking damage and is implementing this effect
			###
		Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
		EffectList: victim
		Invoke: Void
		Deadsies: victim
	*
***
OpponentTakeDamageEffect:
	Method:
		Comments:
			// b: The current battle
			// user: The user of the attack and implementer of the effect
			// victim: The Pokemon who is taking damage
			###
		Header: void takeDamage(Battle b, ActivePokemon user, ActivePokemon victim)
		EffectList: user
		Invoke: Void
		Deadsies: victim
	*
***
CrashDamageMove:
    Extends: AttackInterface
	Method:
		Header: void crash(Battle b, ActivePokemon user)
		Move: user
		Invoke: Void
	*
***
EffectReleaser:
    Method:
        Header: void release(Battle b, ActivePokemon released, String releaseMessage)
        Default:
            Messages.add(releaseMessage);

            if (this instanceof PokemonEffect) {
                released.getEffects().remove((PokemonEffect)this);
            } else if (this instanceof TeamEffect) {
                b.getTrainer(released).getEffects().remove((TeamEffect)this);
            } else {
                Global.error("Invalid release object " + this.getClass().getSimpleName());
            }
            ###
    *
***
BarrierEffect:
	Extends: EffectReleaser
    Method:
        Header: String getBreakMessage(ActivePokemon breaker)
    *
    Method:
		Header: void breakBarrier(Battle b, ActivePokemon breaker, ActivePokemon broken)
		EffectList: broken
		Invoke: Void
		InvokeName: breakBarriers
        Default:
            this.release(b, broken, this.getBreakMessage(breaker));
            ###
	*
***
DefogRelease:
    Extends: EffectReleaser
    Method:
        Header: String getDefogReleaseMessage(ActivePokemon released)
    *
    Method:
		Header: void releaseDefog(Battle b, ActivePokemon released)
		Invoke: Void
		EffectList: released
		InvokeName: release
        Default:
            this.release(b, released, this.getDefogReleaseMessage(released));
            ###
	*
***
RapidSpinRelease:
    Extends: EffectReleaser
    Method:
        Header: String getRapidSpinReleaseMessage(ActivePokemon released)
    *
    Method:
		Header: void releaseRapidSpin(Battle b, ActivePokemon released)
		Invoke: Void
		EffectList: released
		InvokeName: release
        Default:
            this.release(b, released, this.getRapidSpinReleaseMessage(released));
            ###
	*
***
NameChanger:
	Method:
		Comments: // TODO: Not a fan that this only operates on the ability but then again I'm not passing the battle in here and also fuck illusion srsly I might just special case it since it's so fucking unique
		Header: String getNameChange()
		Invoke: Get
		InvokeParameters: ActivePokemon p
		SetInvokees: List<InvokeEffect> invokees = Collections.singletonList(p.getAbility());
		InvokeName: getChangedName
	*
	Method:
		Header: void setNameChange(Battle b, ActivePokemon victim)
		Invoke: Void
		EffectList: victim
		InvokeName: setNameChanges
	*
***
EntryEffect:
	Method:
		Header: void enter(Battle b, ActivePokemon enterer)
		Invoke: void
		EffectList: enterer
	*
***
StatLoweredEffect:
	Method:
		Comments:
			// b: The current battle
			// caster: The Pokemon responsible for causing the stat to be lowered
			// victim: The Pokemon who's stat is being lowered
			###
		Header: void takeItToTheNextLevel(Battle b, ActivePokemon caster, ActivePokemon victim)
		Invoke: Void
		EffectList: victim
	*
***
LevitationEffect:
	Method:
		Header: void fall(Battle b, ActivePokemon fallen)
		Invoke: Void
		EffectList: fallen
		InvokeName: falllllllll
		Default: Empty
	*
	Method:
		Parameters: Battle b, ActivePokemon p, ActivePokemon moldBreaker
		Invoke: Contains
		EffectList: p
		MoldBreaker: moldBreaker
	*
***
MurderEffect:
	Comments: // KILL KILL KILL MURDER MURDER MURDER
	Method:
		Header: void killWish(Battle b, ActivePokemon dead, ActivePokemon murderer)
		Invoke: Void
		InvokeName: killKillKillMurderMurderMurder
		EffectList: murderer
		InvokeAttack: murderer
	*
***
EndBattleEffect:
	Method:
		Header: void afterBattle(Trainer player, Battle b, ActivePokemon p)
		Invoke: Void
	*
***
GroundedEffect:
	Method:
		Parameters: Battle b, ActivePokemon p
		Invoke: Contains
		EffectList: p
	*
	Extends: SelfAttackBlocker
	Method:
		Override: True
		Header: boolean block(Battle b, ActivePokemon user)
		Default:
			return user.getAttack().isMoveType(MoveType.AIRBORNE);
			###
	*
	Method:
		Header: void removeLevitation(Battle b, ActivePokemon p)
		Default:
			if (p.isSemiInvulnerableFlying()) {
				((MultiTurnMove)p.getAttack()).resetReady();
				Messages.add(p.getName() + " fell to the ground!");
                EffectNamesies.FLINCH.getEffect().cast(b, p, p, CastSource.EFFECT, false);
			}

			LevitationEffect.falllllllll(b, p);
			###
	*
***
SemiInvulnerableBypasser:
	Method:
		Comments:
			// Attacker is the Pokemon whose accuracy is being evaluated and is the Pokemon on which this effect is attached to
			// This is evaluated BEFORE the semi-invulnerable checks, so if this returns true, the move will hit even if the defending is semi-invulnerable
			###
		Header: boolean semiInvulnerableBypass(Battle b, ActivePokemon attacking, ActivePokemon defending)
		Invoke: Check true
		InvokeName: bypassAccuracyCheck
		EffectList: attacking
		InvokeAttack: attacking
	*
***
BasicAccuracyBypassEffect:
	Method:
		Comments: 
			// Attacker is the Pokemon whose accuracy is being evaluated and is the Pokemon on which this effect is attached to
			// This is evaluated AFTER the semi-invulnerable checks
			// Should use SemiInvulnerableBypasser for moves that hit fly, dig, etc.
			###
		Header: boolean bypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
		Invoke: Check true
		InvokeName: bypassAccuracyCheck
		EffectList: attacking
		InvokeAttack: attacking
	*
***
OpponentAccuracyBypassEffect:
	Method:
		Comments: 
			// Attacker is the Pokemon whose accuracy is being evaluated, defender is the Pokemon on which this effect is attached to
			// This is evaluated BEFORE the semi-invulnerable checks, so if this returns true, the move will hit even if the defending is semi-invulnerable
			###
		Header: boolean opponentBypassAccuracy(Battle b, ActivePokemon attacking, ActivePokemon defending)
		Invoke: Check true
		InvokeName: bypassAccuracyCheck
		EffectList: defending
	*
***
AttackSelectionEffect:
	Method:
		Header: boolean usable(Battle b, ActivePokemon p, Move m)
		Invoke: CheckGet false
		InvokeName: getUnusableEffect
		EffectList: p
	*
	Method:
		Header: String getUnusableMessage(Battle b, ActivePokemon p)
	*
***
WeatherBlockerEffect:
	Method:
		Header: boolean block(EffectNamesies weather)
		Invoke: Check true
		InvokeName: checkBlocked
		InvokeParameters: Battle b, ActivePokemon p
		EffectList: p
	*
***
TrappingEffect:
	Comments: // Any effect that implements this will prevent a Pokemon with said effect from escaping battle
	Method:
		Header: String trappingMessage(ActivePokemon trapped)
	*
	Method:
		Header: boolean trapped(Battle b, ActivePokemon escaper)
		Default:
			// Ghost-type Pokemon can always escape
			return !escaper.isType(b, Type.GHOST);
			###
		Invoke: CheckMessage true trappingMessage(escaper)
		InvokeName: isTrapped
		EffectList: escaper
	*
***
OpponentTrappingEffect:
	Method:
		Header: boolean trapOpponent(Battle b, ActivePokemon escaper, ActivePokemon trapper)
		Invoke: CheckMessage true opponentTrappingMessage(escaper, trapper)
		InvokeName: isTrapped
		EffectList: trapper
	*
	Method:
		Header: String opponentTrappingMessage(ActivePokemon escaper, ActivePokemon trapper)
	*
***
BeforeTurnEffect:
	Method:
		Comments: // TODO: Rename these to attacking and defending
		Header: boolean canAttack(ActivePokemon p, ActivePokemon opp, Battle b)
		Invoke: Check false
		InvokeName: checkCannotAttack
		Deadsies: p opp
		EffectList: p
	*
***
EffectBlockerEffect:
	Method:
		Header: boolean validMove(Battle b, ActivePokemon user, ActivePokemon victim)
		Invoke: Check false
		InvokeName: checkBlocked
		MoldBreaker: user
		EffectList: victim
	*
***
TargetSwapperEffect:
	Method:
		Header: boolean swapTarget(Battle b, ActivePokemon user, ActivePokemon opponent)
		Invoke: Check true
		InvokeName: checkSwapTarget
		MoldBreaker: user
		EffectList: opponent
	*
***
CritBlockerEffect:
	Method:
		Header: boolean blockCrits()
		Default:
			return true;
			###
		Invoke: Check true
		InvokeName: checkBlocked
		InvokeParameters: Battle b, ActivePokemon attacking, ActivePokemon defending
		MoldBreaker: attacking
		EffectList: defending
		InvokeAttack: attacking
	*
***
StatProtectingEffect:
    Extends: InvokeEffect
	Method:
		Header: boolean prevent(Battle b, ActivePokemon caster, ActivePokemon victim, Stat stat)
		Invoke: CheckGet true
		InvokeName: getPreventEffect
		EffectList: victim
		MoldBreaker: caster
	*
	Method:
		Header: String preventionMessage(Battle b, ActivePokemon p, Stat s)
		Default:
            String statName = s.getName().toLowerCase();
            
            CastSource source = this.getSource().getCastSource();
            if (source.hasSourceName()) {
                String sourceName = source.getSourceName(b, p);
                return p.getName() + "'s " + sourceName + " prevents its " + statName + " from being lowered!";
            }

            return p.getName() + "'s " + statName + " cannot be lowered!";
			###
	*
***
StatusPreventionEffect:
	Method:
		Comments: // TODO: Would be nice in the future if I am able to implement multiple invoke methods for the same interface method since this could also use a basic check invoke as well
		Header: boolean preventStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusCondition status)
		Invoke: CheckGet true
		InvokeName: getPreventEffect
		EffectList: victim
		MoldBreaker: caster
	*
	Method:
		Header: String statusPreventionMessage(ActivePokemon victim)
	*
***
BracingEffect:
	Method:
		Header: boolean isBracing(Battle b, ActivePokemon bracer, boolean fullHealth)
		Invoke: CheckGet true
		InvokeName: getBracingEffect
		EffectList: bracer
		MoldBreaker: b.getOtherPokemon(bracer)
	*
	Method:
		Header: String braceMessage(ActivePokemon bracer)
	*
***
OpponentIgnoreStageEffect:
	Method:
		Header: boolean ignoreStage(Stat s)
		Invoke: Check true
		InvokeName: checkIgnoreStage
		InvokeParameters: Battle b, ActivePokemon stagePokemon, ActivePokemon other
		MoldBreaker: stagePokemon
		StatInvokeAttack: other
	*
***
ChangeTypeEffect:
	Method:
		Comments: // Guarantee the change-type effect to be first
		Header: PokeType getType(Battle b, ActivePokemon p, boolean display)
		Invoke: Get
		InvokeName: getChangedType
		EffectList: p
		EffectPriority: p.getEffect(EffectNamesies.CHANGE_TYPE)
	*
***
ForceMoveEffect:
	Method:
		Header: Move getForcedMove(ActivePokemon attacking)
		Invoke: Get
		InvokeName: getForcedMove
		InvokeParameters: Battle b
		EffectList: attacking
        InvokeAttack: attacking
	*
***
DifferentStatEffect
	Method:
		Header: Integer getStat(ActivePokemon user, Stat stat)
		Invoke: Get
		InvokeName: getStat
		InvokeParameters: Battle b
		EffectList: user
	*
***
CritStageEffect:
	Method:
		Header: int increaseCritStage(int stage, ActivePokemon p)
		Default:
			return stage + 1;
			###
		Invoke: Update
		Update: stage
		InvokeName: updateCritStage
		InvokeParameters: Battle b
		EffectList: p
		InvokeAttack: p
	*
***
PriorityChangeEffect:
	Method:
		Header: int changePriority(Battle b, ActivePokemon user)
		Invoke: Add
		InvokeName: getModifier
		EffectList: user
	*
***
ChangeAttackTypeEffect:
	Method:
		Header: Type changeAttackType(Attack attack, Type original)
		Invoke: Update
		Update: original
		InvokeParameters: Battle b, ActivePokemon attacking
		EffectList: attacking
		InvokeName: updateAttackType
	*
***
AttackingNoAdvantageChanger:
	Method:
		Header: boolean negateNoAdvantage(Type attackingType, Type defendingType)
		Invoke: Check true
		InvokeParameters: Battle b, ActivePokemon attacking
		EffectList: attacking
	*
***
DefendingNoAdvantageChanger:
	Method:
		Header: boolean negateNoAdvantage(Type attackingType, Type defendingType)
		Invoke: Check true
		InvokeParameters: Battle b, ActivePokemon defending
		EffectList: defending
	*
***
ChangeMoveListEffect:
	Method:
		Header: List<Move> getMoveList(List<Move> actualMoves)
		Invoke: Get
		InvokeParameters: Battle b, ActivePokemon p
		EffectList: p
		InvokeName: getMoveList
	*
***
StatSwitchingEffect:
	Method:
		Header: Stat getSwitchStat(Battle b, ActivePokemon statPokemon, Stat s)
		Invoke: Update
		Update: s
		EffectList: statPokemon
		InvokeAttack: statPokemon
		InvokeName: switchStat
	*
***
OpponentStatSwitchingEffect:
	Method:
		Header: Stat getSwitchStat(Stat s)
		Invoke: Update
		Update: s
		InvokeParameters: Battle b, ActivePokemon other
		InvokeName: switchStat
		StatInvokeAttack: other
	*
***
HalfWeightEffect:
	Method:
		Header: int getHalfAmount(int halfAmount)
		Invoke: Update
		Update: halfAmount
		InvokeName: updateHalfAmount
		InvokeParameters: Battle b, ActivePokemon anorexic
		MoldBreaker: b.getOtherPokemon(anorexic)
		EffectList: anorexic
	*
***
StageChangingEffect:
	Method:
		Header: int adjustStage(Battle b, ActivePokemon p, ActivePokemon opp, Stat s)
		Invoke: Add
		MoldBreakerNullCheck: s.user() ? null : opp
		EffectList: p
	*
***
StatModifyingEffect:
	Method:
		Header: double modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s)
		Invoke: Multiply
		EffectList: p
		MoldBreakerNullCheck: s.user() ? null : opp
	*
***
SimpleStatModifyingEffect:
	Extends: StatModifyingEffect
	Method:
		Header: boolean isModifyStat(Stat s)
	*
	Method:
		Header: double getModifier()
	*
	Method:
		Header: boolean canModifyStat(Battle b, ActivePokemon p, ActivePokemon opp)
		Default:
			return true;
			###
	*
	Method:
		Override: True
		Header: double modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s)
		Default:
			if (isModifyStat(s) && canModifyStat(b, p, opp)) {
					return getModifier();
			}

			return 1;
			###
	*
***
StatChangingEffect:
	Method:
		Comments:
			// b: The current battle
			// p: The Pokemon that the stat is being altered on
			// opp: The opposing Pokemon
			// s: The stat that is being altered
			// stat: The current value of stat s
			// Return: The modified value of stat, if stat was not altered, just return stat
			###
		Header: int modify(Battle b, ActivePokemon p, ActivePokemon opp, Stat s, int stat)
		Invoke: Update
		Update: stat
		InvokeName: modifyStat
		EffectList: p
		MoldBreakerNullCheck: s.user() ? null : opp
	*
***
EffectChanceMultiplierEffect:
	Method:
		Header: double getEffectChanceMultiplier(ActivePokemon user)
        InvokeParameters: Battle b
		Invoke: Multiply
		EffectList: user
	*
***
PowerChangeEffect:
	Method:
		Header: double getMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
		Invoke: Multiply
		EffectList: user
		InvokeAttack: user
	*
***
OpponentPowerChangeEffect:
	Method:
		Header: double getOpponentMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
		Invoke: Multiply
		EffectList: victim
		MoldBreaker: user
	*
***
AdvantageMultiplierMove:
    Extends: AttackInterface
	Method:
		Header: double multiplyAdvantage(Type attackingType, PokeType defendingTypes)
		Invoke: Multiply
		InvokeParameters: ActivePokemon attacking
		Move: attacking
	*
***
AbsorbDamageEffect:
	Method:
		Header: boolean absorbDamage(Battle b, ActivePokemon damageTaker, int damageAmount)
		Invoke: Check true
		EffectList: damageTaker
	*
***
DamageTakenEffect:
	Method:
		Header: void damageTaken(Battle b, ActivePokemon damageTaker)
		Invoke: void
		EffectList: damageTaker
	*
***
AlwaysCritEffect:
	Method:
		Header: boolean shouldCrit(Battle b, ActivePokemon attacking, ActivePokemon defending)
		Default:
			return true;
			###
		Invoke: Check true
		EffectList: attacking
		InvokeAttack: attacking
		InvokeName: defCritsies
	*
***
EffectCurerEffect:
    Extends: EffectReceivedEffect, EndTurnEffect
    Method:
        Header: Set<EffectNamesies> getCurableEffects()
    *
    Method:
        Header: String getRemoveMessage(ActivePokemon victim, EffectNamesies effectType)
    *
    Method:
        Header: boolean usesies(ActivePokemon user)
        Default:
            boolean used = false;
            for (EffectNamesies removableEffect : this.getCurableEffects()) {
                if (user.getEffects().remove(removableEffect)) {
                    used = true;
                    Messages.add(this.getRemoveMessage(user, removableEffect));
                }
            }

            return used;
            ###
    *
    Method:
        Header: void receiveEffect(Battle b, ActivePokemon caster, ActivePokemon victim, EffectNamesies effectType)
        Override: True
        Default:
        if (this.getCurableEffects().contains(effectType)) {
            Messages.add(this.getRemoveMessage(victim, effectType));
            victim.getEffects().remove(effectType);
            victim.consumeItem(b);
        }
        ###
    *
    Method:
        Header: void applyEndTurn(ActivePokemon victim, Battle b)
        Override: True
        Default:
            if (usesies(victim)) {
                victim.consumeItem(b);
            }
            ###
    *
***
EffectReceivedEffect:
	Method:
		Header: void receiveEffect(Battle b, ActivePokemon caster, ActivePokemon victim, EffectNamesies effectType)
		Invoke: Void
		EffectList: victim
	*
***
StatusReceivedEffect:
	Method:
		Header: void receiveStatus(Battle b, ActivePokemon caster, ActivePokemon victim, StatusCondition statusType)
		Invoke: Void
		EffectList: victim
	*
***
OpponentStatusReceivedEffect:
	Method:
		Header: void receiveStatus(Battle b, ActivePokemon victim, StatusCondition statusType)
		Invoke: Void
		EffectList: b.getOtherPokemon(victim)
	*
***
SleepyFightsterEffect:
	Method:
		Parameters: Battle b, ActivePokemon p
		Invoke: Contains
		EffectList: p
		InvokeAttack: p
	*
***
OpponentEndAttackEffect:
	Method:
		Header: void endsies(Battle b, ActivePokemon attacking)
		Invoke: Void
		EffectList: b.getOtherPokemon(attacking)
	*
***
TerrainCastEffect:
	Method:
		Header: void newTerrain(Battle b, ActivePokemon p, TerrainType newTerrain)
		Invoke: Void
		EffectList: p
	*
***
AttackBlocker:
	Method:
		Header: boolean block(Battle b, ActivePokemon user, ActivePokemon victim)
		Invoke: CheckGet true
		InvokeName: checkBlocked
		MoldBreaker: user
		EffectList: victim
	*
	Method:
		Header: void alternateEffect(Battle b, ActivePokemon user, ActivePokemon victim)
		Default: Empty
	*
	Method:
		Header: String getBlockMessage(Battle b, ActivePokemon user, ActivePokemon victim)
		Default:
			return Effect.DEFAULT_FAIL_MESSAGE;
			###
	*
***
SelfAttackBlocker:
	Method:
		Header: boolean block(Battle b, ActivePokemon user)
		Invoke: CheckGet true
		InvokeName: checkBlocked
		EffectList: user
		InvokeAttack: user
	*
	Method:
		Header: String getBlockMessage(Battle b, ActivePokemon user)
		Default:
			return Effect.DEFAULT_FAIL_MESSAGE;
			###
	*
***
ItemSwapperEffect:
	Method:
		Header: String getSwitchMessage(ActivePokemon user, Item userItem, ActivePokemon victim, Item victimItem)
	*
    Method:
        Header: void swapItems(Battle b, ActivePokemon user, ActivePokemon victim)
        Default:
            Item userItem = user.getHeldItem(b);
            Item victimItem = victim.getHeldItem(b);

            Messages.add(this.getSwitchMessage(user, userItem, victim, victimItem));

            // For wild battles, an actual switch occurs
            if (b.isWildBattle()) {
                user.giveItem((HoldItem)victimItem);
                victim.giveItem((HoldItem)userItem);
            } else {
                user.setCastSource(victimItem);
                EffectNamesies.CHANGE_ITEM.getEffect().apply(b, user, user, CastSource.CAST_SOURCE, false);

                user.setCastSource(userItem);
                EffectNamesies.CHANGE_ITEM.getEffect().apply(b, user, victim, CastSource.CAST_SOURCE, false);
            }
            ###
    *
***
SwapOpponentEffect:
	Method:
		Header: String getSwapMessage(ActivePokemon user, ActivePokemon victim)
	*
    Method:
        Header: void swapOpponent(Battle b, ActivePokemon user, ActivePokemon victim)
        Default:
            if (!user.canSwapOpponent(b, victim)) {
                return;
            }

            Messages.add(this.getSwapMessage(user, victim));

            Team opponent = b.getTrainer(victim);
            if (opponent instanceof WildPokemon) {
                // End the battle against a wild Pokemon
                Messages.add(new MessageUpdate().withUpdate(MessageUpdateType.EXIT_BATTLE));
            } else {
                Trainer trainer = (Trainer)opponent;

                // Swap to a random Pokemon!
                trainer.switchToRandom(b);
                b.enterBattle(trainer.front(), enterer -> "...and " + enterer.getName() + " was dragged out!");
            }
            ###
    *
***
ProtectingEffect:
	Extends: AttackBlocker
	Method:
		Header: void protectingEffects(Battle b, ActivePokemon p, ActivePokemon opp)
		Default: Empty
	*
	Method:
		Header: boolean protectingCondition(Battle b, ActivePokemon attacking)
		Default:
			return true;
			###
	*
	Method:
		Override: True
		Header: boolean block(Battle b, ActivePokemon user, ActivePokemon victim)
		Default:
			Attack attack = user.getAttack();
			return protectingCondition(b, user) && !attack.isSelfTargetStatusMove() && !attack.isMoveType(MoveType.FIELD) && !attack.isMoveType(MoveType.PROTECT_PIERCING);
			###
	*
	Method:
		Override: True
		Header: void alternateEffect(Battle b, ActivePokemon user, ActivePokemon victim)
		Default:
			CrashDamageMove.invokeCrashDamageMove(b, user);
			this.protectingEffects(b, user, victim);
			###
	*
	Method:
		Override: True
		Header: String getBlockMessage(Battle b, ActivePokemon user, ActivePokemon victim)
		Default:
			return victim.getName() + " is protecting itself!";
			###
	*
***
AttackSelectionSelfBlockerEffect:
	Extends: AttackSelectionEffect, SelfAttackBlocker
	Method:
		Override: True
		Header: boolean block(Battle b, ActivePokemon user)
		Default:
			return !this.usable(b, user, user.getMove());
			###
	*
***
PowderMove:
	Extends: AttackInterface, SelfAttackBlocker
	Method:
		Override: True
		Header: boolean block(Battle b, ActivePokemon user)
		Default:
			// Powder moves don't work against Grass-type Pokemon
			return b.getOtherPokemon(user).isType(b, Type.GRASS);
			###
	*
***
WildEncounterAlterer:
	Method:
		Header: void alterWildPokemon(ActivePokemon playerFront, WildEncounterInfo encounterData, WildEncounter encounter)
		Invoke: Void
		NonBattleEffects: playerFront
	*
***
MaxLevelWildEncounterEffect:
	Extends: WildEncounterAlterer
	Method:
		Override: True
		Header: void alterWildPokemon(ActivePokemon playerFront, WildEncounterInfo encounterData, WildEncounter encounter)
		Default:
			if (RandomUtils.chanceTest(50)) {
				encounter.setLevel(encounterData.getMaxLevel());
			}
			###
	*
***
RepellingEffect:
	Method:
		Header: boolean shouldRepel(ActivePokemon playerFront, WildEncounter wildPokemon)
		Invoke: Check true
		NonBattleEffects: playerFront
        Begin:
            if (wildPokemon.getLevel() <= playerFront.getLevel() && Game.getPlayer().getRepelInfo().isUsingRepel()) {
                return true;
            }
            ###
	*
***
RepelLowLevelEncounterEffect:
	Extends: RepellingEffect
	Method:
		Override: True
		Header: boolean shouldRepel(ActivePokemon playerFront, WildEncounter wildPokemon)
		Default:
			return RandomUtils.chanceTest(50) && wildPokemon.getLevel() + 5 <= playerFront.getLevel();
			###
	*
***
WildEncounterSelector:
	Method:
		Header: WildEncounterInfo getWildEncounter(ActivePokemon playerFront, WildEncounterInfo[] wildEncounters)
		Invoke: Get
		NonBattleEffects: playerFront
		InvokeName: getForcedWildEncounter
	*
***
TypedWildEncounterSelector:
	Extends: WildEncounterSelector
	Method:
		Header: Type getEncounterType()
	*
	Method:
		Override: True
		Header: WildEncounterInfo getWildEncounter(ActivePokemon playerFront, WildEncounterInfo[] wildEncounters)
		Default:
			if (RandomUtils.chanceTest(50)) {
				List<WildEncounterInfo> typedList = new ArrayList<>();
				for (WildEncounterInfo wildEncounter : wildEncounters) {
					PokemonInfo pokemon = wildEncounter.getPokemonName().getInfo();
					if (pokemon.isType(this.getEncounterType())) {
						typedList.add(wildEncounter);
					}
				}

				if (!typedList.isEmpty()) {
					return RandomUtils.getRandomValue(typedList);
				}
			}

			return null;
			###
	*
***
EncounterRateMultiplier:
	Method:
		Header: double getEncounterRateMultiplier()
		Invoke: Multiply
		InvokeParameters: ActivePokemon playerFront
		NonBattleEffects: playerFront
	*
***
ModifyStageValueEffect:
	Method:
		Header: int modifyStageValue(int modVal)
		Invoke: Update
		Update: modVal
		InvokeParameters: Battle b, ActivePokemon caster, ActivePokemon victim
		MoldBreakerNullCheck: caster == victim ? null : caster
		EffectList: victim
	*
***
StrikeFirstEffect:
    Method:
        Comments: // Returns if the Pokemon should go first within its priority bracket
        Header: boolean strikeFirst(Battle b, ActivePokemon striker)
        Invoke: CheckMessage true getStrikeFirstMessage(striker)
        InvokeName: checkStrikeFirst
        EffectList: striker
    *
    Method:
        Header: String getStrikeFirstMessage(ActivePokemon striker)
    *
***
WeatherEliminatingEffect:
	Method:
		Header: String getEliminateMessage(ActivePokemon eliminator)
	*
	Method:
		Header: boolean eliminateWeather(Weather weather)
		Default:
			return weather.namesies() != EffectNamesies.CLEAR_SKIES;
			###
		InvokeParameters: Battle b, ActivePokemon eliminator
		Invoke: CheckMessage true getEliminateMessage(eliminator)
		EffectList: eliminator
		InvokeName: shouldEliminateWeather
	*
	Extends: EntryEndTurnEffect
	Method:
		Override: True
		Header: void applyEffect(Battle b, ActivePokemon p)
		Default:
			b.addEffect(b.getWeather());
			###
	*
***
EntryEndTurnEffect:
	Extends: EntryEffect, EndTurnEffect
	Method:
		Header: void applyEffect(Battle b, ActivePokemon p)
	*
	Method:
		Override: True
		Header: void applyEndTurn(ActivePokemon victim, Battle b)
		Default:
			applyEffect(b, victim);
			###
	*
	Method:
		Override: True
		Header: void enter(Battle b, ActivePokemon enterer)
		Default:
			applyEffect(b, enterer);
			###
	*
***
SwitchOutEffect:
	Method:
		Header: void switchOut(ActivePokemon switchee)
		Invoke: Void
		SetInvokees:
			List<InvokeEffect> invokees = switchee.getAllEffects(null);
			###
	*
***
WeatherExtendingEffect:
	Method:
		Header: int getExtensionTurns(EffectNamesies weatherType)
		Invoke: Add
		InvokeParameters: Battle b, ActivePokemon p
		EffectList: p
	*
***
SapHealthEffect:
	Extends: ApplyDamageEffect
	Method:
		Header: double sapPercentage()
		Default:
			return .5;
			###
	*
	Method:
		Header: String getSapMessage(ActivePokemon victim)
		Default:
			return victim.getName() + "'s health was sapped!";
			###
	*
	Method:
		Header: void sapHealth(Battle b, ActivePokemon user, ActivePokemon victim, int damageAmount, boolean print)
		Default:
			int sapAmount = (int)Math.ceil(damageAmount*this.sapPercentage());

			// Sap message
			if (print) {
					Messages.add(this.getSapMessage(victim));
			}
			
			// Big Root heals an additional 30%
			if (user.isHoldingItem(b, ItemNamesies.BIG_ROOT)) {
					sapAmount *= 1.3;
			}

			if (victim.hasAbility(AbilityNamesies.LIQUID_OOZE)) {
					Messages.add(victim.getName() + "'s " + AbilityNamesies.LIQUID_OOZE.getName() + " caused " + user.getName() + " to lose health instead!");
					user.reduceHealth(b, sapAmount);
					return;
			}

			// Healers gon' heal
			if (!user.hasEffect(EffectNamesies.HEAL_BLOCK)) {
					user.heal(sapAmount);
			}

			Messages.add(new MessageUpdate().updatePokemon(b, victim));
			Messages.add(new MessageUpdate().updatePokemon(b, user));
			###
	*
	Method:
		Override: True
		Header: void applyDamageEffect(Battle b, ActivePokemon user, ActivePokemon victim, int damage)
		Default:
			this.sapHealth(b, user, victim, damage, true);
			###
	*
***
PowerCountMove:
	Extends: AttackInterface, PowerChangeEffect
	Method:
		Header: boolean doubleDefenseCurled()
	*
	Method:
		Override: True
		Header: double getMultiplier(Battle b, ActivePokemon user, ActivePokemon victim)
		Default:
			return Math.min(user.getCount(), 5)*(this.doubleDefenseCurled() && user.hasEffect(EffectNamesies.USED_DEFENSE_CURL) ? 2 : 1);
			###
	*
***
ItemBlockerEffect:
    Method:
        Parameters: Battle b, ActivePokemon p
        Invoke: Contains
        SetInvokees:
			// Don't include the item because then it's all like ahhhhhh
			List<InvokeEffect> invokees = b.getEffectsList(p, false);
			###
    *
***
OpponentItemBlockerEffect:
    Method:
        Header: boolean blockItem(Battle b, ActivePokemon opp, ItemNamesies item)
        Invoke: Check true
        SetInvokees:
			// Don't include the item because then it's all like ahhhhhh
			List<InvokeEffect> invokees = b.getEffectsList(opp, false);
			###
    *
***
StallingEffect:
    Method:
        Invoke: Contains
        Parameters: Battle b, ActivePokemon p
        EffectList: p
    *
***
DefiniteEscape:
    Extends: InvokeEffect
    Method:
        Header: String getEscapeMessage(Battle b, ActivePokemon sourcerer)
        Default:
            CastSource source = this.getSource().getCastSource();
            if (source.hasSourceName()) {
                return sourcerer.getName() + "'s " + source.getSourceName(b, sourcerer) + " allowed it to escape!";
            }

            return "Got away safely!";
            ###
    *
    Method:
        Header: boolean canEscape()
        Default:
            return true;
            ###
        Parameters: Battle b, ActivePokemon p
        EffectList: p
        Invoke: CheckMessage true getEscapeMessage(b, p)
        InvokeName: canDefinitelyEscape
    *
***
TerrainEffect:
    Method:
        Header: TerrainType getTerrainType()
    *
***
PassableEffect:
***
