# The name of each effect and its contents.
# Blocks are separated by '*'
# Any function must be terminated by ### on a line by itself
# Fields can be specified in any order

Constructor:
	Namesies Enum Namesies Effect
	MinTurns Default -1 Int
	MaxTurns Default -1 Int
	NextTurnSubside Default False Boolean
*
Failure:
	Header boolean applies(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source)
	CanHave Not Default True Boolean Effect.hasEffect(b.getEffects(victim.user()), this.namesies)
*

***

Reflect:
	Int: BarrierEffect
	Barrier: Defense reflect
*
LightScreen:
	Int: BarrierEffect
	Barrier: Sp_Defense light screen
*
Tailwind:
	ToModify: Speed
	ModifyMultiplier: 2 true
	NumTurns: 4
	SubsideMessage: "The effects of tailwind faded."
	CastMessage: user.getName() + " raised the speed of its team!"
*
StickyWeb:
	Int: EntryEffect, RapidSpinRelease, DefogRelease
	Enter:
	if (victim.isLevitating(b)) {
		return;
	}
	
	victim.getAttributes().modifyStage(b.getOtherPokemon(victim.user()), victim, -1, Stat.SPEED, b, CastSource.EFFECT, "The sticky web {change} " + victim.getName() + "'s {statName}!");
	###
	CastMessage: "Sticky web covers everything!"
	RapidSpin: "The sticky web spun away!"
	Defog: "The sticky web dispersed!"
*
StealthRock:
	Int: EntryEffect, RapidSpinRelease, DefogRelease
	Enter: 
	if (victim.hasAbility(Namesies.MAGIC_GUARD_ABILITY)) {
		return;
	}
	
	b.addMessage(victim.getName() + " was hurt by stealth rock!");
	victim.reduceHealthFraction(b, Type.getBasicAdvantage(Type.ROCK, victim, b)/8.0);
	###
	CastMessage: "Floating rocks were scattered all around!"
	RapidSpin: "The floating rocks spun away!"
	Defog: "The floating rocks dispersed!"
*
ToxicSpikes:
	Int: EntryEffect, RapidSpinRelease, DefogRelease
	Field: 
	private int layers;
	###
	Activate: 
	x.layers = 1;
	###
	Enter: 
	if (victim.isLevitating(b)) {
		return;
	}
	
	if (victim.isType(b, Type.POISON)) {
		b.addMessage(victim.getName() + " absorbed the Toxic Spikes!");
		super.active = false;
		return;
	}
	
	ActivePokemon theOtherPokemon = b.getOtherPokemon(victim.user());
	if (Status.applies(StatusCondition.POISONED, b, theOtherPokemon, victim)) {
		if (layers >= 2) {
			PokemonEffect.getEffect(Namesies.BAD_POISON_EFFECT).cast(b, theOtherPokemon, victim, CastSource.EFFECT, false);
		}
		else {
			Status.giveStatus(b, theOtherPokemon, victim, StatusCondition.POISONED);
		}
	}
	###
	CastMessage: "Toxic spikes were scattered all around!"
	CanHave: True
	Cast: 
	Effect spikesies = Effect.getEffect(b.getEffects(victim.user()), this.namesies);
	if (spikesies == null) {
		super.cast(b, caster, victim, source, printCast);
		return;
	}
	
	((ToxicSpikes)spikesies).layers++;
	b.addMessage(getCastMessage(b, caster, victim));
	###
	RapidSpin: "The toxic spikes dispersed!"
	Defog: "The toxic spikes dispersed!"
*
Spikes:
	Int: EntryEffect, RapidSpinRelease, DefogRelease
	Field: 
	private int layers;
	###
	Activate: 
	x.layers = 1;
	###
	Enter: 
	if (victim.isLevitating(b) || victim.hasAbility(Namesies.MAGIC_GUARD_ABILITY)) {
		return;
	}
	
	b.addMessage(victim.getName() + " was hurt by spikes!");
	
	// TODO: Generalize this type of statement
	if (layers == 1) victim.reduceHealthFraction(b, 1/8.0);
	else if (layers == 2) victim.reduceHealthFraction(b, 1/6.0);
	else victim.reduceHealthFraction(b, 1/4.0);
	###
	CastMessage: "Spikes were scattered all around!"
	CanHave: True
	Cast: 
	Effect spikesies = Effect.getEffect(b.getEffects(victim.user()), this.namesies);
	if (spikesies == null) {
		super.cast(b, caster, victim, source, printCast);
		return;
	}
	
	((Spikes)spikesies).layers++;
	b.addMessage(getCastMessage(b, caster, victim));
	###
	RapidSpin: "The spikes dispersed!"
	Defog: "The spikes dispersed!"
*
Wish:
	NumTurns: 1
	NextTurnSubside: True
	Field: 
	private String casterName;
	###
	Activate: 
	x.casterName = casterName;
	###
	Subside: 
	if (p.hasEffect(Namesies.HEAL_BLOCK_EFFECT)) {
		return;
	}
	
	p.healHealthFraction(1/2.0);
	b.addMessage(casterName + "'s wish came true!", p);
	###
	Cast: 
	casterName = caster.getName();
	super.cast(b, caster, victim, source, printCast);
	###
*
LuckyChant:
	NumTurns: 5
	CastMessage: "The lucky chant shielded " + victim.getName() + "'s team from critical hits!"
	SubsideMessage: "The effects of lucky chant wore off."
	Int: CritBlockerEffect
*
FutureSight:
	FutureAttackEffect: Future_Sight
*
DoomDesire:
	FutureAttackEffect: Doom_Desire
*
HealSwitch:
	Field: 
	private String wish;
	###
	Activate: 
	x.wish = wish;
	###
	Int: EntryEffect
	Enter: 
	victim.healHealthFraction(1);
	victim.removeStatus();
	
	b.addMessage(victim.getName() + " health was restored due to the " + wish + "!", victim);
	super.active = false;
	###
	Cast: 
	wish = caster.getAttack().namesies() == Namesies.LUNAR_DANCE_ATTACK ? "lunar dance" : "healing wish";
	super.cast(b, caster, victim, source, printCast);
	###
*
DeadAlly:
	NumTurns: 2
*
PayDay:
	Int: EndBattleEffect
	Field: 
	private int coins;
	###
	Cast: 
	PayDay payday = (PayDay)Effect.getEffect(b.getEffects(true), this.namesies);
	b.addMessage(getCastMessage(b, caster, victim));
	coins = 5*caster.getLevel();
	if (payday == null) {
		b.getPlayer().addEffect(this);
	}
	else {
		payday.coins += coins;
	}
	###
	CastMessage: "Coins scattered everywhere!"
	Activate: 
	x.coins = coins;
	###
	CanHave: True
	EndBattle: 
	b.addMessage(player.getName() + " picked up " + coins + " pokedollars!");
	player.getDatCashMoney(coins);
	###
*
GetDatCashMoneyTwice:
*