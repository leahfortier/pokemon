# The name of each effect and its contents.
# Blocks are separated by '*'
# Any function must be terminated by ### on a line by itself
# Fields can be specified in any order

Constructor:
	Namesies Enum Namesies Effect
	MinTurns Default -1 Int
	MaxTurns Default -1 Int
	NextTurnSubside Default False Boolean
*
Failure:
	Header boolean applies(Battle b, ActivePokemon caster, ActivePokemon victim, CastSource source)
	CanHave Not Default True Boolean Effect.hasEffect(b.getEffects(victim.user()), this.namesies)
*

***

Reflect:
	Int: StatChangingEffect, DefogRelease
	NumTurns: 5
	ModifyStat: 
	return stat*(s == Stat.DEFENSE && !opp.hasAbility(Namesies.INFILTRATOR_ABILITY) ? 2 : 1);
	###
	CastMessage: user.getName() + " raised the defense of its team!"
	SubsideMessage: "The effects of reflect faded."
	Defog: "The effects of reflect faded."
	Cast: 
	super.cast(b, caster, victim, source, printCast);
	if (caster.isHoldingItem(b, Namesies.LIGHT_CLAY_ITEM))
	{
		Effect.getEffect(b.getEffects(victim.user()), this.namesies).setTurns(8);
	}
	###
*
LightScreen:
	Int: StatChangingEffect, DefogRelease
	NumTurns: 5
	ModifyStat: 
	return stat*(s == Stat.SP_DEFENSE && !opp.hasAbility(Namesies.INFILTRATOR_ABILITY) ? 2 : 1);
	###
	CastMessage: user.getName() + " raised the special defense of its team!"
	SubsideMessage: "The effects of light screen faded."
	Defog: "The effects of light screen faded."
	Cast: 
	super.cast(b, caster, victim, source, printCast);
	if (caster.isHoldingItem(b, Namesies.LIGHT_CLAY_ITEM)) 
	{
		Effect.getEffect(b.getEffects(victim.user()), this.namesies).setTurns(8);
	}
	###
*
Tailwind:
	Int: StatChangingEffect
	ModifyStat: 
	return stat*(s == Stat.SPEED ? 2 : 1);
	###
	NumTurns: 4
	SubsideMessage: "The effects of tailwind faded."
	CastMessage: user.getName() + " raised the speed of its team!"
*
StealthRock:
	Int: EntryEffect, RapidSpinRelease, DefogRelease
	Enter: 
	if (victim.hasAbility(Namesies.MAGIC_GUARD_ABILITY)) 
	{
		return;
	}
	
	b.addMessage(victim.getName() + " was hurt by stealth rock!");
	victim.reduceHealthFraction(b, Type.getBasicAdvantage(Type.ROCK, victim, b)/8.0);
	###
	CastMessage: "Floating rocks were scattered all around!"
	RapidSpin: "The floating rocks spun away!"
	Defog: "The floating rocks dispersed!"
*
ToxicSpikes:
	Int: EntryEffect, RapidSpinRelease, DefogRelease
	Field: 
	private int layers;
	###
	Activate: 
	x.layers = 1;
	###
	Enter: 
	if (victim.isLevitating(b)) 
	{
		return;
	}
	
	if (victim.isType(b, Type.POISON))
	{
		b.addMessage(victim.getName() + " absorbed the Toxic Spikes!");
		super.active = false;
		return;
	}
	
	ActivePokemon theOtherPokemon = b.getOtherPokemon(victim.user());
	if (Status.applies(StatusCondition.POISONED, b, theOtherPokemon, victim))
	{
		if (layers >= 2) 
		{
			PokemonEffect.getEffect(Namesies.BAD_POISON_EFFECT).cast(b, theOtherPokemon, victim, CastSource.EFFECT, false);
		}
		else 
		{
			Status.giveStatus(b, theOtherPokemon, victim, StatusCondition.POISONED);
		}
	}
	###
	CastMessage: "Toxic spikes were scattered all around!"
	CanHave: True
	Cast: 
	Effect spikesies = Effect.getEffect(b.getEffects(victim.user()), this.namesies);
	if (spikesies == null)
	{
		super.cast(b, caster, victim, source, printCast);
		return;
	}
	
	((ToxicSpikes)spikesies).layers++;
	b.addMessage(getCastMessage(b, caster, victim));
	###
	RapidSpin: "The toxic spikes dispersed!"
	Defog: "The toxic spikes dispersed!"
*
Spikes:
	Int: EntryEffect, RapidSpinRelease, DefogRelease
	Field: 
	private int layers;
	###
	Activate: 
	x.layers = 1;
	###
	Enter: 
	if (victim.isLevitating(b) || victim.hasAbility(Namesies.MAGIC_GUARD_ABILITY))
	{
		return;
	}
	
	b.addMessage(victim.getName() + " was hurt by spikes!");
	if (layers == 1) victim.reduceHealthFraction(b, 1/8.0);
	else if (layers == 2) victim.reduceHealthFraction(b, 1/6.0);
	else victim.reduceHealthFraction(b, 1/4.0);
	###
	CastMessage: "Spikes were scattered all around!"
	CanHave: True
	Cast: 
	Effect spikesies = Effect.getEffect(b.getEffects(victim.user()), this.namesies);
	if (spikesies == null)
	{
		super.cast(b, caster, victim, source, printCast);
		return;
	}
	
	((Spikes)spikesies).layers++;
	b.addMessage(getCastMessage(b, caster, victim));
	###
	RapidSpin: "The spikes dispersed!"
	Defog: "The spikes dispersed!"
*
Wish:
	NumTurns: 1
	NextTurnSubside: True
	Field: 
	private String casterName;
	###
	Activate: 
	x.casterName = casterName;
	###
	Subside: 
	if (p.hasEffect(Namesies.HEAL_BLOCK_EFFECT))
	{
		return;
	}
	
	p.healHealthFraction(1/2.0);
	b.addMessage(casterName + "'s wish came true!", p.getHP(), p.user());
	###
	Cast: 
	casterName = caster.getName();
	super.cast(b, caster, victim, source, printCast);
	###
*
LuckyChant:
	NumTurns: 5
	CastMessage: "The lucky chant shielded " + victim.getName() + "'s team from critical hits!"
	SubsideMessage: "The effects of lucky chant wore off."
	Int: CritBlockerEffect
*
FutureSight:
	NumTurns: 2
	NextTurnSubside: True
	Field: 
	private ActivePokemon theSeeer;
	###
	Activate: 
	x.theSeeer = theSeeer;
	###
	Subside: 
	b.addMessage(p.getName() + " took " + theSeeer.getName() + "'s attack!");
	theSeeer.setMove(new Move(Attack.getAttack(Namesies.FUTURE_SIGHT_ATTACK)));
	theSeeer.getAttack().applyDamage(theSeeer, p, b);
	###
	Cast: 
	theSeeer = caster;
	super.cast(b, caster, victim, source, printCast);
	###
	CastMessage: theSeeer.getName() + " foresaw an attack!"
*
DoomDesire:
	NumTurns: 2
	NextTurnSubside: True
	Field: 
	private ActivePokemon theSeeer;
	###
	Activate: 
	x.theSeeer = theSeeer;
	###
	Subside: 
	b.addMessage(p.getName() + " took " + theSeeer.getName() + "'s attack!");
	theSeeer.setMove(new Move(Attack.getAttack(Namesies.DOOM_DESIRE_ATTACK)));
	theSeeer.getAttack().applyDamage(theSeeer, p, b);
	###
	Cast: 
	theSeeer = caster;
	super.cast(b, caster, victim, source, printCast);
	###
	CastMessage: theSeeer.getName() + " foresaw an attack!"
*
HealSwitch:
	Field: 
	private String wish;
	###
	Activate: 
	x.wish = wish;
	###
	Int: EntryEffect
	Enter: 
	victim.healHealthFraction(1);
	victim.removeStatus();
	b.addMessage(victim.getName() + " health was restored due to the " + wish + "!", victim.getHP(), victim.user());
	b.addMessage("", StatusCondition.NONE, victim.user());
	super.active = false;
	###
	Cast: 
	wish = caster.getAttack().namesies() == Namesies.LUNAR_DANCE_ATTACK ? "lunar dance" : "healing wish";
	super.cast(b, caster, victim, source, printCast);
	###
*
DeadAlly:
	NumTurns: 2
*
PayDay:
	Int: EndBattleEffect
	Field: 
	private int coins;
	###
	Cast: 
	PayDay payday = (PayDay)Effect.getEffect(b.getEffects(true), this.namesies);
	b.addMessage(getCastMessage(b, caster, victim));
	coins = 5*caster.getLevel();
	if (payday == null) b.getPlayer().addEffect(this);
	else payday.coins += coins;
	###
	CastMessage: "Coins scattered everywhere!"
	Activate: 
	x.coins = coins;
	###
	CanHave: True
	EndBattle: 
	b.addMessage(player.getName() + " picked up " + coins + " pokedollars!");
	player.getDatCashMoney(coins);
	###
*
DoubleMoney:
*